{"version":3,"sources":["../../src/internal/index.ts","../../node_modules/.pnpm/@ai-sdk+provider@3.0.0/node_modules/@ai-sdk/provider/src/errors/ai-sdk-error.ts","../../node_modules/.pnpm/@ai-sdk+provider@3.0.0/node_modules/@ai-sdk/provider/src/errors/api-call-error.ts","../../node_modules/.pnpm/@ai-sdk+provider@3.0.0/node_modules/@ai-sdk/provider/src/errors/empty-response-body-error.ts","../../node_modules/.pnpm/@ai-sdk+provider@3.0.0/node_modules/@ai-sdk/provider/src/errors/get-error-message.ts","../../node_modules/.pnpm/@ai-sdk+provider@3.0.0/node_modules/@ai-sdk/provider/src/errors/invalid-argument-error.ts","../../node_modules/.pnpm/@ai-sdk+provider@3.0.0/node_modules/@ai-sdk/provider/src/errors/invalid-prompt-error.ts","../../node_modules/.pnpm/@ai-sdk+provider@3.0.0/node_modules/@ai-sdk/provider/src/errors/invalid-response-data-error.ts","../../node_modules/.pnpm/@ai-sdk+provider@3.0.0/node_modules/@ai-sdk/provider/src/errors/json-parse-error.ts","../../node_modules/.pnpm/@ai-sdk+provider@3.0.0/node_modules/@ai-sdk/provider/src/errors/load-api-key-error.ts","../../node_modules/.pnpm/@ai-sdk+provider@3.0.0/node_modules/@ai-sdk/provider/src/errors/load-setting-error.ts","../../node_modules/.pnpm/@ai-sdk+provider@3.0.0/node_modules/@ai-sdk/provider/src/errors/no-content-generated-error.ts","../../node_modules/.pnpm/@ai-sdk+provider@3.0.0/node_modules/@ai-sdk/provider/src/errors/no-such-model-error.ts","../../node_modules/.pnpm/@ai-sdk+provider@3.0.0/node_modules/@ai-sdk/provider/src/errors/too-many-embedding-values-for-call-error.ts","../../node_modules/.pnpm/@ai-sdk+provider@3.0.0/node_modules/@ai-sdk/provider/src/errors/type-validation-error.ts","../../node_modules/.pnpm/@ai-sdk+provider@3.0.0/node_modules/@ai-sdk/provider/src/errors/unsupported-functionality-error.ts","../../node_modules/.pnpm/@ai-sdk+provider@3.0.0/node_modules/@ai-sdk/provider/src/json-value/is-json.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/combine-headers.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/convert-async-iterator-to-readable-stream.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/create-tool-name-mapping.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/delay.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/delayed-promise.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/extract-response-headers.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/uint8-utils.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/convert-image-model-file-to-data-uri.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/convert-to-form-data.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/download-error.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/download-blob.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/generate-id.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/get-error-message.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/get-from-api.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/handle-fetch-error.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/is-abort-error.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/get-runtime-environment-user-agent.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/normalize-headers.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/with-user-agent-suffix.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/version.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/inject-json-instruction.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/is-non-nullable.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/is-url-supported.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/load-api-key.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/load-optional-setting.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/load-setting.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/media-type-to-extension.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/parse-json.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/secure-json-parse.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/validate-types.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/schema.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/add-additional-properties-to-json-schema.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/to-json-schema/zod3-to-json-schema/options.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/to-json-schema/zod3-to-json-schema/select-parser.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/any.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/array.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/bigint.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/boolean.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/branded.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/catch.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/date.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/default.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/effects.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/enum.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/intersection.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/literal.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/record.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/string.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/map.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/native-enum.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/never.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/null.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/union.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/nullable.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/number.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/object.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/optional.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/pipeline.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/promise.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/set.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/tuple.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/undefined.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/unknown.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/to-json-schema/zod3-to-json-schema/parsers/readonly.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/to-json-schema/zod3-to-json-schema/get-relative-path.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/to-json-schema/zod3-to-json-schema/parse-def.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/to-json-schema/zod3-to-json-schema/refs.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/to-json-schema/zod3-to-json-schema/zod3-to-json-schema.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/parse-json-event-stream.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/parse-provider-options.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/post-to-api.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/types/tool.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/provider-tool-factory.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/remove-undefined-entries.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/resolve.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/response-handler.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/without-trailing-slash.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/is-async-iterable.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/types/execute-tool.ts","../../node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/src/index.ts","../../node_modules/.pnpm/eventsource-parser@3.0.6/node_modules/eventsource-parser/src/errors.ts","../../node_modules/.pnpm/eventsource-parser@3.0.6/node_modules/eventsource-parser/src/parse.ts","../../node_modules/.pnpm/eventsource-parser@3.0.6/node_modules/eventsource-parser/src/stream.ts","../../src/schemas/reasoning-details.ts","../../src/utils/type-guards.ts","../../src/schemas/format.ts","../../src/schemas/error-response.ts","../../src/schemas/provider-metadata.ts","../../src/utils/map-finish-reason.ts","../../src/utils/reasoning-details-duplicate-tracker.ts","../../src/types/openrouter-chat-completions-input.ts","../../src/chat/is-url.ts","../../src/chat/file-url-utils.ts","../../src/chat/convert-to-openrouter-chat-messages.ts","../../src/chat/get-tool-choice.ts","../../src/chat/schemas.ts","../../src/schemas/image.ts","../../src/chat/index.ts","../../src/completion/convert-to-openrouter-completion-prompt.ts","../../src/completion/schemas.ts","../../src/completion/index.ts","../../src/embedding/schemas.ts","../../src/embedding/index.ts","../../src/image/schemas.ts","../../src/image/index.ts"],"sourcesContent":["export * from '../chat';\nexport * from '../completion';\nexport * from '../embedding';\nexport * from '../image';\nexport * from '../types';\nexport * from '../types/openrouter-chat-settings';\nexport * from '../types/openrouter-completion-settings';\nexport * from '../types/openrouter-image-settings';\n","/**\n * Symbol used for identifying AI SDK Error instances.\n * Enables checking if an error is an instance of AISDKError across package versions.\n */\nconst marker = 'vercel.ai.error';\nconst symbol = Symbol.for(marker);\n\n/**\n * Custom error class for AI SDK related errors.\n * @extends Error\n */\nexport class AISDKError extends Error {\n  private readonly [symbol] = true; // used in isInstance\n\n  /**\n   * The underlying cause of the error, if any.\n   */\n  readonly cause?: unknown;\n\n  /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */\n  constructor({\n    name,\n    message,\n    cause,\n  }: {\n    name: string;\n    message: string;\n    cause?: unknown;\n  }) {\n    super(message);\n\n    this.name = name;\n    this.cause = cause;\n  }\n\n  /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */\n  static isInstance(error: unknown): error is AISDKError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  protected static hasMarker(error: unknown, marker: string): boolean {\n    const markerSymbol = Symbol.for(marker);\n    return (\n      error != null &&\n      typeof error === 'object' &&\n      markerSymbol in error &&\n      typeof error[markerSymbol] === 'boolean' &&\n      error[markerSymbol] === true\n    );\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_APICallError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class APICallError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly url: string;\n  readonly requestBodyValues: unknown;\n  readonly statusCode?: number;\n\n  readonly responseHeaders?: Record<string, string>;\n  readonly responseBody?: string;\n\n  readonly isRetryable: boolean;\n  readonly data?: unknown;\n\n  constructor({\n    message,\n    url,\n    requestBodyValues,\n    statusCode,\n    responseHeaders,\n    responseBody,\n    cause,\n    isRetryable = statusCode != null &&\n      (statusCode === 408 || // request timeout\n        statusCode === 409 || // conflict\n        statusCode === 429 || // too many requests\n        statusCode >= 500), // server error\n    data,\n  }: {\n    message: string;\n    url: string;\n    requestBodyValues: unknown;\n    statusCode?: number;\n    responseHeaders?: Record<string, string>;\n    responseBody?: string;\n    cause?: unknown;\n    isRetryable?: boolean;\n    data?: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.url = url;\n    this.requestBodyValues = requestBodyValues;\n    this.statusCode = statusCode;\n    this.responseHeaders = responseHeaders;\n    this.responseBody = responseBody;\n    this.isRetryable = isRetryable;\n    this.data = data;\n  }\n\n  static isInstance(error: unknown): error is APICallError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_EmptyResponseBodyError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class EmptyResponseBodyError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message = 'Empty response body' }: { message?: string } = {}) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is EmptyResponseBodyError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","export function getErrorMessage(error: unknown | undefined) {\n  if (error == null) {\n    return 'unknown error';\n  }\n\n  if (typeof error === 'string') {\n    return error;\n  }\n\n  if (error instanceof Error) {\n    return error.message;\n  }\n\n  return JSON.stringify(error);\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidArgumentError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * A function argument is invalid.\n */\nexport class InvalidArgumentError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly argument: string;\n\n  constructor({\n    message,\n    cause,\n    argument,\n  }: {\n    argument: string;\n    message: string;\n    cause?: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.argument = argument;\n  }\n\n  static isInstance(error: unknown): error is InvalidArgumentError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidPromptError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * A prompt is invalid. This error should be thrown by providers when they cannot\n * process a prompt.\n */\nexport class InvalidPromptError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly prompt: unknown;\n\n  constructor({\n    prompt,\n    message,\n    cause,\n  }: {\n    prompt: unknown;\n    message: string;\n    cause?: unknown;\n  }) {\n    super({ name, message: `Invalid prompt: ${message}`, cause });\n\n    this.prompt = prompt;\n  }\n\n  static isInstance(error: unknown): error is InvalidPromptError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidResponseDataError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * Server returned a response with invalid data content.\n * This should be thrown by providers when they cannot parse the response from the API.\n */\nexport class InvalidResponseDataError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly data: unknown;\n\n  constructor({\n    data,\n    message = `Invalid response data: ${JSON.stringify(data)}.`,\n  }: {\n    data: unknown;\n    message?: string;\n  }) {\n    super({ name, message });\n\n    this.data = data;\n  }\n\n  static isInstance(error: unknown): error is InvalidResponseDataError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\nimport { getErrorMessage } from './get-error-message';\n\nconst name = 'AI_JSONParseError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class JSONParseError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly text: string;\n\n  constructor({ text, cause }: { text: string; cause: unknown }) {\n    super({\n      name,\n      message:\n        `JSON parsing failed: ` +\n        `Text: ${text}.\\n` +\n        `Error message: ${getErrorMessage(cause)}`,\n      cause,\n    });\n\n    this.text = text;\n  }\n\n  static isInstance(error: unknown): error is JSONParseError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_LoadAPIKeyError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class LoadAPIKeyError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message }: { message: string }) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is LoadAPIKeyError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_LoadSettingError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class LoadSettingError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message }: { message: string }) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is LoadSettingError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_NoContentGeneratedError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\nThrown when the AI provider fails to generate any content.\n */\nexport class NoContentGeneratedError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({\n    message = 'No content generated.',\n  }: { message?: string } = {}) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is NoContentGeneratedError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_NoSuchModelError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class NoSuchModelError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly modelId: string;\n  readonly modelType:\n    | 'languageModel'\n    | 'embeddingModel'\n    | 'imageModel'\n    | 'transcriptionModel'\n    | 'speechModel'\n    | 'rerankingModel';\n\n  constructor({\n    errorName = name,\n    modelId,\n    modelType,\n    message = `No such ${modelType}: ${modelId}`,\n  }: {\n    errorName?: string;\n    modelId: string;\n    modelType:\n      | 'languageModel'\n      | 'embeddingModel'\n      | 'imageModel'\n      | 'transcriptionModel'\n      | 'speechModel'\n      | 'rerankingModel';\n    message?: string;\n  }) {\n    super({ name: errorName, message });\n\n    this.modelId = modelId;\n    this.modelType = modelType;\n  }\n\n  static isInstance(error: unknown): error is NoSuchModelError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_TooManyEmbeddingValuesForCallError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class TooManyEmbeddingValuesForCallError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly provider: string;\n  readonly modelId: string;\n  readonly maxEmbeddingsPerCall: number;\n  readonly values: Array<unknown>;\n\n  constructor(options: {\n    provider: string;\n    modelId: string;\n    maxEmbeddingsPerCall: number;\n    values: Array<unknown>;\n  }) {\n    super({\n      name,\n      message:\n        `Too many values for a single embedding call. ` +\n        `The ${options.provider} model \"${options.modelId}\" can only embed up to ` +\n        `${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`,\n    });\n\n    this.provider = options.provider;\n    this.modelId = options.modelId;\n    this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;\n    this.values = options.values;\n  }\n\n  static isInstance(\n    error: unknown,\n  ): error is TooManyEmbeddingValuesForCallError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\nimport { getErrorMessage } from './get-error-message';\n\nconst name = 'AI_TypeValidationError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class TypeValidationError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly value: unknown;\n\n  constructor({ value, cause }: { value: unknown; cause: unknown }) {\n    super({\n      name,\n      message:\n        `Type validation failed: ` +\n        `Value: ${JSON.stringify(value)}.\\n` +\n        `Error message: ${getErrorMessage(cause)}`,\n      cause,\n    });\n\n    this.value = value;\n  }\n\n  static isInstance(error: unknown): error is TypeValidationError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * Wraps an error into a TypeValidationError.\n   * If the cause is already a TypeValidationError with the same value, it returns the cause.\n   * Otherwise, it creates a new TypeValidationError.\n   *\n   * @param {Object} params - The parameters for wrapping the error.\n   * @param {unknown} params.value - The value that failed validation.\n   * @param {unknown} params.cause - The original error or cause of the validation failure.\n   * @returns {TypeValidationError} A TypeValidationError instance.\n   */\n  static wrap({\n    value,\n    cause,\n  }: {\n    value: unknown;\n    cause: unknown;\n  }): TypeValidationError {\n    return TypeValidationError.isInstance(cause) && cause.value === value\n      ? cause\n      : new TypeValidationError({ value, cause });\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_UnsupportedFunctionalityError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class UnsupportedFunctionalityError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly functionality: string;\n\n  constructor({\n    functionality,\n    message = `'${functionality}' functionality not supported.`,\n  }: {\n    functionality: string;\n    message?: string;\n  }) {\n    super({ name, message });\n    this.functionality = functionality;\n  }\n\n  static isInstance(error: unknown): error is UnsupportedFunctionalityError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { JSONArray, JSONObject, JSONValue } from './json-value';\n\nexport function isJSONValue(value: unknown): value is JSONValue {\n  if (\n    value === null ||\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    typeof value === 'boolean'\n  ) {\n    return true;\n  }\n\n  if (Array.isArray(value)) {\n    return value.every(isJSONValue);\n  }\n\n  if (typeof value === 'object') {\n    return Object.entries(value).every(\n      ([key, val]) =>\n        typeof key === 'string' && (val === undefined || isJSONValue(val)),\n    );\n  }\n\n  return false;\n}\n\nexport function isJSONArray(value: unknown): value is JSONArray {\n  return Array.isArray(value) && value.every(isJSONValue);\n}\n\nexport function isJSONObject(value: unknown): value is JSONObject {\n  return (\n    value != null &&\n    typeof value === 'object' &&\n    Object.entries(value).every(\n      ([key, val]) =>\n        typeof key === 'string' && (val === undefined || isJSONValue(val)),\n    )\n  );\n}\n","export function combineHeaders(\n  ...headers: Array<Record<string, string | undefined> | undefined>\n): Record<string, string | undefined> {\n  return headers.reduce(\n    (combinedHeaders, currentHeaders) => ({\n      ...combinedHeaders,\n      ...(currentHeaders ?? {}),\n    }),\n    {},\n  ) as Record<string, string | undefined>;\n}\n","/**\n * Converts an AsyncIterator to a ReadableStream.\n *\n * @template T - The type of elements produced by the AsyncIterator.\n * @param { <T>} iterator - The AsyncIterator to convert.\n * @returns {ReadableStream<T>} - A ReadableStream that provides the same data as the AsyncIterator.\n */\nexport function convertAsyncIteratorToReadableStream<T>(\n  iterator: AsyncIterator<T>,\n): ReadableStream<T> {\n  let cancelled = false;\n\n  return new ReadableStream<T>({\n    /**\n     * Called when the consumer wants to pull more data from the stream.\n     *\n     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.\n     * @returns {Promise<void>}\n     */\n    async pull(controller) {\n      if (cancelled) return;\n      try {\n        const { value, done } = await iterator.next();\n        if (done) {\n          controller.close();\n        } else {\n          controller.enqueue(value);\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    /**\n     * Called when the consumer cancels the stream.\n     */\n    async cancel(reason?: unknown) {\n      cancelled = true;\n      if (iterator.return) {\n        try {\n          await iterator.return(reason);\n        } catch {\n          // intentionally ignore errors during cancellation\n        }\n      }\n    },\n  });\n}\n","import {\n  LanguageModelV3FunctionTool,\n  LanguageModelV3ProviderTool,\n} from '@ai-sdk/provider';\n\n/**\n * Interface for mapping between custom tool names and provider tool names.\n */\nexport interface ToolNameMapping {\n  /**\n   * Maps a custom tool name (used by the client) to the provider's tool name.\n   * If the custom tool name does not have a mapping, returns the input name.\n   *\n   * @param customToolName - The custom name of the tool defined by the client.\n   * @returns The corresponding provider tool name, or the input name if not mapped.\n   */\n  toProviderToolName: (customToolName: string) => string;\n\n  /**\n   * Maps a provider tool name to the custom tool name used by the client.\n   * If the provider tool name does not have a mapping, returns the input name.\n   *\n   * @param providerToolName - The name of the tool as understood by the provider.\n   * @returns The corresponding custom tool name, or the input name if not mapped.\n   */\n  toCustomToolName: (providerToolName: string) => string;\n}\n\n/**\n * @param tools - Tools that were passed to the language model.\n * @param providerToolNames - Maps the provider tool ids to the provider tool names.\n */\nexport function createToolNameMapping({\n  tools = [],\n  providerToolNames,\n}: {\n  /**\n   * Tools that were passed to the language model.\n   */\n  tools:\n    | Array<LanguageModelV3FunctionTool | LanguageModelV3ProviderTool>\n    | undefined;\n\n  /**\n   * Maps the provider tool ids to the provider tool names.\n   */\n  providerToolNames: Record<`${string}.${string}`, string>;\n}): ToolNameMapping {\n  const customToolNameToProviderToolName: Record<string, string> = {};\n  const providerToolNameToCustomToolName: Record<string, string> = {};\n\n  for (const tool of tools) {\n    if (tool.type === 'provider' && tool.id in providerToolNames) {\n      const providerToolName = providerToolNames[tool.id];\n      customToolNameToProviderToolName[tool.name] = providerToolName;\n      providerToolNameToCustomToolName[providerToolName] = tool.name;\n    }\n  }\n\n  return {\n    toProviderToolName: (customToolName: string) =>\n      customToolNameToProviderToolName[customToolName] ?? customToolName,\n    toCustomToolName: (providerToolName: string) =>\n      providerToolNameToCustomToolName[providerToolName] ?? providerToolName,\n  };\n}\n","/**\n * Creates a Promise that resolves after a specified delay\n * @param delayInMs - The delay duration in milliseconds. If null or undefined, resolves immediately.\n * @param signal - Optional AbortSignal to cancel the delay\n * @returns A Promise that resolves after the specified delay\n * @throws {DOMException} When the signal is aborted\n */\nexport async function delay(\n  delayInMs?: number | null,\n  options?: {\n    abortSignal?: AbortSignal;\n  },\n): Promise<void> {\n  if (delayInMs == null) {\n    return Promise.resolve();\n  }\n\n  const signal = options?.abortSignal;\n\n  return new Promise<void>((resolve, reject) => {\n    if (signal?.aborted) {\n      reject(createAbortError());\n      return;\n    }\n\n    const timeoutId = setTimeout(() => {\n      cleanup();\n      resolve();\n    }, delayInMs);\n\n    const cleanup = () => {\n      clearTimeout(timeoutId);\n      signal?.removeEventListener('abort', onAbort);\n    };\n\n    const onAbort = () => {\n      cleanup();\n      reject(createAbortError());\n    };\n\n    signal?.addEventListener('abort', onAbort);\n  });\n}\n\nfunction createAbortError(): DOMException {\n  return new DOMException('Delay was aborted', 'AbortError');\n}\n","/**\n * Delayed promise. It is only constructed once the value is accessed.\n * This is useful to avoid unhandled promise rejections when the promise is created\n * but not accessed.\n */\nexport class DelayedPromise<T> {\n  private status:\n    | { type: 'pending' }\n    | { type: 'resolved'; value: T }\n    | { type: 'rejected'; error: unknown } = { type: 'pending' };\n  private _promise: Promise<T> | undefined;\n  private _resolve: undefined | ((value: T) => void) = undefined;\n  private _reject: undefined | ((error: unknown) => void) = undefined;\n\n  get promise(): Promise<T> {\n    if (this._promise) {\n      return this._promise;\n    }\n\n    this._promise = new Promise<T>((resolve, reject) => {\n      if (this.status.type === 'resolved') {\n        resolve(this.status.value);\n      } else if (this.status.type === 'rejected') {\n        reject(this.status.error);\n      }\n\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n\n    return this._promise;\n  }\n\n  resolve(value: T): void {\n    this.status = { type: 'resolved', value };\n\n    if (this._promise) {\n      this._resolve?.(value);\n    }\n  }\n\n  reject(error: unknown): void {\n    this.status = { type: 'rejected', error };\n\n    if (this._promise) {\n      this._reject?.(error);\n    }\n  }\n\n  isResolved(): boolean {\n    return this.status.type === 'resolved';\n  }\n\n  isRejected(): boolean {\n    return this.status.type === 'rejected';\n  }\n\n  isPending(): boolean {\n    return this.status.type === 'pending';\n  }\n}\n","/**\nExtracts the headers from a response object and returns them as a key-value object.\n\n@param response - The response object to extract headers from.\n@returns The headers as a key-value object.\n*/\nexport function extractResponseHeaders(response: Response) {\n  return Object.fromEntries<string>([...response.headers]);\n}\n","// btoa and atob need to be invoked as a function call, not as a method call.\n// Otherwise CloudFlare will throw a\n// \"TypeError: Illegal invocation: function called with incorrect this reference\"\nconst { btoa, atob } = globalThis;\n\nexport function convertBase64ToUint8Array(base64String: string) {\n  const base64Url = base64String.replace(/-/g, '+').replace(/_/g, '/');\n  const latin1string = atob(base64Url);\n  return Uint8Array.from(latin1string, byte => byte.codePointAt(0)!);\n}\n\nexport function convertUint8ArrayToBase64(array: Uint8Array): string {\n  let latin1string = '';\n\n  // Note: regular for loop to support older JavaScript versions that\n  // do not support for..of on Uint8Array\n  for (let i = 0; i < array.length; i++) {\n    latin1string += String.fromCodePoint(array[i]);\n  }\n\n  return btoa(latin1string);\n}\n\nexport function convertToBase64(value: string | Uint8Array): string {\n  return value instanceof Uint8Array ? convertUint8ArrayToBase64(value) : value;\n}\n","import { ImageModelV3File } from '@ai-sdk/provider';\nimport { convertUint8ArrayToBase64 } from './uint8-utils';\n\n/**\n * Convert an ImageModelV3File to a URL or data URI string.\n *\n * If the file is a URL, it returns the URL as-is.\n * If the file is base64 data, it returns a data URI with the base64 data.\n * If the file is a Uint8Array, it converts it to base64 and returns a data URI.\n */\nexport function convertImageModelFileToDataUri(file: ImageModelV3File): string {\n  if (file.type === 'url') return file.url;\n\n  return `data:${file.mediaType};base64,${\n    typeof file.data === 'string'\n      ? file.data\n      : convertUint8ArrayToBase64(file.data)\n  }`;\n}\n","/**\n * Converts an input object to FormData for multipart/form-data requests.\n *\n * Handles the following cases:\n * - `null` or `undefined` values are skipped\n * - Arrays with a single element are appended as a single value\n * - Arrays with multiple elements are appended with `[]` suffix (e.g., `image[]`)\n *   unless `useArrayBrackets` is set to `false`\n * - All other values are appended directly\n *\n * @param input - The input object to convert. Use a generic type for type validation.\n * @param options - Optional configuration object.\n * @param options.useArrayBrackets - Whether to add `[]` suffix for multi-element arrays.\n *   Defaults to `true`. Set to `false` for APIs that expect repeated keys without brackets.\n * @returns A FormData object containing the input values.\n *\n * @example\n * ```ts\n * type MyInput = {\n *   model: string;\n *   prompt: string;\n *   images: Blob[];\n * };\n *\n * const formData = convertToFormData<MyInput>({\n *   model: 'gpt-image-1',\n *   prompt: 'A cat',\n *   images: [blob1, blob2],\n * });\n * ```\n */\nexport function convertToFormData<T extends Record<string, unknown>>(\n  input: T,\n  options: { useArrayBrackets?: boolean } = {},\n): FormData {\n  const { useArrayBrackets = true } = options;\n  const formData = new FormData();\n\n  for (const [key, value] of Object.entries(input)) {\n    if (value == null) {\n      continue;\n    }\n\n    if (Array.isArray(value)) {\n      if (value.length === 1) {\n        formData.append(key, value[0] as string | Blob);\n        continue;\n      }\n\n      const arrayKey = useArrayBrackets ? `${key}[]` : key;\n      for (const item of value) {\n        formData.append(arrayKey, item as string | Blob);\n      }\n      continue;\n    }\n\n    formData.append(key, value as string | Blob);\n  }\n\n  return formData;\n}\n","import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_DownloadError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class DownloadError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly url: string;\n  readonly statusCode?: number;\n  readonly statusText?: string;\n\n  constructor({\n    url,\n    statusCode,\n    statusText,\n    cause,\n    message = cause == null\n      ? `Failed to download ${url}: ${statusCode} ${statusText}`\n      : `Failed to download ${url}: ${cause}`,\n  }: {\n    url: string;\n    statusCode?: number;\n    statusText?: string;\n    message?: string;\n    cause?: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.url = url;\n    this.statusCode = statusCode;\n    this.statusText = statusText;\n  }\n\n  static isInstance(error: unknown): error is DownloadError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { DownloadError } from './download-error';\n\n/**\n * Download a file from a URL and return it as a Blob.\n *\n * @param url - The URL to download from.\n * @returns A Promise that resolves to the downloaded Blob.\n *\n * @throws DownloadError if the download fails.\n */\nexport async function downloadBlob(url: string): Promise<Blob> {\n  try {\n    const response = await fetch(url);\n\n    if (!response.ok) {\n      throw new DownloadError({\n        url,\n        statusCode: response.status,\n        statusText: response.statusText,\n      });\n    }\n\n    return await response.blob();\n  } catch (error) {\n    if (DownloadError.isInstance(error)) {\n      throw error;\n    }\n\n    throw new DownloadError({ url, cause: error });\n  }\n}\n","import { InvalidArgumentError } from '@ai-sdk/provider';\n\n/**\nCreates an ID generator.\nThe total length of the ID is the sum of the prefix, separator, and random part length.\nNot cryptographically secure.\n\n@param alphabet - The alphabet to use for the ID. Default: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.\n@param prefix - The prefix of the ID to generate. Optional.\n@param separator - The separator between the prefix and the random part of the ID. Default: '-'.\n@param size - The size of the random part of the ID to generate. Default: 16.\n */\nexport const createIdGenerator = ({\n  prefix,\n  size = 16,\n  alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n  separator = '-',\n}: {\n  prefix?: string;\n  separator?: string;\n  size?: number;\n  alphabet?: string;\n} = {}): IdGenerator => {\n  const generator = () => {\n    const alphabetLength = alphabet.length;\n    const chars = new Array(size);\n    for (let i = 0; i < size; i++) {\n      chars[i] = alphabet[(Math.random() * alphabetLength) | 0];\n    }\n    return chars.join('');\n  };\n\n  if (prefix == null) {\n    return generator;\n  }\n\n  // check that the prefix is not part of the alphabet (otherwise prefix checking can fail randomly)\n  if (alphabet.includes(separator)) {\n    throw new InvalidArgumentError({\n      argument: 'separator',\n      message: `The separator \"${separator}\" must not be part of the alphabet \"${alphabet}\".`,\n    });\n  }\n\n  return () => `${prefix}${separator}${generator()}`;\n};\n\n/**\nA function that generates an ID.\n */\nexport type IdGenerator = () => string;\n\n/**\nGenerates a 16-character random string to use for IDs.\nNot cryptographically secure.\n */\nexport const generateId = createIdGenerator();\n","export function getErrorMessage(error: unknown | undefined) {\n  if (error == null) {\n    return 'unknown error';\n  }\n\n  if (typeof error === 'string') {\n    return error;\n  }\n\n  if (error instanceof Error) {\n    return error.message;\n  }\n\n  return JSON.stringify(error);\n}\n","import { APICallError } from '@ai-sdk/provider';\nimport { extractResponseHeaders } from './extract-response-headers';\nimport { FetchFunction } from './fetch-function';\nimport { handleFetchError } from './handle-fetch-error';\nimport { isAbortError } from './is-abort-error';\nimport { ResponseHandler } from './response-handler';\nimport { getRuntimeEnvironmentUserAgent } from './get-runtime-environment-user-agent';\nimport { withUserAgentSuffix } from './with-user-agent-suffix';\nimport { VERSION } from './version';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => globalThis.fetch;\n\nexport const getFromApi = async <T>({\n  url,\n  headers = {},\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch(),\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  failedResponseHandler: ResponseHandler<Error>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: 'GET',\n      headers: withUserAgentSuffix(\n        headers,\n        `ai-sdk/provider-utils/${VERSION}`,\n        getRuntimeEnvironmentUserAgent(),\n      ),\n      signal: abortSignal,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.ok) {\n      let errorInformation: {\n        value: Error;\n        responseHeaders?: Record<string, string> | undefined;\n      };\n\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: {},\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n\n        throw new APICallError({\n          message: 'Failed to process error response',\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: {},\n        });\n      }\n\n      throw errorInformation.value;\n    }\n\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: {},\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n\n      throw new APICallError({\n        message: 'Failed to process successful response',\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: {},\n      });\n    }\n  } catch (error) {\n    throw handleFetchError({ error, url, requestBodyValues: {} });\n  }\n};\n","import { APICallError } from '@ai-sdk/provider';\nimport { isAbortError } from './is-abort-error';\n\nconst FETCH_FAILED_ERROR_MESSAGES = ['fetch failed', 'failed to fetch'];\n\nexport function handleFetchError({\n  error,\n  url,\n  requestBodyValues,\n}: {\n  error: unknown;\n  url: string;\n  requestBodyValues: unknown;\n}) {\n  if (isAbortError(error)) {\n    return error;\n  }\n\n  // unwrap original error when fetch failed (for easier debugging):\n  if (\n    error instanceof TypeError &&\n    FETCH_FAILED_ERROR_MESSAGES.includes(error.message.toLowerCase())\n  ) {\n    const cause = (error as any).cause;\n\n    if (cause != null) {\n      // Failed to connect to server:\n      return new APICallError({\n        message: `Cannot connect to API: ${cause.message}`,\n        cause,\n        url,\n        requestBodyValues,\n        isRetryable: true, // retry when network error\n      });\n    }\n  }\n\n  return error;\n}\n","export function isAbortError(error: unknown): error is Error {\n  return (\n    (error instanceof Error || error instanceof DOMException) &&\n    (error.name === 'AbortError' ||\n      error.name === 'ResponseAborted' || // Next.js\n      error.name === 'TimeoutError')\n  );\n}\n","export function getRuntimeEnvironmentUserAgent(\n  globalThisAny: any = globalThis as any,\n): string {\n  // Browsers\n  if (globalThisAny.window) {\n    return `runtime/browser`;\n  }\n\n  // Cloudflare Workers / Deno / Bun / Node.js >= 21.1\n  if (globalThisAny.navigator?.userAgent) {\n    return `runtime/${globalThisAny.navigator.userAgent.toLowerCase()}`;\n  }\n\n  // Nodes.js < 21.1\n  if (globalThisAny.process?.versions?.node) {\n    return `runtime/node.js/${globalThisAny.process.version.substring(0)}`;\n  }\n\n  if (globalThisAny.EdgeRuntime) {\n    return `runtime/vercel-edge`;\n  }\n\n  return 'runtime/unknown';\n}\n","/**\n * Normalizes different header inputs into a plain record with lower-case keys.\n * Entries with `undefined` or `null` values are removed.\n *\n * @param headers - Input headers (`Headers`, tuples array, plain record) to normalize.\n * @returns A record containing the normalized header entries.\n */\nexport function normalizeHeaders(\n  headers:\n    | HeadersInit\n    | Record<string, string | undefined>\n    | Array<[string, string | undefined]>\n    | undefined,\n): Record<string, string> {\n  if (headers == null) {\n    return {};\n  }\n\n  const normalized: Record<string, string> = {};\n\n  if (headers instanceof Headers) {\n    headers.forEach((value, key) => {\n      normalized[key.toLowerCase()] = value;\n    });\n  } else {\n    if (!Array.isArray(headers)) {\n      headers = Object.entries(headers);\n    }\n\n    for (const [key, value] of headers) {\n      if (value != null) {\n        normalized[key.toLowerCase()] = value;\n      }\n    }\n  }\n\n  return normalized;\n}\n","import { normalizeHeaders } from './normalize-headers';\n\n/**\n * Appends suffix parts to the `user-agent` header.\n * If a `user-agent` header already exists, the suffix parts are appended to it.\n * If no `user-agent` header exists, a new one is created with the suffix parts.\n * Automatically removes undefined entries from the headers.\n *\n * @param headers - The original headers.\n * @param userAgentSuffixParts - The parts to append to the `user-agent` header.\n * @returns The new headers with the `user-agent` header set or updated.\n */\nexport function withUserAgentSuffix(\n  headers: HeadersInit | Record<string, string | undefined> | undefined,\n  ...userAgentSuffixParts: string[]\n): Record<string, string> {\n  const normalizedHeaders = new Headers(normalizeHeaders(headers));\n\n  const currentUserAgentHeader = normalizedHeaders.get('user-agent') || '';\n\n  normalizedHeaders.set(\n    'user-agent',\n    [currentUserAgentHeader, ...userAgentSuffixParts].filter(Boolean).join(' '),\n  );\n\n  return Object.fromEntries(normalizedHeaders.entries());\n}\n","// Version string of this package injected at build time.\ndeclare const __PACKAGE_VERSION__: string | undefined;\nexport const VERSION: string =\n  typeof __PACKAGE_VERSION__ !== 'undefined'\n    ? __PACKAGE_VERSION__\n    : '0.0.0-test';\n","import {\n  JSONSchema7,\n  LanguageModelV3Message,\n  LanguageModelV3Prompt,\n} from '@ai-sdk/provider';\n\nconst DEFAULT_SCHEMA_PREFIX = 'JSON schema:';\nconst DEFAULT_SCHEMA_SUFFIX =\n  'You MUST answer with a JSON object that matches the JSON schema above.';\nconst DEFAULT_GENERIC_SUFFIX = 'You MUST answer with JSON.';\n\nexport function injectJsonInstruction({\n  prompt,\n  schema,\n  schemaPrefix = schema != null ? DEFAULT_SCHEMA_PREFIX : undefined,\n  schemaSuffix = schema != null\n    ? DEFAULT_SCHEMA_SUFFIX\n    : DEFAULT_GENERIC_SUFFIX,\n}: {\n  prompt?: string;\n  schema?: JSONSchema7;\n  schemaPrefix?: string;\n  schemaSuffix?: string;\n}): string {\n  return [\n    prompt != null && prompt.length > 0 ? prompt : undefined,\n    prompt != null && prompt.length > 0 ? '' : undefined, // add a newline if prompt is not null\n    schemaPrefix,\n    schema != null ? JSON.stringify(schema) : undefined,\n    schemaSuffix,\n  ]\n    .filter(line => line != null)\n    .join('\\n');\n}\n\nexport function injectJsonInstructionIntoMessages({\n  messages,\n  schema,\n  schemaPrefix,\n  schemaSuffix,\n}: {\n  messages: LanguageModelV3Prompt;\n  schema?: JSONSchema7;\n  schemaPrefix?: string;\n  schemaSuffix?: string;\n}): LanguageModelV3Prompt {\n  const systemMessage: LanguageModelV3Message =\n    messages[0]?.role === 'system'\n      ? { ...messages[0] }\n      : { role: 'system', content: '' };\n\n  systemMessage.content = injectJsonInstruction({\n    prompt: systemMessage.content,\n    schema,\n    schemaPrefix,\n    schemaSuffix,\n  });\n\n  return [\n    systemMessage,\n    ...(messages[0]?.role === 'system' ? messages.slice(1) : messages),\n  ];\n}\n","/**\n * Type guard that checks whether a value is not `null` or `undefined`.\n *\n * @template T - The type of the value to check.\n * @param value - The value to check.\n * @returns `true` if the value is neither `null` nor `undefined`, otherwise `false`.\n */\nexport function isNonNullable<T>(\n  value: T | undefined | null,\n): value is NonNullable<T> {\n  return value != null;\n}\n","/**\n * Checks if the given URL is supported natively by the model.\n *\n * @param mediaType - The media type of the URL. Case-sensitive.\n * @param url - The URL to check.\n * @param supportedUrls - A record where keys are case-sensitive media types (or '*')\n *                        and values are arrays of RegExp patterns for URLs.\n *\n * @returns `true` if the URL matches a pattern under the specific media type\n *          or the wildcard '*', `false` otherwise.\n */\nexport function isUrlSupported({\n  mediaType,\n  url,\n  supportedUrls,\n}: {\n  mediaType: string;\n  url: string;\n  supportedUrls: Record<string, RegExp[]>;\n}): boolean {\n  // standardize media type and url to lower case\n  url = url.toLowerCase();\n  mediaType = mediaType.toLowerCase();\n\n  return (\n    Object.entries(supportedUrls)\n      // standardize supported url map into lowercase prefixes:\n      .map(([key, value]) => {\n        const mediaType = key.toLowerCase();\n        return mediaType === '*' || mediaType === '*/*'\n          ? { mediaTypePrefix: '', regexes: value }\n          : { mediaTypePrefix: mediaType.replace(/\\*/, ''), regexes: value };\n      })\n      // gather all regexp pattern from matched media type prefixes:\n      .filter(({ mediaTypePrefix }) => mediaType.startsWith(mediaTypePrefix))\n      .flatMap(({ regexes }) => regexes)\n      // check if any pattern matches the url:\n      .some(pattern => pattern.test(url))\n  );\n}\n","import { LoadAPIKeyError } from '@ai-sdk/provider';\n\nexport function loadApiKey({\n  apiKey,\n  environmentVariableName,\n  apiKeyParameterName = 'apiKey',\n  description,\n}: {\n  apiKey: string | undefined;\n  environmentVariableName: string;\n  apiKeyParameterName?: string;\n  description: string;\n}): string {\n  if (typeof apiKey === 'string') {\n    return apiKey;\n  }\n\n  if (apiKey != null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string.`,\n    });\n  }\n\n  if (typeof process === 'undefined') {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`,\n    });\n  }\n\n  apiKey = process.env[environmentVariableName];\n\n  if (apiKey == null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`,\n    });\n  }\n\n  if (typeof apiKey !== 'string') {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`,\n    });\n  }\n\n  return apiKey;\n}\n","/**\n * Loads an optional `string` setting from the environment or a parameter.\n *\n * @param settingValue - The setting value.\n * @param environmentVariableName - The environment variable name.\n * @returns The setting value.\n */\nexport function loadOptionalSetting({\n  settingValue,\n  environmentVariableName,\n}: {\n  settingValue: string | undefined;\n  environmentVariableName: string;\n}): string | undefined {\n  if (typeof settingValue === 'string') {\n    return settingValue;\n  }\n\n  if (settingValue != null || typeof process === 'undefined') {\n    return undefined;\n  }\n\n  settingValue = process.env[environmentVariableName];\n\n  if (settingValue == null || typeof settingValue !== 'string') {\n    return undefined;\n  }\n\n  return settingValue;\n}\n","import { LoadSettingError } from '@ai-sdk/provider';\n\n/**\n * Loads a `string` setting from the environment or a parameter.\n *\n * @param settingValue - The setting value.\n * @param environmentVariableName - The environment variable name.\n * @param settingName - The setting name.\n * @param description - The description of the setting.\n * @returns The setting value.\n */\nexport function loadSetting({\n  settingValue,\n  environmentVariableName,\n  settingName,\n  description,\n}: {\n  settingValue: string | undefined;\n  environmentVariableName: string;\n  settingName: string;\n  description: string;\n}): string {\n  if (typeof settingValue === 'string') {\n    return settingValue;\n  }\n\n  if (settingValue != null) {\n    throw new LoadSettingError({\n      message: `${description} setting must be a string.`,\n    });\n  }\n\n  if (typeof process === 'undefined') {\n    throw new LoadSettingError({\n      message:\n        `${description} setting is missing. ` +\n        `Pass it using the '${settingName}' parameter. ` +\n        `Environment variables is not supported in this environment.`,\n    });\n  }\n\n  settingValue = process.env[environmentVariableName];\n\n  if (settingValue == null) {\n    throw new LoadSettingError({\n      message:\n        `${description} setting is missing. ` +\n        `Pass it using the '${settingName}' parameter ` +\n        `or the ${environmentVariableName} environment variable.`,\n    });\n  }\n\n  if (typeof settingValue !== 'string') {\n    throw new LoadSettingError({\n      message:\n        `${description} setting must be a string. ` +\n        `The value of the ${environmentVariableName} environment variable is not a string.`,\n    });\n  }\n\n  return settingValue;\n}\n","/**\n * Maps a media type to its corresponding file extension.\n * It was originally introduced to set a filename for audio file uploads\n * in https://github.com/vercel/ai/pull/8159.\n *\n * @param mediaType The media type to map.\n * @returns The corresponding file extension\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/MIME_types/Common_types\n */\nexport function mediaTypeToExtension(mediaType: string) {\n  const [_type, subtype = ''] = mediaType.toLowerCase().split('/');\n\n  return (\n    {\n      mpeg: 'mp3',\n      'x-wav': 'wav',\n      opus: 'ogg',\n      mp4: 'm4a',\n      'x-m4a': 'm4a',\n    }[subtype] ?? subtype\n  );\n}\n","import {\n  JSONParseError,\n  JSONValue,\n  TypeValidationError,\n} from '@ai-sdk/provider';\nimport { secureJsonParse } from './secure-json-parse';\nimport { safeValidateTypes, validateTypes } from './validate-types';\nimport { FlexibleSchema } from './schema';\n\n/**\n * Parses a JSON string into an unknown object.\n *\n * @param text - The JSON string to parse.\n * @returns {JSONValue} - The parsed JSON object.\n */\nexport async function parseJSON(options: {\n  text: string;\n  schema?: undefined;\n}): Promise<JSONValue>;\n/**\n * Parses a JSON string into a strongly-typed object using the provided schema.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Validator<T>} schema - The schema to use for parsing the JSON.\n * @returns {Promise<T>} - The parsed object.\n */\nexport async function parseJSON<T>(options: {\n  text: string;\n  schema: FlexibleSchema<T>;\n}): Promise<T>;\nexport async function parseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: FlexibleSchema<T>;\n}): Promise<T> {\n  try {\n    const value = secureJsonParse(text);\n\n    if (schema == null) {\n      return value;\n    }\n\n    return validateTypes<T>({ value, schema });\n  } catch (error) {\n    if (\n      JSONParseError.isInstance(error) ||\n      TypeValidationError.isInstance(error)\n    ) {\n      throw error;\n    }\n\n    throw new JSONParseError({ text, cause: error });\n  }\n}\n\nexport type ParseResult<T> =\n  | { success: true; value: T; rawValue: unknown }\n  | {\n      success: false;\n      error: JSONParseError | TypeValidationError;\n      rawValue: unknown;\n    };\n\n/**\n * Safely parses a JSON string and returns the result as an object of type `unknown`.\n *\n * @param text - The JSON string to parse.\n * @returns {Promise<object>} Either an object with `success: true` and the parsed data, or an object with `success: false` and the error that occurred.\n */\nexport async function safeParseJSON(options: {\n  text: string;\n  schema?: undefined;\n}): Promise<ParseResult<JSONValue>>;\n/**\n * Safely parses a JSON string into a strongly-typed object, using a provided schema to validate the object.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Validator<T>} schema - The schema to use for parsing the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport async function safeParseJSON<T>(options: {\n  text: string;\n  schema: FlexibleSchema<T>;\n}): Promise<ParseResult<T>>;\nexport async function safeParseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: FlexibleSchema<T>;\n}): Promise<ParseResult<T>> {\n  try {\n    const value = secureJsonParse(text);\n\n    if (schema == null) {\n      return { success: true, value: value as T, rawValue: value };\n    }\n\n    return await safeValidateTypes<T>({ value, schema });\n  } catch (error) {\n    return {\n      success: false,\n      error: JSONParseError.isInstance(error)\n        ? error\n        : new JSONParseError({ text, cause: error }),\n      rawValue: undefined,\n    };\n  }\n}\n\nexport function isParsableJson(input: string): boolean {\n  try {\n    secureJsonParse(input);\n    return true;\n  } catch {\n    return false;\n  }\n}\n","// Licensed under BSD-3-Clause (this file only)\n// Code adapted from https://github.com/fastify/secure-json-parse/blob/783fcb1b5434709466759847cec974381939673a/index.js\n//\n// Copyright (c) Vercel, Inc. (https://vercel.com)\n// Copyright (c) 2019 The Fastify Team\n// Copyright (c) 2019, Sideway Inc, and project contributors\n// All rights reserved.\n//\n// The complete list of contributors can be found at:\n// - https://github.com/hapijs/bourne/graphs/contributors\n// - https://github.com/fastify/secure-json-parse/graphs/contributors\n// - https://github.com/vercel/ai/commits/main/packages/provider-utils/src/secure-parse-json.ts\n//\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n//\n// 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nconst suspectProtoRx = /\"__proto__\"\\s*:/;\nconst suspectConstructorRx = /\"constructor\"\\s*:/;\n\nfunction _parse(text: string) {\n  // Parse normally\n  const obj = JSON.parse(text);\n\n  // Ignore null and non-objects\n  if (obj === null || typeof obj !== 'object') {\n    return obj;\n  }\n\n  if (\n    suspectProtoRx.test(text) === false &&\n    suspectConstructorRx.test(text) === false\n  ) {\n    return obj;\n  }\n\n  // Scan result for proto keys\n  return filter(obj);\n}\n\nfunction filter(obj: any) {\n  let next = [obj];\n\n  while (next.length) {\n    const nodes = next;\n    next = [];\n\n    for (const node of nodes) {\n      if (Object.prototype.hasOwnProperty.call(node, '__proto__')) {\n        throw new SyntaxError('Object contains forbidden prototype property');\n      }\n\n      if (\n        Object.prototype.hasOwnProperty.call(node, 'constructor') &&\n        Object.prototype.hasOwnProperty.call(node.constructor, 'prototype')\n      ) {\n        throw new SyntaxError('Object contains forbidden prototype property');\n      }\n\n      for (const key in node) {\n        const value = node[key];\n        if (value && typeof value === 'object') {\n          next.push(value);\n        }\n      }\n    }\n  }\n  return obj;\n}\n\nexport function secureJsonParse(text: string) {\n  const { stackTraceLimit } = Error;\n  try {\n    // Performance optimization, see https://github.com/fastify/secure-json-parse/pull/90\n    Error.stackTraceLimit = 0;\n  } catch (e) {\n    // Fallback in case Error is immutable (v8 readonly)\n    return _parse(text);\n  }\n\n  try {\n    return _parse(text);\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit;\n  }\n}\n","import { TypeValidationError } from '@ai-sdk/provider';\nimport { FlexibleSchema, asSchema } from './schema';\n\n/**\n * Validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The object to validate.\n * @param {Validator<T>} options.schema - The schema to use for validating the JSON.\n * @returns {Promise<T>} - The typed object.\n */\nexport async function validateTypes<OBJECT>({\n  value,\n  schema,\n}: {\n  value: unknown;\n  schema: FlexibleSchema<OBJECT>;\n}): Promise<OBJECT> {\n  const result = await safeValidateTypes({ value, schema });\n\n  if (!result.success) {\n    throw TypeValidationError.wrap({ value, cause: result.error });\n  }\n\n  return result.value;\n}\n\n/**\n * Safely validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The JSON object to validate.\n * @param {Validator<T>} options.schema - The schema to use for validating the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport async function safeValidateTypes<OBJECT>({\n  value,\n  schema,\n}: {\n  value: unknown;\n  schema: FlexibleSchema<OBJECT>;\n}): Promise<\n  | {\n      success: true;\n      value: OBJECT;\n      rawValue: unknown;\n    }\n  | {\n      success: false;\n      error: TypeValidationError;\n      rawValue: unknown;\n    }\n> {\n  const actualSchema = asSchema(schema);\n\n  try {\n    if (actualSchema.validate == null) {\n      return { success: true, value: value as OBJECT, rawValue: value };\n    }\n\n    const result = await actualSchema.validate(value);\n\n    if (result.success) {\n      return { success: true, value: result.value, rawValue: value };\n    }\n\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: result.error }),\n      rawValue: value,\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: error }),\n      rawValue: value,\n    };\n  }\n}\n","import { JSONSchema7, TypeValidationError } from '@ai-sdk/provider';\nimport { StandardSchemaV1, StandardJSONSchemaV1 } from '@standard-schema/spec';\nimport * as z3 from 'zod/v3';\nimport * as z4 from 'zod/v4';\nimport { addAdditionalPropertiesToJsonSchema } from './add-additional-properties-to-json-schema';\nimport { zod3ToJsonSchema } from './to-json-schema/zod3-to-json-schema';\n\n/**\n * Used to mark schemas so we can support both Zod and custom schemas.\n */\nconst schemaSymbol = Symbol.for('vercel.ai.schema');\n\nexport type ValidationResult<OBJECT> =\n  | { success: true; value: OBJECT }\n  | { success: false; error: Error };\n\nexport type Schema<OBJECT = unknown> = {\n  /**\n   * Used to mark schemas so we can support both Zod and custom schemas.\n   */\n  [schemaSymbol]: true;\n\n  /**\n   * Schema type for inference.\n   */\n  _type: OBJECT;\n\n  /**\n   * Optional. Validates that the structure of a value matches this schema,\n   * and returns a typed version of the value if it does.\n   */\n  readonly validate?: (\n    value: unknown,\n  ) => ValidationResult<OBJECT> | PromiseLike<ValidationResult<OBJECT>>;\n\n  /**\n   * The JSON Schema for the schema. It is passed to the providers.\n   */\n  readonly jsonSchema: JSONSchema7 | PromiseLike<JSONSchema7>;\n};\n\n/**\n * Creates a schema with deferred creation.\n * This is important to reduce the startup time of the library\n * and to avoid initializing unused validators.\n *\n * @param createValidator A function that creates a schema.\n * @returns A function that returns a schema.\n */\nexport function lazySchema<SCHEMA>(\n  createSchema: () => Schema<SCHEMA>,\n): LazySchema<SCHEMA> {\n  // cache the validator to avoid initializing it multiple times\n  let schema: Schema<SCHEMA> | undefined;\n  return () => {\n    if (schema == null) {\n      schema = createSchema();\n    }\n    return schema;\n  };\n}\n\nexport type LazySchema<SCHEMA> = () => Schema<SCHEMA>;\n\nexport type ZodSchema<SCHEMA = any> =\n  | z3.Schema<SCHEMA, z3.ZodTypeDef, any>\n  | z4.core.$ZodType<SCHEMA, any>;\n\nexport type StandardSchema<SCHEMA = any> = StandardSchemaV1<unknown, SCHEMA> &\n  StandardJSONSchemaV1<unknown, SCHEMA>;\n\nexport type FlexibleSchema<SCHEMA = any> =\n  | Schema<SCHEMA>\n  | LazySchema<SCHEMA>\n  | ZodSchema<SCHEMA>\n  | StandardSchema<SCHEMA>;\n\nexport type InferSchema<SCHEMA> =\n  SCHEMA extends ZodSchema<infer T>\n    ? T\n    : SCHEMA extends StandardSchema<infer T>\n      ? T\n      : SCHEMA extends LazySchema<infer T>\n        ? T\n        : SCHEMA extends Schema<infer T>\n          ? T\n          : never;\n\n/**\n * Create a schema using a JSON Schema.\n *\n * @param jsonSchema The JSON Schema for the schema.\n * @param options.validate Optional. A validation function for the schema.\n */\nexport function jsonSchema<OBJECT = unknown>(\n  jsonSchema:\n    | JSONSchema7\n    | PromiseLike<JSONSchema7>\n    | (() => JSONSchema7 | PromiseLike<JSONSchema7>),\n  {\n    validate,\n  }: {\n    validate?: (\n      value: unknown,\n    ) => ValidationResult<OBJECT> | PromiseLike<ValidationResult<OBJECT>>;\n  } = {},\n): Schema<OBJECT> {\n  return {\n    [schemaSymbol]: true,\n    _type: undefined as OBJECT, // should never be used directly\n    get jsonSchema() {\n      if (typeof jsonSchema === 'function') {\n        jsonSchema = jsonSchema(); // cache the function results\n      }\n      return jsonSchema;\n    },\n    validate,\n  };\n}\n\nfunction isSchema(value: unknown): value is Schema {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    schemaSymbol in value &&\n    value[schemaSymbol] === true &&\n    'jsonSchema' in value &&\n    'validate' in value\n  );\n}\n\nexport function asSchema<OBJECT>(\n  schema: FlexibleSchema<OBJECT> | undefined,\n): Schema<OBJECT> {\n  return schema == null\n    ? jsonSchema({ properties: {}, additionalProperties: false })\n    : isSchema(schema)\n      ? schema\n      : '~standard' in schema\n        ? schema['~standard'].vendor === 'zod'\n          ? zodSchema(schema as ZodSchema<OBJECT>)\n          : standardSchema(schema as StandardSchema<OBJECT>)\n        : schema();\n}\n\nfunction standardSchema<OBJECT>(\n  standardSchema: StandardSchema<OBJECT>,\n): Schema<OBJECT> {\n  return jsonSchema(\n    () =>\n      standardSchema['~standard'].jsonSchema.input({\n        target: 'draft-07',\n      }),\n    {\n      validate: async value => {\n        const result = await standardSchema['~standard'].validate(value);\n        return 'value' in result\n          ? { success: true, value: result.value }\n          : {\n              success: false,\n              error: new TypeValidationError({\n                value,\n                cause: result.issues,\n              }),\n            };\n      },\n    },\n  );\n}\n\nexport function zod3Schema<OBJECT>(\n  zodSchema: z3.Schema<OBJECT, z3.ZodTypeDef, any>,\n  options?: {\n    /**\n     * Enables support for references in the schema.\n     * This is required for recursive schemas, e.g. with `z.lazy`.\n     * However, not all language models and providers support such references.\n     * Defaults to `false`.\n     */\n    useReferences?: boolean;\n  },\n): Schema<OBJECT> {\n  // default to no references (to support openapi conversion for google)\n  const useReferences = options?.useReferences ?? false;\n\n  return jsonSchema(\n    // defer json schema creation to avoid unnecessary computation when only validation is needed\n    () =>\n      zod3ToJsonSchema(zodSchema, {\n        $refStrategy: useReferences ? 'root' : 'none',\n      }) as JSONSchema7,\n    {\n      validate: async value => {\n        const result = await zodSchema.safeParseAsync(value);\n        return result.success\n          ? { success: true, value: result.data }\n          : { success: false, error: result.error };\n      },\n    },\n  );\n}\n\nexport function zod4Schema<OBJECT>(\n  zodSchema: z4.core.$ZodType<OBJECT, any>,\n  options?: {\n    /**\n     * Enables support for references in the schema.\n     * This is required for recursive schemas, e.g. with `z.lazy`.\n     * However, not all language models and providers support such references.\n     * Defaults to `false`.\n     */\n    useReferences?: boolean;\n  },\n): Schema<OBJECT> {\n  // default to no references (to support openapi conversion for google)\n  const useReferences = options?.useReferences ?? false;\n\n  return jsonSchema(\n    // defer json schema creation to avoid unnecessary computation when only validation is needed\n    () =>\n      addAdditionalPropertiesToJsonSchema(\n        z4.toJSONSchema(zodSchema, {\n          target: 'draft-7',\n          io: 'input',\n          reused: useReferences ? 'ref' : 'inline',\n        }) as JSONSchema7,\n      ),\n    {\n      validate: async value => {\n        const result = await z4.safeParseAsync(zodSchema, value);\n        return result.success\n          ? { success: true, value: result.data }\n          : { success: false, error: result.error };\n      },\n    },\n  );\n}\n\nexport function isZod4Schema(\n  zodSchema: z4.core.$ZodType<any, any> | z3.Schema<any, z3.ZodTypeDef, any>,\n): zodSchema is z4.core.$ZodType<any, any> {\n  // https://zod.dev/library-authors?id=how-to-support-zod-3-and-zod-4-simultaneously\n  return '_zod' in zodSchema;\n}\n\nexport function zodSchema<OBJECT>(\n  zodSchema:\n    | z4.core.$ZodType<OBJECT, any>\n    | z3.Schema<OBJECT, z3.ZodTypeDef, any>,\n  options?: {\n    /**\n     * Enables support for references in the schema.\n     * This is required for recursive schemas, e.g. with `z.lazy`.\n     * However, not all language models and providers support such references.\n     * Defaults to `false`.\n     */\n    useReferences?: boolean;\n  },\n): Schema<OBJECT> {\n  if (isZod4Schema(zodSchema)) {\n    return zod4Schema(zodSchema, options);\n  } else {\n    return zod3Schema(zodSchema, options);\n  }\n}\n","import { JSONSchema7 } from '@ai-sdk/provider';\n\n/**\n * Recursively adds additionalProperties: false to the JSON schema. This is necessary because some providers (e.g. OpenAI) do not support additionalProperties: true.\n */\nexport function addAdditionalPropertiesToJsonSchema(\n  jsonSchema: JSONSchema7,\n): JSONSchema7 {\n  if (jsonSchema.type === 'object') {\n    jsonSchema.additionalProperties = false;\n    const properties = jsonSchema.properties;\n    if (properties != null) {\n      for (const property in properties) {\n        properties[property] = addAdditionalPropertiesToJsonSchema(\n          properties[property] as JSONSchema7,\n        );\n      }\n    }\n  }\n  if (jsonSchema.type === 'array' && jsonSchema.items != null) {\n    if (Array.isArray(jsonSchema.items)) {\n      jsonSchema.items = jsonSchema.items.map(item =>\n        addAdditionalPropertiesToJsonSchema(item as JSONSchema7),\n      );\n    } else {\n      jsonSchema.items = addAdditionalPropertiesToJsonSchema(\n        jsonSchema.items as JSONSchema7,\n      );\n    }\n  }\n  return jsonSchema;\n}\n","import { ZodSchema, ZodTypeDef } from 'zod/v3';\nimport { Refs, Seen } from './refs';\nimport { JsonSchema7Type } from './parse-types';\n\nexport type DateStrategy =\n  | 'format:date-time'\n  | 'format:date'\n  | 'string'\n  | 'integer';\n\nexport const ignoreOverride = Symbol(\n  'Let zodToJsonSchema decide on which parser to use',\n);\n\nexport type OverrideCallback = (\n  def: ZodTypeDef,\n  refs: Refs,\n  seen: Seen | undefined,\n  forceResolution?: boolean,\n) => JsonSchema7Type | undefined | typeof ignoreOverride;\n\nexport type PostProcessCallback = (\n  jsonSchema: JsonSchema7Type | undefined,\n  def: ZodTypeDef,\n  refs: Refs,\n) => JsonSchema7Type | undefined;\n\nexport const jsonDescription: PostProcessCallback = (jsonSchema, def) => {\n  if (def.description) {\n    try {\n      return {\n        ...jsonSchema,\n        ...JSON.parse(def.description),\n      };\n    } catch {}\n  }\n\n  return jsonSchema;\n};\n\nexport type Options = {\n  name: string | undefined;\n  $refStrategy: 'root' | 'relative' | 'none' | 'seen';\n  basePath: string[];\n  effectStrategy: 'input' | 'any';\n  pipeStrategy: 'input' | 'output' | 'all';\n  dateStrategy: DateStrategy | DateStrategy[];\n  mapStrategy: 'entries' | 'record';\n  removeAdditionalStrategy: 'passthrough' | 'strict';\n  allowedAdditionalProperties: true | undefined;\n  rejectedAdditionalProperties: false | undefined;\n  strictUnions: boolean;\n  definitionPath: string;\n  definitions: Record<string, ZodSchema>;\n  errorMessages: boolean;\n  patternStrategy: 'escape' | 'preserve';\n  applyRegexFlags: boolean;\n  emailStrategy: 'format:email' | 'format:idn-email' | 'pattern:zod';\n  base64Strategy: 'format:binary' | 'contentEncoding:base64' | 'pattern:zod';\n  nameStrategy: 'ref' | 'title';\n  override?: OverrideCallback;\n  postProcess?: PostProcessCallback;\n};\n\nexport const defaultOptions: Options = {\n  name: undefined,\n  $refStrategy: 'root',\n  basePath: ['#'],\n  effectStrategy: 'input',\n  pipeStrategy: 'all',\n  dateStrategy: 'format:date-time',\n  mapStrategy: 'entries',\n  removeAdditionalStrategy: 'passthrough',\n  allowedAdditionalProperties: true,\n  rejectedAdditionalProperties: false,\n  definitionPath: 'definitions',\n  strictUnions: false,\n  definitions: {},\n  errorMessages: false,\n  patternStrategy: 'escape',\n  applyRegexFlags: false,\n  emailStrategy: 'format:email',\n  base64Strategy: 'contentEncoding:base64',\n  nameStrategy: 'ref',\n};\n\nexport const getDefaultOptions = (\n  options: Partial<Options> | string | undefined,\n) =>\n  (typeof options === 'string'\n    ? {\n        ...defaultOptions,\n        name: options,\n      }\n    : {\n        ...defaultOptions,\n        ...options,\n      }) as Options;\n","import { ZodFirstPartyTypeKind } from 'zod/v3';\nimport { parseAnyDef } from './parsers/any';\nimport { parseArrayDef } from './parsers/array';\nimport { parseBigintDef } from './parsers/bigint';\nimport { parseBooleanDef } from './parsers/boolean';\nimport { parseBrandedDef } from './parsers/branded';\nimport { parseCatchDef } from './parsers/catch';\nimport { parseDateDef } from './parsers/date';\nimport { parseDefaultDef } from './parsers/default';\nimport { parseEffectsDef } from './parsers/effects';\nimport { parseEnumDef } from './parsers/enum';\nimport { parseIntersectionDef } from './parsers/intersection';\nimport { parseLiteralDef } from './parsers/literal';\nimport { parseMapDef } from './parsers/map';\nimport { parseNativeEnumDef } from './parsers/native-enum';\nimport { parseNeverDef } from './parsers/never';\nimport { parseNullDef } from './parsers/null';\nimport { parseNullableDef } from './parsers/nullable';\nimport { parseNumberDef } from './parsers/number';\nimport { parseObjectDef } from './parsers/object';\nimport { parseOptionalDef } from './parsers/optional';\nimport { parsePipelineDef } from './parsers/pipeline';\nimport { parsePromiseDef } from './parsers/promise';\nimport { parseRecordDef } from './parsers/record';\nimport { parseSetDef } from './parsers/set';\nimport { parseStringDef } from './parsers/string';\nimport { parseTupleDef } from './parsers/tuple';\nimport { parseUndefinedDef } from './parsers/undefined';\nimport { parseUnionDef } from './parsers/union';\nimport { parseUnknownDef } from './parsers/unknown';\nimport { Refs } from './refs';\nimport { parseReadonlyDef } from './parsers/readonly';\nimport { JsonSchema7Type } from './parse-types';\n\nexport type InnerDefGetter = () => any;\n\nexport const selectParser = (\n  def: any,\n  typeName: ZodFirstPartyTypeKind,\n  refs: Refs,\n): JsonSchema7Type | undefined | InnerDefGetter => {\n  switch (typeName) {\n    case ZodFirstPartyTypeKind.ZodString:\n      return parseStringDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodNumber:\n      return parseNumberDef(def);\n    case ZodFirstPartyTypeKind.ZodObject:\n      return parseObjectDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodBigInt:\n      return parseBigintDef(def);\n    case ZodFirstPartyTypeKind.ZodBoolean:\n      return parseBooleanDef();\n    case ZodFirstPartyTypeKind.ZodDate:\n      return parseDateDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodUndefined:\n      return parseUndefinedDef();\n    case ZodFirstPartyTypeKind.ZodNull:\n      return parseNullDef();\n    case ZodFirstPartyTypeKind.ZodArray:\n      return parseArrayDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodUnion:\n    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:\n      return parseUnionDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodIntersection:\n      return parseIntersectionDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodTuple:\n      return parseTupleDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodRecord:\n      return parseRecordDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodLiteral:\n      return parseLiteralDef(def);\n    case ZodFirstPartyTypeKind.ZodEnum:\n      return parseEnumDef(def);\n    case ZodFirstPartyTypeKind.ZodNativeEnum:\n      return parseNativeEnumDef(def);\n    case ZodFirstPartyTypeKind.ZodNullable:\n      return parseNullableDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodOptional:\n      return parseOptionalDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodMap:\n      return parseMapDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodSet:\n      return parseSetDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodLazy:\n      return () => (def as any).getter()._def;\n    case ZodFirstPartyTypeKind.ZodPromise:\n      return parsePromiseDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodNaN:\n    case ZodFirstPartyTypeKind.ZodNever:\n      return parseNeverDef();\n    case ZodFirstPartyTypeKind.ZodEffects:\n      return parseEffectsDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodAny:\n      return parseAnyDef();\n    case ZodFirstPartyTypeKind.ZodUnknown:\n      return parseUnknownDef();\n    case ZodFirstPartyTypeKind.ZodDefault:\n      return parseDefaultDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodBranded:\n      return parseBrandedDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodReadonly:\n      return parseReadonlyDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodCatch:\n      return parseCatchDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodPipeline:\n      return parsePipelineDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodFunction:\n    case ZodFirstPartyTypeKind.ZodVoid:\n    case ZodFirstPartyTypeKind.ZodSymbol:\n      return undefined;\n    default:\n      /* c8 ignore next */\n      return ((_: never) => undefined)(typeName);\n  }\n};\n","export type JsonSchema7AnyType = { $ref?: string };\n\nexport function parseAnyDef(): JsonSchema7AnyType {\n  return {};\n}\n","import { ZodArrayDef, ZodFirstPartyTypeKind } from 'zod/v3';\nimport { parseDef } from '../parse-def';\nimport { JsonSchema7Type } from '../parse-types';\nimport { Refs } from '../refs';\n\nexport type JsonSchema7ArrayType = {\n  type: 'array';\n  items?: JsonSchema7Type;\n  minItems?: number;\n  maxItems?: number;\n};\n\nexport function parseArrayDef(def: ZodArrayDef, refs: Refs) {\n  const res: JsonSchema7ArrayType = {\n    type: 'array',\n  };\n  if (\n    def.type?._def &&\n    def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny\n  ) {\n    res.items = parseDef(def.type._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, 'items'],\n    });\n  }\n\n  if (def.minLength) {\n    res.minItems = def.minLength.value;\n  }\n  if (def.maxLength) {\n    res.maxItems = def.maxLength.value;\n  }\n  if (def.exactLength) {\n    res.minItems = def.exactLength.value;\n    res.maxItems = def.exactLength.value;\n  }\n  return res;\n}\n","import { ZodBigIntDef } from 'zod/v3';\n\nexport type JsonSchema7BigintType = {\n  type: 'integer';\n  format: 'int64';\n  minimum?: BigInt;\n  exclusiveMinimum?: BigInt;\n  maximum?: BigInt;\n  exclusiveMaximum?: BigInt;\n  multipleOf?: BigInt;\n};\n\nexport function parseBigintDef(def: ZodBigIntDef): JsonSchema7BigintType {\n  const res: JsonSchema7BigintType = {\n    type: 'integer',\n    format: 'int64',\n  };\n\n  if (!def.checks) return res;\n\n  for (const check of def.checks) {\n    switch (check.kind) {\n      case 'min':\n        if (check.inclusive) {\n          res.minimum = check.value;\n        } else {\n          res.exclusiveMinimum = check.value;\n        }\n        break;\n      case 'max':\n        if (check.inclusive) {\n          res.maximum = check.value;\n        } else {\n          res.exclusiveMaximum = check.value;\n        }\n\n        break;\n      case 'multipleOf':\n        res.multipleOf = check.value;\n        break;\n    }\n  }\n  return res;\n}\n","export type JsonSchema7BooleanType = {\n  type: 'boolean';\n};\n\nexport function parseBooleanDef(): JsonSchema7BooleanType {\n  return { type: 'boolean' };\n}\n","import { ZodBrandedDef } from 'zod/v3';\nimport { parseDef } from '../parse-def';\nimport { Refs } from '../refs';\n\nexport function parseBrandedDef(_def: ZodBrandedDef<any>, refs: Refs) {\n  return parseDef(_def.type._def, refs);\n}\n","import { ZodCatchDef } from 'zod/v3';\nimport { parseDef } from '../parse-def';\nimport { Refs } from '../refs';\n\nexport const parseCatchDef = (def: ZodCatchDef<any>, refs: Refs) => {\n  return parseDef(def.innerType._def, refs);\n};\n","import { ZodDateDef } from 'zod/v3';\nimport { Refs } from '../refs';\nimport { DateStrategy } from '../options';\n\nexport type JsonSchema7DateType =\n  | {\n      type: 'integer' | 'string';\n      format: 'unix-time' | 'date-time' | 'date';\n      minimum?: number;\n      maximum?: number;\n    }\n  | {\n      anyOf: JsonSchema7DateType[];\n    };\n\nexport function parseDateDef(\n  def: ZodDateDef,\n  refs: Refs,\n  overrideDateStrategy?: DateStrategy,\n): JsonSchema7DateType {\n  const strategy = overrideDateStrategy ?? refs.dateStrategy;\n\n  if (Array.isArray(strategy)) {\n    return {\n      anyOf: strategy.map((item, i) => parseDateDef(def, refs, item)),\n    };\n  }\n\n  switch (strategy) {\n    case 'string':\n    case 'format:date-time':\n      return {\n        type: 'string',\n        format: 'date-time',\n      };\n    case 'format:date':\n      return {\n        type: 'string',\n        format: 'date',\n      };\n    case 'integer':\n      return integerDateParser(def);\n  }\n}\n\nconst integerDateParser = (def: ZodDateDef) => {\n  const res: JsonSchema7DateType = {\n    type: 'integer',\n    format: 'unix-time',\n  };\n\n  for (const check of def.checks) {\n    switch (check.kind) {\n      case 'min':\n        res.minimum = check.value;\n        break;\n      case 'max':\n        res.maximum = check.value;\n        break;\n    }\n  }\n\n  return res;\n};\n","import { ZodDefaultDef } from 'zod/v3';\nimport { parseDef } from '../parse-def';\nimport { JsonSchema7Type } from '../parse-types';\nimport { Refs } from '../refs';\n\nexport function parseDefaultDef(\n  _def: ZodDefaultDef,\n  refs: Refs,\n): JsonSchema7Type & { default: any } {\n  return {\n    ...parseDef(_def.innerType._def, refs),\n    default: _def.defaultValue(),\n  };\n}\n","import { ZodEffectsDef } from 'zod/v3';\nimport { parseDef } from '../parse-def';\nimport { JsonSchema7Type } from '../parse-types';\nimport { Refs } from '../refs';\nimport { parseAnyDef } from './any';\n\nexport function parseEffectsDef(\n  _def: ZodEffectsDef,\n  refs: Refs,\n): JsonSchema7Type | undefined {\n  return refs.effectStrategy === 'input'\n    ? parseDef(_def.schema._def, refs)\n    : parseAnyDef();\n}\n","import { ZodEnumDef } from 'zod/v3';\n\nexport type JsonSchema7EnumType = {\n  type: 'string';\n  enum: string[];\n};\n\nexport function parseEnumDef(def: ZodEnumDef): JsonSchema7EnumType {\n  return {\n    type: 'string',\n    enum: Array.from(def.values),\n  };\n}\n","import { ZodIntersectionDef } from 'zod/v3';\nimport { parseDef } from '../parse-def';\nimport { JsonSchema7Type } from '../parse-types';\nimport { Refs } from '../refs';\nimport { JsonSchema7StringType } from './string';\n\nexport type JsonSchema7AllOfType = {\n  allOf: JsonSchema7Type[];\n  unevaluatedProperties?: boolean;\n};\n\nconst isJsonSchema7AllOfType = (\n  type: JsonSchema7Type | JsonSchema7StringType,\n): type is JsonSchema7AllOfType => {\n  if ('type' in type && type.type === 'string') return false;\n  return 'allOf' in type;\n};\n\nexport function parseIntersectionDef(\n  def: ZodIntersectionDef,\n  refs: Refs,\n): JsonSchema7AllOfType | JsonSchema7Type | undefined {\n  const allOf = [\n    parseDef(def.left._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, 'allOf', '0'],\n    }),\n    parseDef(def.right._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, 'allOf', '1'],\n    }),\n  ].filter((x): x is JsonSchema7Type => !!x);\n\n  const mergedAllOf: JsonSchema7Type[] = [];\n  // If either of the schemas is an allOf, merge them into a single allOf\n  allOf.forEach(schema => {\n    if (isJsonSchema7AllOfType(schema)) {\n      mergedAllOf.push(...schema.allOf);\n    } else {\n      let nestedSchema: JsonSchema7Type = schema;\n      if (\n        'additionalProperties' in schema &&\n        schema.additionalProperties === false\n      ) {\n        const { additionalProperties, ...rest } = schema;\n        nestedSchema = rest;\n      }\n      mergedAllOf.push(nestedSchema);\n    }\n  });\n  return mergedAllOf.length ? { allOf: mergedAllOf } : undefined;\n}\n","import { ZodLiteralDef } from 'zod/v3';\n\nexport type JsonSchema7LiteralType =\n  | {\n      type: 'string' | 'number' | 'integer' | 'boolean';\n      const: string | number | boolean;\n    }\n  | {\n      type: 'object' | 'array';\n    };\n\nexport function parseLiteralDef(def: ZodLiteralDef): JsonSchema7LiteralType {\n  const parsedType = typeof def.value;\n  if (\n    parsedType !== 'bigint' &&\n    parsedType !== 'number' &&\n    parsedType !== 'boolean' &&\n    parsedType !== 'string'\n  ) {\n    return {\n      type: Array.isArray(def.value) ? 'array' : 'object',\n    };\n  }\n\n  return {\n    type: parsedType === 'bigint' ? 'integer' : parsedType,\n    const: def.value,\n  };\n}\n","import {\n  ZodFirstPartyTypeKind,\n  ZodMapDef,\n  ZodRecordDef,\n  ZodTypeAny,\n} from 'zod/v3';\nimport { parseDef } from '../parse-def';\nimport { JsonSchema7Type } from '../parse-types';\nimport { Refs } from '../refs';\nimport { parseBrandedDef } from './branded';\nimport { JsonSchema7EnumType } from './enum';\nimport { JsonSchema7StringType, parseStringDef } from './string';\n\ntype JsonSchema7RecordPropertyNamesType =\n  | Omit<JsonSchema7StringType, 'type'>\n  | Omit<JsonSchema7EnumType, 'type'>;\n\nexport type JsonSchema7RecordType = {\n  type: 'object';\n  additionalProperties?: JsonSchema7Type | true;\n  propertyNames?: JsonSchema7RecordPropertyNamesType;\n};\n\nexport function parseRecordDef(\n  def: ZodRecordDef<ZodTypeAny, ZodTypeAny> | ZodMapDef,\n  refs: Refs,\n): JsonSchema7RecordType {\n  const schema: JsonSchema7RecordType = {\n    type: 'object',\n    additionalProperties:\n      parseDef(def.valueType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, 'additionalProperties'],\n      }) ?? refs.allowedAdditionalProperties,\n  };\n\n  if (\n    def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString &&\n    def.keyType._def.checks?.length\n  ) {\n    const { type, ...keyType } = parseStringDef(def.keyType._def, refs);\n\n    return {\n      ...schema,\n      propertyNames: keyType,\n    };\n  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {\n    return {\n      ...schema,\n      propertyNames: {\n        enum: def.keyType._def.values,\n      },\n    };\n  } else if (\n    def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodBranded &&\n    def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString &&\n    def.keyType._def.type._def.checks?.length\n  ) {\n    const { type, ...keyType } = parseBrandedDef(\n      def.keyType._def,\n      refs,\n    ) as JsonSchema7StringType;\n\n    return {\n      ...schema,\n      propertyNames: keyType,\n    };\n  }\n\n  return schema;\n}\n","import { ZodStringDef } from 'zod/v3';\nimport { Refs } from '../refs';\n\nlet emojiRegex: RegExp | undefined = undefined;\n\n/**\n * Generated from the regular expressions found here as of 2024-05-22:\n * https://github.com/colinhacks/zod/blob/master/src/types.ts.\n *\n * Expressions with /i flag have been changed accordingly.\n */\nexport const zodPatterns = {\n  /**\n   * `c` was changed to `[cC]` to replicate /i flag\n   */\n  cuid: /^[cC][^\\s-]{8,}$/,\n  cuid2: /^[0-9a-z]+$/,\n  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,\n  /**\n   * `a-z` was added to replicate /i flag\n   */\n  email:\n    /^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_'+\\-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$/,\n  /**\n   * Constructed a valid Unicode RegExp\n   *\n   * Lazily instantiate since this type of regex isn't supported\n   * in all envs (e.g. React Native).\n   *\n   * See:\n   * https://github.com/colinhacks/zod/issues/2433\n   * Fix in Zod:\n   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b\n   */\n  emoji: () => {\n    if (emojiRegex === undefined) {\n      emojiRegex = RegExp(\n        '^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$',\n        'u',\n      );\n    }\n    return emojiRegex;\n  },\n  /**\n   * Unused\n   */\n  uuid: /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/,\n  /**\n   * Unused\n   */\n  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,\n  ipv4Cidr:\n    /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/,\n  /**\n   * Unused\n   */\n  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,\n  ipv6Cidr:\n    /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,\n  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,\n  base64url:\n    /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,\n  nanoid: /^[a-zA-Z0-9_-]{21}$/,\n  jwt: /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/,\n} as const;\n\nexport type JsonSchema7StringType = {\n  type: 'string';\n  minLength?: number;\n  maxLength?: number;\n  format?:\n    | 'email'\n    | 'idn-email'\n    | 'uri'\n    | 'uuid'\n    | 'date-time'\n    | 'ipv4'\n    | 'ipv6'\n    | 'date'\n    | 'time'\n    | 'duration';\n  pattern?: string;\n  allOf?: {\n    pattern: string;\n  }[];\n  anyOf?: {\n    format: string;\n  }[];\n  contentEncoding?: string;\n};\n\nexport function parseStringDef(\n  def: ZodStringDef,\n  refs: Refs,\n): JsonSchema7StringType {\n  const res: JsonSchema7StringType = {\n    type: 'string',\n  };\n\n  if (def.checks) {\n    for (const check of def.checks) {\n      switch (check.kind) {\n        case 'min':\n          res.minLength =\n            typeof res.minLength === 'number'\n              ? Math.max(res.minLength, check.value)\n              : check.value;\n          break;\n        case 'max':\n          res.maxLength =\n            typeof res.maxLength === 'number'\n              ? Math.min(res.maxLength, check.value)\n              : check.value;\n\n          break;\n        case 'email':\n          switch (refs.emailStrategy) {\n            case 'format:email':\n              addFormat(res, 'email', check.message, refs);\n              break;\n            case 'format:idn-email':\n              addFormat(res, 'idn-email', check.message, refs);\n              break;\n            case 'pattern:zod':\n              addPattern(res, zodPatterns.email, check.message, refs);\n              break;\n          }\n\n          break;\n        case 'url':\n          addFormat(res, 'uri', check.message, refs);\n          break;\n        case 'uuid':\n          addFormat(res, 'uuid', check.message, refs);\n          break;\n        case 'regex':\n          addPattern(res, check.regex, check.message, refs);\n          break;\n        case 'cuid':\n          addPattern(res, zodPatterns.cuid, check.message, refs);\n          break;\n        case 'cuid2':\n          addPattern(res, zodPatterns.cuid2, check.message, refs);\n          break;\n        case 'startsWith':\n          addPattern(\n            res,\n            RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`),\n            check.message,\n            refs,\n          );\n          break;\n        case 'endsWith':\n          addPattern(\n            res,\n            RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`),\n            check.message,\n            refs,\n          );\n          break;\n        case 'datetime':\n          addFormat(res, 'date-time', check.message, refs);\n          break;\n        case 'date':\n          addFormat(res, 'date', check.message, refs);\n          break;\n        case 'time':\n          addFormat(res, 'time', check.message, refs);\n          break;\n        case 'duration':\n          addFormat(res, 'duration', check.message, refs);\n          break;\n        case 'length':\n          res.minLength =\n            typeof res.minLength === 'number'\n              ? Math.max(res.minLength, check.value)\n              : check.value;\n          res.maxLength =\n            typeof res.maxLength === 'number'\n              ? Math.min(res.maxLength, check.value)\n              : check.value;\n          break;\n        case 'includes': {\n          addPattern(\n            res,\n            RegExp(escapeLiteralCheckValue(check.value, refs)),\n            check.message,\n            refs,\n          );\n          break;\n        }\n        case 'ip': {\n          if (check.version !== 'v6') {\n            addFormat(res, 'ipv4', check.message, refs);\n          }\n          if (check.version !== 'v4') {\n            addFormat(res, 'ipv6', check.message, refs);\n          }\n          break;\n        }\n        case 'base64url':\n          addPattern(res, zodPatterns.base64url, check.message, refs);\n          break;\n        case 'jwt':\n          addPattern(res, zodPatterns.jwt, check.message, refs);\n          break;\n        case 'cidr': {\n          if (check.version !== 'v6') {\n            addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);\n          }\n          if (check.version !== 'v4') {\n            addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);\n          }\n          break;\n        }\n        case 'emoji':\n          addPattern(res, zodPatterns.emoji(), check.message, refs);\n          break;\n        case 'ulid': {\n          addPattern(res, zodPatterns.ulid, check.message, refs);\n          break;\n        }\n        case 'base64': {\n          switch (refs.base64Strategy) {\n            case 'format:binary': {\n              addFormat(res, 'binary' as any, check.message, refs);\n              break;\n            }\n\n            case 'contentEncoding:base64': {\n              res.contentEncoding = 'base64';\n              break;\n            }\n\n            case 'pattern:zod': {\n              addPattern(res, zodPatterns.base64, check.message, refs);\n              break;\n            }\n          }\n          break;\n        }\n        case 'nanoid': {\n          addPattern(res, zodPatterns.nanoid, check.message, refs);\n        }\n        case 'toLowerCase':\n        case 'toUpperCase':\n        case 'trim':\n          break;\n        default:\n          /* c8 ignore next */\n          ((_: never) => {})(check);\n      }\n    }\n  }\n\n  return res;\n}\n\nfunction escapeLiteralCheckValue(literal: string, refs: Refs): string {\n  return refs.patternStrategy === 'escape'\n    ? escapeNonAlphaNumeric(literal)\n    : literal;\n}\n\nconst ALPHA_NUMERIC = new Set(\n  'ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789',\n);\n\nfunction escapeNonAlphaNumeric(source: string) {\n  let result = '';\n\n  for (let i = 0; i < source.length; i++) {\n    if (!ALPHA_NUMERIC.has(source[i])) {\n      result += '\\\\';\n    }\n\n    result += source[i];\n  }\n\n  return result;\n}\n\n// Adds a \"format\" keyword to the schema. If a format exists, both formats will be joined in an allOf-node, along with subsequent ones.\nfunction addFormat(\n  schema: JsonSchema7StringType,\n  value: Required<JsonSchema7StringType>['format'],\n  message: string | undefined,\n  refs: Refs,\n) {\n  if (schema.format || schema.anyOf?.some(x => x.format)) {\n    if (!schema.anyOf) {\n      schema.anyOf = [];\n    }\n\n    if (schema.format) {\n      schema.anyOf!.push({\n        format: schema.format,\n      });\n      delete schema.format;\n    }\n\n    schema.anyOf!.push({\n      format: value,\n      ...(message &&\n        refs.errorMessages && { errorMessage: { format: message } }),\n    });\n  } else {\n    schema.format = value;\n  }\n}\n\n// Adds a \"pattern\" keyword to the schema. If a pattern exists, both patterns will be joined in an allOf-node, along with subsequent ones.\nfunction addPattern(\n  schema: JsonSchema7StringType,\n  regex: RegExp,\n  message: string | undefined,\n  refs: Refs,\n) {\n  if (schema.pattern || schema.allOf?.some(x => x.pattern)) {\n    if (!schema.allOf) {\n      schema.allOf = [];\n    }\n\n    if (schema.pattern) {\n      schema.allOf!.push({\n        pattern: schema.pattern,\n      });\n      delete schema.pattern;\n    }\n\n    schema.allOf!.push({\n      pattern: stringifyRegExpWithFlags(regex, refs),\n      ...(message &&\n        refs.errorMessages && { errorMessage: { pattern: message } }),\n    });\n  } else {\n    schema.pattern = stringifyRegExpWithFlags(regex, refs);\n  }\n}\n\n// Mutate z.string.regex() in a best attempt to accommodate for regex flags when applyRegexFlags is true\nfunction stringifyRegExpWithFlags(regex: RegExp, refs: Refs): string {\n  if (!refs.applyRegexFlags || !regex.flags) {\n    return regex.source;\n  }\n\n  // Currently handled flags\n  const flags = {\n    i: regex.flags.includes('i'), // Case-insensitive\n    m: regex.flags.includes('m'), // `^` and `$` matches adjacent to newline characters\n    s: regex.flags.includes('s'), // `.` matches newlines\n  };\n\n  // The general principle here is to step through each character, one at a time, applying mutations as flags require. We keep track when the current character is escaped, and when it's inside a group /like [this]/ or (also) a range like /[a-z]/. The following is fairly brittle imperative code; edit at your peril!\n  const source = flags.i ? regex.source.toLowerCase() : regex.source;\n  let pattern = '';\n  let isEscaped = false;\n  let inCharGroup = false;\n  let inCharRange = false;\n\n  for (let i = 0; i < source.length; i++) {\n    if (isEscaped) {\n      pattern += source[i];\n      isEscaped = false;\n      continue;\n    }\n\n    if (flags.i) {\n      if (inCharGroup) {\n        if (source[i].match(/[a-z]/)) {\n          if (inCharRange) {\n            pattern += source[i];\n            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();\n            inCharRange = false;\n          } else if (source[i + 1] === '-' && source[i + 2]?.match(/[a-z]/)) {\n            pattern += source[i];\n            inCharRange = true;\n          } else {\n            pattern += `${source[i]}${source[i].toUpperCase()}`;\n          }\n          continue;\n        }\n      } else if (source[i].match(/[a-z]/)) {\n        pattern += `[${source[i]}${source[i].toUpperCase()}]`;\n        continue;\n      }\n    }\n\n    if (flags.m) {\n      if (source[i] === '^') {\n        pattern += `(^|(?<=[\\r\\n]))`;\n        continue;\n      } else if (source[i] === '$') {\n        pattern += `($|(?=[\\r\\n]))`;\n        continue;\n      }\n    }\n\n    if (flags.s && source[i] === '.') {\n      pattern += inCharGroup ? `${source[i]}\\r\\n` : `[${source[i]}\\r\\n]`;\n      continue;\n    }\n\n    pattern += source[i];\n    if (source[i] === '\\\\') {\n      isEscaped = true;\n    } else if (inCharGroup && source[i] === ']') {\n      inCharGroup = false;\n    } else if (!inCharGroup && source[i] === '[') {\n      inCharGroup = true;\n    }\n  }\n\n  try {\n    new RegExp(pattern);\n  } catch {\n    console.warn(\n      `Could not convert regex pattern at ${refs.currentPath.join(\n        '/',\n      )} to a flag-independent form! Falling back to the flag-ignorant source`,\n    );\n    return regex.source;\n  }\n\n  return pattern;\n}\n","import { ZodMapDef } from 'zod/v3';\nimport { parseDef } from '../parse-def';\nimport { JsonSchema7Type } from '../parse-types';\nimport { Refs } from '../refs';\nimport { parseAnyDef } from './any';\nimport { JsonSchema7RecordType, parseRecordDef } from './record';\n\nexport type JsonSchema7MapType = {\n  type: 'array';\n  maxItems: 125;\n  items: {\n    type: 'array';\n    items: [JsonSchema7Type, JsonSchema7Type];\n    minItems: 2;\n    maxItems: 2;\n  };\n};\n\nexport function parseMapDef(\n  def: ZodMapDef,\n  refs: Refs,\n): JsonSchema7MapType | JsonSchema7RecordType {\n  if (refs.mapStrategy === 'record') {\n    return parseRecordDef(def, refs);\n  }\n\n  const keys =\n    parseDef(def.keyType._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, 'items', 'items', '0'],\n    }) || parseAnyDef();\n  const values =\n    parseDef(def.valueType._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, 'items', 'items', '1'],\n    }) || parseAnyDef();\n  return {\n    type: 'array',\n    maxItems: 125,\n    items: {\n      type: 'array',\n      items: [keys, values],\n      minItems: 2,\n      maxItems: 2,\n    },\n  };\n}\n","import { ZodNativeEnumDef } from 'zod/v3';\n\nexport type JsonSchema7NativeEnumType = {\n  type: 'string' | 'number' | ['string', 'number'];\n  enum: (string | number)[];\n};\n\nexport function parseNativeEnumDef(\n  def: ZodNativeEnumDef,\n): JsonSchema7NativeEnumType {\n  const object = def.values;\n  const actualKeys = Object.keys(def.values).filter((key: string) => {\n    return typeof object[object[key]] !== 'number';\n  });\n\n  const actualValues = actualKeys.map((key: string) => object[key]);\n\n  const parsedTypes = Array.from(\n    new Set(actualValues.map((values: string | number) => typeof values)),\n  );\n\n  return {\n    type:\n      parsedTypes.length === 1\n        ? parsedTypes[0] === 'string'\n          ? 'string'\n          : 'number'\n        : ['string', 'number'],\n    enum: actualValues,\n  };\n}\n","import { JsonSchema7AnyType, parseAnyDef } from './any';\n\nexport type JsonSchema7NeverType = {\n  not: JsonSchema7AnyType;\n};\n\nexport function parseNeverDef(): JsonSchema7NeverType | undefined {\n  return { not: parseAnyDef() };\n}\n","export type JsonSchema7NullType = {\n  type: 'null';\n};\n\nexport function parseNullDef(): JsonSchema7NullType {\n  return {\n    type: 'null',\n  };\n}\n","import {\n  ZodDiscriminatedUnionDef,\n  ZodLiteralDef,\n  ZodTypeAny,\n  ZodUnionDef,\n} from 'zod/v3';\nimport { parseDef } from '../parse-def';\nimport { JsonSchema7Type } from '../parse-types';\nimport { Refs } from '../refs';\n\nexport const primitiveMappings = {\n  ZodString: 'string',\n  ZodNumber: 'number',\n  ZodBigInt: 'integer',\n  ZodBoolean: 'boolean',\n  ZodNull: 'null',\n} as const;\ntype ZodPrimitive = keyof typeof primitiveMappings;\ntype JsonSchema7Primitive =\n  (typeof primitiveMappings)[keyof typeof primitiveMappings];\n\nexport type JsonSchema7UnionType =\n  | JsonSchema7PrimitiveUnionType\n  | JsonSchema7AnyOfType;\n\ntype JsonSchema7PrimitiveUnionType =\n  | {\n      type: JsonSchema7Primitive | JsonSchema7Primitive[];\n    }\n  | {\n      type: JsonSchema7Primitive | JsonSchema7Primitive[];\n      enum: (string | number | bigint | boolean | null)[];\n    };\n\ntype JsonSchema7AnyOfType = {\n  anyOf: JsonSchema7Type[];\n};\n\nexport function parseUnionDef(\n  def: ZodUnionDef | ZodDiscriminatedUnionDef<any, any>,\n  refs: Refs,\n): JsonSchema7PrimitiveUnionType | JsonSchema7AnyOfType | undefined {\n  const options: readonly ZodTypeAny[] =\n    def.options instanceof Map ? Array.from(def.options.values()) : def.options;\n\n  // This blocks tries to look ahead a bit to produce nicer looking schemas with type array instead of anyOf.\n  if (\n    options.every(\n      x =>\n        x._def.typeName in primitiveMappings &&\n        (!x._def.checks || !x._def.checks.length),\n    )\n  ) {\n    // all types in union are primitive and lack checks, so might as well squash into {type: [...]}\n\n    const types = options.reduce((types: JsonSchema7Primitive[], x) => {\n      const type = primitiveMappings[x._def.typeName as ZodPrimitive]; //Can be safely casted due to row 43\n      return type && !types.includes(type) ? [...types, type] : types;\n    }, []);\n\n    return {\n      type: types.length > 1 ? types : types[0],\n    };\n  } else if (\n    options.every(x => x._def.typeName === 'ZodLiteral' && !x.description)\n  ) {\n    // all options literals\n\n    const types = options.reduce(\n      (acc: JsonSchema7Primitive[], x: { _def: ZodLiteralDef }) => {\n        const type = typeof x._def.value;\n        switch (type) {\n          case 'string':\n          case 'number':\n          case 'boolean':\n            return [...acc, type];\n          case 'bigint':\n            return [...acc, 'integer' as const];\n          case 'object':\n            if (x._def.value === null) return [...acc, 'null' as const];\n          case 'symbol':\n          case 'undefined':\n          case 'function':\n          default:\n            return acc;\n        }\n      },\n      [],\n    );\n\n    if (types.length === options.length) {\n      // all the literals are primitive, as far as null can be considered primitive\n\n      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);\n      return {\n        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],\n        enum: options.reduce(\n          (acc, x) => {\n            return acc.includes(x._def.value) ? acc : [...acc, x._def.value];\n          },\n          [] as (string | number | bigint | boolean | null)[],\n        ),\n      };\n    }\n  } else if (options.every(x => x._def.typeName === 'ZodEnum')) {\n    return {\n      type: 'string',\n      enum: options.reduce(\n        (acc: string[], x) => [\n          ...acc,\n          ...x._def.values.filter((x: string) => !acc.includes(x)),\n        ],\n        [],\n      ),\n    };\n  }\n\n  return asAnyOf(def, refs);\n}\n\nconst asAnyOf = (\n  def: ZodUnionDef | ZodDiscriminatedUnionDef<any, any>,\n  refs: Refs,\n): JsonSchema7PrimitiveUnionType | JsonSchema7AnyOfType | undefined => {\n  const anyOf = (\n    (def.options instanceof Map\n      ? Array.from(def.options.values())\n      : def.options) as any[]\n  )\n    .map((x, i) =>\n      parseDef(x._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, 'anyOf', `${i}`],\n      }),\n    )\n    .filter(\n      (x): x is JsonSchema7Type =>\n        !!x &&\n        (!refs.strictUnions ||\n          (typeof x === 'object' && Object.keys(x).length > 0)),\n    );\n\n  return anyOf.length ? { anyOf } : undefined;\n};\n","import { ZodNullableDef } from 'zod/v3';\nimport { parseDef } from '../parse-def';\nimport { JsonSchema7Type } from '../parse-types';\nimport { Refs } from '../refs';\nimport { JsonSchema7NullType } from './null';\nimport { primitiveMappings } from './union';\n\nexport type JsonSchema7NullableType =\n  | {\n      anyOf: [JsonSchema7Type, JsonSchema7NullType];\n    }\n  | {\n      type: [string, 'null'];\n    };\n\nexport function parseNullableDef(\n  def: ZodNullableDef,\n  refs: Refs,\n): JsonSchema7NullableType | undefined {\n  if (\n    ['ZodString', 'ZodNumber', 'ZodBigInt', 'ZodBoolean', 'ZodNull'].includes(\n      def.innerType._def.typeName,\n    ) &&\n    (!def.innerType._def.checks || !def.innerType._def.checks.length)\n  ) {\n    return {\n      type: [\n        primitiveMappings[\n          def.innerType._def.typeName as keyof typeof primitiveMappings\n        ],\n        'null',\n      ],\n    };\n  }\n\n  const base = parseDef(def.innerType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, 'anyOf', '0'],\n  });\n\n  return base && { anyOf: [base, { type: 'null' }] };\n}\n","import { ZodNumberDef } from 'zod/v3';\n\nexport type JsonSchema7NumberType = {\n  type: 'number' | 'integer';\n  minimum?: number;\n  exclusiveMinimum?: number;\n  maximum?: number;\n  exclusiveMaximum?: number;\n  multipleOf?: number;\n};\n\nexport function parseNumberDef(def: ZodNumberDef): JsonSchema7NumberType {\n  const res: JsonSchema7NumberType = {\n    type: 'number',\n  };\n\n  if (!def.checks) return res;\n\n  for (const check of def.checks) {\n    switch (check.kind) {\n      case 'int':\n        res.type = 'integer';\n        break;\n      case 'min':\n        if (check.inclusive) {\n          res.minimum = check.value;\n        } else {\n          res.exclusiveMinimum = check.value;\n        }\n        break;\n      case 'max':\n        if (check.inclusive) {\n          res.maximum = check.value;\n        } else {\n          res.exclusiveMaximum = check.value;\n        }\n        break;\n      case 'multipleOf':\n        res.multipleOf = check.value;\n        break;\n    }\n  }\n  return res;\n}\n","import { ZodObjectDef, ZodTypeAny } from 'zod/v3';\nimport { parseDef } from '../parse-def';\nimport { JsonSchema7Type } from '../parse-types';\nimport { Refs } from '../refs';\n\nexport type JsonSchema7ObjectType = {\n  type: 'object';\n  properties: Record<string, JsonSchema7Type>;\n  additionalProperties?: boolean | JsonSchema7Type;\n  required?: string[];\n};\n\nexport function parseObjectDef(def: ZodObjectDef, refs: Refs) {\n  const result: JsonSchema7ObjectType = {\n    type: 'object',\n    properties: {},\n  };\n\n  const required: string[] = [];\n\n  const shape = def.shape();\n\n  for (const propName in shape) {\n    let propDef = shape[propName];\n\n    if (propDef === undefined || propDef._def === undefined) {\n      continue;\n    }\n\n    const propOptional = safeIsOptional(propDef);\n\n    const parsedDef = parseDef(propDef._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, 'properties', propName],\n      propertyPath: [...refs.currentPath, 'properties', propName],\n    });\n\n    if (parsedDef === undefined) {\n      continue;\n    }\n\n    result.properties[propName] = parsedDef;\n\n    if (!propOptional) {\n      required.push(propName);\n    }\n  }\n\n  if (required.length) {\n    result.required = required;\n  }\n\n  const additionalProperties = decideAdditionalProperties(def, refs);\n\n  if (additionalProperties !== undefined) {\n    result.additionalProperties = additionalProperties;\n  }\n\n  return result;\n}\n\nfunction decideAdditionalProperties(def: ZodObjectDef, refs: Refs) {\n  if (def.catchall._def.typeName !== 'ZodNever') {\n    return parseDef(def.catchall._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, 'additionalProperties'],\n    });\n  }\n\n  switch (def.unknownKeys) {\n    case 'passthrough':\n      return refs.allowedAdditionalProperties;\n    case 'strict':\n      return refs.rejectedAdditionalProperties;\n    case 'strip':\n      return refs.removeAdditionalStrategy === 'strict'\n        ? refs.allowedAdditionalProperties\n        : refs.rejectedAdditionalProperties;\n  }\n}\n\nfunction safeIsOptional(schema: ZodTypeAny): boolean {\n  try {\n    return schema.isOptional();\n  } catch {\n    return true;\n  }\n}\n","import { ZodOptionalDef } from 'zod/v3';\nimport { parseDef } from '../parse-def';\nimport { JsonSchema7Type } from '../parse-types';\nimport { Refs } from '../refs';\nimport { parseAnyDef } from './any';\n\nexport const parseOptionalDef = (\n  def: ZodOptionalDef,\n  refs: Refs,\n): JsonSchema7Type | undefined => {\n  if (refs.currentPath.toString() === refs.propertyPath?.toString()) {\n    return parseDef(def.innerType._def, refs);\n  }\n\n  const innerSchema = parseDef(def.innerType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, 'anyOf', '1'],\n  });\n\n  return innerSchema\n    ? { anyOf: [{ not: parseAnyDef() }, innerSchema] }\n    : parseAnyDef();\n};\n","import { ZodPipelineDef } from 'zod/v3';\nimport { parseDef } from '../parse-def';\nimport { JsonSchema7Type } from '../parse-types';\nimport { Refs } from '../refs';\nimport { JsonSchema7AllOfType } from './intersection';\n\nexport const parsePipelineDef = (\n  def: ZodPipelineDef<any, any>,\n  refs: Refs,\n): JsonSchema7AllOfType | JsonSchema7Type | undefined => {\n  if (refs.pipeStrategy === 'input') {\n    return parseDef(def.in._def, refs);\n  } else if (refs.pipeStrategy === 'output') {\n    return parseDef(def.out._def, refs);\n  }\n\n  const a = parseDef(def.in._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, 'allOf', '0'],\n  });\n  const b = parseDef(def.out._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, 'allOf', a ? '1' : '0'],\n  });\n\n  return {\n    allOf: [a, b].filter((x): x is JsonSchema7Type => x !== undefined),\n  };\n};\n","import { ZodPromiseDef } from 'zod/v3';\nimport { parseDef } from '../parse-def';\nimport { JsonSchema7Type } from '../parse-types';\nimport { Refs } from '../refs';\n\nexport function parsePromiseDef(\n  def: ZodPromiseDef,\n  refs: Refs,\n): JsonSchema7Type | undefined {\n  return parseDef(def.type._def, refs);\n}\n","import { ZodSetDef } from 'zod/v3';\nimport { parseDef } from '../parse-def';\nimport { JsonSchema7Type } from '../parse-types';\nimport { Refs } from '../refs';\n\nexport type JsonSchema7SetType = {\n  type: 'array';\n  uniqueItems: true;\n  items?: JsonSchema7Type;\n  minItems?: number;\n  maxItems?: number;\n};\n\nexport function parseSetDef(def: ZodSetDef, refs: Refs): JsonSchema7SetType {\n  const items = parseDef(def.valueType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, 'items'],\n  });\n\n  const schema: JsonSchema7SetType = {\n    type: 'array',\n    uniqueItems: true,\n    items,\n  };\n\n  if (def.minSize) {\n    schema.minItems = def.minSize.value;\n  }\n\n  if (def.maxSize) {\n    schema.maxItems = def.maxSize.value;\n  }\n\n  return schema;\n}\n","import { ZodTupleDef, ZodTupleItems, ZodTypeAny } from 'zod/v3';\nimport { parseDef } from '../parse-def';\nimport { JsonSchema7Type } from '../parse-types';\nimport { Refs } from '../refs';\n\nexport type JsonSchema7TupleType = {\n  type: 'array';\n  minItems: number;\n  items: JsonSchema7Type[];\n} & (\n  | {\n      maxItems: number;\n    }\n  | {\n      additionalItems?: JsonSchema7Type;\n    }\n);\n\nexport function parseTupleDef(\n  def: ZodTupleDef<ZodTupleItems | [], ZodTypeAny | null>,\n  refs: Refs,\n): JsonSchema7TupleType {\n  if (def.rest) {\n    return {\n      type: 'array',\n      minItems: def.items.length,\n      items: def.items\n        .map((x, i) =>\n          parseDef(x._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, 'items', `${i}`],\n          }),\n        )\n        .reduce(\n          (acc: JsonSchema7Type[], x) => (x === undefined ? acc : [...acc, x]),\n          [],\n        ),\n      additionalItems: parseDef(def.rest._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, 'additionalItems'],\n      }),\n    };\n  } else {\n    return {\n      type: 'array',\n      minItems: def.items.length,\n      maxItems: def.items.length,\n      items: def.items\n        .map((x, i) =>\n          parseDef(x._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, 'items', `${i}`],\n          }),\n        )\n        .reduce(\n          (acc: JsonSchema7Type[], x) => (x === undefined ? acc : [...acc, x]),\n          [],\n        ),\n    };\n  }\n}\n","import { JsonSchema7AnyType, parseAnyDef } from './any';\n\nexport type JsonSchema7UndefinedType = {\n  not: JsonSchema7AnyType;\n};\n\nexport function parseUndefinedDef(): JsonSchema7UndefinedType {\n  return {\n    not: parseAnyDef(),\n  };\n}\n","import { JsonSchema7AnyType, parseAnyDef } from './any';\n\nexport type JsonSchema7UnknownType = JsonSchema7AnyType;\n\nexport function parseUnknownDef(): JsonSchema7UnknownType {\n  return parseAnyDef();\n}\n","import { ZodReadonlyDef } from 'zod/v3';\nimport { parseDef } from '../parse-def';\nimport { Refs } from '../refs';\n\nexport const parseReadonlyDef = (def: ZodReadonlyDef<any>, refs: Refs) => {\n  return parseDef(def.innerType._def, refs);\n};\n","export const getRelativePath = (pathA: string[], pathB: string[]) => {\n  let i = 0;\n  for (; i < pathA.length && i < pathB.length; i++) {\n    if (pathA[i] !== pathB[i]) break;\n  }\n  return [(pathA.length - i).toString(), ...pathB.slice(i)].join('/');\n};\n","import { ZodTypeDef } from 'zod/v3';\nimport { Refs, Seen } from './refs';\nimport { ignoreOverride } from './options';\nimport { JsonSchema7Type } from './parse-types';\nimport { selectParser } from './select-parser';\nimport { getRelativePath } from './get-relative-path';\nimport { parseAnyDef } from './parsers/any';\n\nexport function parseDef(\n  def: ZodTypeDef,\n  refs: Refs,\n  forceResolution = false, // Forces a new schema to be instantiated even though its def has been seen. Used for improving refs in definitions. See https://github.com/StefanTerdell/zod-to-json-schema/pull/61.\n): JsonSchema7Type | undefined {\n  const seenItem = refs.seen.get(def);\n\n  if (refs.override) {\n    const overrideResult = refs.override?.(\n      def,\n      refs,\n      seenItem,\n      forceResolution,\n    );\n\n    if (overrideResult !== ignoreOverride) {\n      return overrideResult;\n    }\n  }\n\n  if (seenItem && !forceResolution) {\n    const seenSchema = get$ref(seenItem, refs);\n\n    if (seenSchema !== undefined) {\n      return seenSchema;\n    }\n  }\n\n  const newItem: Seen = { def, path: refs.currentPath, jsonSchema: undefined };\n\n  refs.seen.set(def, newItem);\n\n  const jsonSchemaOrGetter = selectParser(def, (def as any).typeName, refs);\n\n  // If the return was a function, then the inner definition needs to be extracted before a call to parseDef (recursive)\n  const jsonSchema =\n    typeof jsonSchemaOrGetter === 'function'\n      ? parseDef(jsonSchemaOrGetter(), refs)\n      : jsonSchemaOrGetter;\n\n  if (jsonSchema) {\n    addMeta(def, refs, jsonSchema);\n  }\n\n  if (refs.postProcess) {\n    const postProcessResult = refs.postProcess(jsonSchema, def, refs);\n\n    newItem.jsonSchema = jsonSchema;\n\n    return postProcessResult;\n  }\n\n  newItem.jsonSchema = jsonSchema;\n\n  return jsonSchema;\n}\n\nconst get$ref = (\n  item: Seen,\n  refs: Refs,\n):\n  | {\n      $ref: string;\n    }\n  | {}\n  | undefined => {\n  switch (refs.$refStrategy) {\n    case 'root':\n      return { $ref: item.path.join('/') };\n    case 'relative':\n      return { $ref: getRelativePath(refs.currentPath, item.path) };\n    case 'none':\n    case 'seen': {\n      if (\n        item.path.length < refs.currentPath.length &&\n        item.path.every((value, index) => refs.currentPath[index] === value)\n      ) {\n        console.warn(\n          `Recursive reference detected at ${refs.currentPath.join(\n            '/',\n          )}! Defaulting to any`,\n        );\n\n        return parseAnyDef();\n      }\n\n      return refs.$refStrategy === 'seen' ? parseAnyDef() : undefined;\n    }\n  }\n};\n\nconst addMeta = (\n  def: ZodTypeDef,\n  refs: Refs,\n  jsonSchema: JsonSchema7Type,\n): JsonSchema7Type => {\n  if (def.description) {\n    jsonSchema.description = def.description;\n  }\n  return jsonSchema;\n};\n","import { ZodTypeDef } from 'zod/v3';\nimport { getDefaultOptions, Options } from './options';\nimport { JsonSchema7Type } from './parse-types';\n\nexport type Refs = {\n  seen: Map<ZodTypeDef, Seen>;\n  currentPath: string[];\n  propertyPath: string[] | undefined;\n} & Options;\n\nexport type Seen = {\n  def: ZodTypeDef;\n  path: string[];\n  jsonSchema: JsonSchema7Type | undefined;\n};\n\nexport const getRefs = (options?: string | Partial<Options>): Refs => {\n  const _options = getDefaultOptions(options);\n  const currentPath =\n    _options.name !== undefined\n      ? [..._options.basePath, _options.definitionPath, _options.name]\n      : _options.basePath;\n  return {\n    ..._options,\n    currentPath: currentPath,\n    propertyPath: undefined,\n    seen: new Map(\n      Object.entries(_options.definitions).map(([name, def]) => [\n        def._def,\n        {\n          def: def._def,\n          path: [..._options.basePath, _options.definitionPath, name],\n          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.\n          jsonSchema: undefined,\n        },\n      ]),\n    ),\n  };\n};\n","import { ZodSchema } from 'zod/v3';\nimport { Options } from './options';\nimport { parseDef } from './parse-def';\nimport { JsonSchema7Type } from './parse-types';\nimport { getRefs } from './refs';\nimport { parseAnyDef } from './parsers/any';\n\nconst zod3ToJsonSchema = (\n  schema: ZodSchema<any>,\n  options?: Partial<Options> | string,\n): JsonSchema7Type & {\n  $schema?: string;\n  definitions?: {\n    [key: string]: JsonSchema7Type;\n  };\n} => {\n  const refs = getRefs(options);\n\n  let definitions =\n    typeof options === 'object' && options.definitions\n      ? Object.entries(options.definitions).reduce(\n          (acc: { [key: string]: JsonSchema7Type }, [name, schema]) => ({\n            ...acc,\n            [name]:\n              parseDef(\n                schema._def,\n                {\n                  ...refs,\n                  currentPath: [...refs.basePath, refs.definitionPath, name],\n                },\n                true,\n              ) ?? parseAnyDef(),\n          }),\n          {},\n        )\n      : undefined;\n\n  const name =\n    typeof options === 'string'\n      ? options\n      : options?.nameStrategy === 'title'\n        ? undefined\n        : options?.name;\n\n  const main =\n    parseDef(\n      schema._def,\n      name === undefined\n        ? refs\n        : {\n            ...refs,\n            currentPath: [...refs.basePath, refs.definitionPath, name],\n          },\n      false,\n    ) ?? (parseAnyDef() as JsonSchema7Type);\n\n  const title =\n    typeof options === 'object' &&\n    options.name !== undefined &&\n    options.nameStrategy === 'title'\n      ? options.name\n      : undefined;\n\n  if (title !== undefined) {\n    main.title = title;\n  }\n\n  const combined: ReturnType<typeof zod3ToJsonSchema> =\n    name === undefined\n      ? definitions\n        ? {\n            ...main,\n            [refs.definitionPath]: definitions,\n          }\n        : main\n      : {\n          $ref: [\n            ...(refs.$refStrategy === 'relative' ? [] : refs.basePath),\n            refs.definitionPath,\n            name,\n          ].join('/'),\n          [refs.definitionPath]: {\n            ...definitions,\n            [name]: main,\n          },\n        };\n\n  combined.$schema = 'http://json-schema.org/draft-07/schema#';\n\n  return combined;\n};\n\nexport { zod3ToJsonSchema };\n","import {\n  EventSourceMessage,\n  EventSourceParserStream,\n} from 'eventsource-parser/stream';\nimport { ParseResult, safeParseJSON } from './parse-json';\nimport { FlexibleSchema } from './schema';\n\n/**\n * Parses a JSON event stream into a stream of parsed JSON objects.\n */\nexport function parseJsonEventStream<T>({\n  stream,\n  schema,\n}: {\n  stream: ReadableStream<Uint8Array>;\n  schema: FlexibleSchema<T>;\n}): ReadableStream<ParseResult<T>> {\n  return stream\n    .pipeThrough(new TextDecoderStream())\n    .pipeThrough(new EventSourceParserStream())\n    .pipeThrough(\n      new TransformStream<EventSourceMessage, ParseResult<T>>({\n        async transform({ data }, controller) {\n          // ignore the 'DONE' event that e.g. OpenAI sends:\n          if (data === '[DONE]') {\n            return;\n          }\n\n          controller.enqueue(await safeParseJSON({ text: data, schema }));\n        },\n      }),\n    );\n}\n","import { InvalidArgumentError } from '@ai-sdk/provider';\nimport { safeValidateTypes } from './validate-types';\nimport { FlexibleSchema } from './schema';\n\nexport async function parseProviderOptions<OPTIONS>({\n  provider,\n  providerOptions,\n  schema,\n}: {\n  provider: string;\n  providerOptions: Record<string, unknown> | undefined;\n  schema: FlexibleSchema<OPTIONS>;\n}): Promise<OPTIONS | undefined> {\n  if (providerOptions?.[provider] == null) {\n    return undefined;\n  }\n\n  const parsedProviderOptions = await safeValidateTypes<OPTIONS | undefined>({\n    value: providerOptions[provider],\n    schema,\n  });\n\n  if (!parsedProviderOptions.success) {\n    throw new InvalidArgumentError({\n      argument: 'providerOptions',\n      message: `invalid ${provider} provider options`,\n      cause: parsedProviderOptions.error,\n    });\n  }\n\n  return parsedProviderOptions.value;\n}\n","import { APICallError } from '@ai-sdk/provider';\nimport { extractResponseHeaders } from './extract-response-headers';\nimport { FetchFunction } from './fetch-function';\nimport { handleFetchError } from './handle-fetch-error';\nimport { isAbortError } from './is-abort-error';\nimport { ResponseHandler } from './response-handler';\nimport { getRuntimeEnvironmentUserAgent } from './get-runtime-environment-user-agent';\nimport { withUserAgentSuffix } from './with-user-agent-suffix';\nimport { VERSION } from './version';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => globalThis.fetch;\n\nexport const postJsonToApi = async <T>({\n  url,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch,\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  body: unknown;\n  failedResponseHandler: ResponseHandler<APICallError>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) =>\n  postToApi({\n    url,\n    headers: {\n      'Content-Type': 'application/json',\n      ...headers,\n    },\n    body: {\n      content: JSON.stringify(body),\n      values: body,\n    },\n    failedResponseHandler,\n    successfulResponseHandler,\n    abortSignal,\n    fetch,\n  });\n\nexport const postFormDataToApi = async <T>({\n  url,\n  headers,\n  formData,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch,\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  formData: FormData;\n  failedResponseHandler: ResponseHandler<APICallError>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) =>\n  postToApi({\n    url,\n    headers,\n    body: {\n      content: formData,\n      values: Object.fromEntries((formData as any).entries()),\n    },\n    failedResponseHandler,\n    successfulResponseHandler,\n    abortSignal,\n    fetch,\n  });\n\nexport const postToApi = async <T>({\n  url,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch(),\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  body: {\n    content: string | FormData | Uint8Array;\n    values: unknown;\n  };\n  failedResponseHandler: ResponseHandler<Error>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: withUserAgentSuffix(\n        headers,\n        `ai-sdk/provider-utils/${VERSION}`,\n        getRuntimeEnvironmentUserAgent(),\n      ),\n      body: body.content,\n      signal: abortSignal,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.ok) {\n      let errorInformation: {\n        value: Error;\n        responseHeaders?: Record<string, string> | undefined;\n      };\n\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: body.values,\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n\n        throw new APICallError({\n          message: 'Failed to process error response',\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: body.values,\n        });\n      }\n\n      throw errorInformation.value;\n    }\n\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: body.values,\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n\n      throw new APICallError({\n        message: 'Failed to process successful response',\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: body.values,\n      });\n    }\n  } catch (error) {\n    throw handleFetchError({ error, url, requestBodyValues: body.values });\n  }\n};\n","import { JSONValue } from '@ai-sdk/provider';\nimport { FlexibleSchema } from '../schema';\nimport { ToolResultOutput } from './content-part';\nimport { ModelMessage } from './model-message';\nimport { ProviderOptions } from './provider-options';\n\n/**\n * Additional options that are sent into each tool call.\n */\nexport interface ToolExecutionOptions {\n  /**\n   * The ID of the tool call. You can use it e.g. when sending tool-call related information with stream data.\n   */\n  toolCallId: string;\n\n  /**\n   * Messages that were sent to the language model to initiate the response that contained the tool call.\n   * The messages **do not** include the system prompt nor the assistant response that contained the tool call.\n   */\n  messages: ModelMessage[];\n\n  /**\n   * An optional abort signal that indicates that the overall operation should be aborted.\n   */\n  abortSignal?: AbortSignal;\n\n  /**\n   * User-defined context.\n   *\n   * Treat the context object as immutable inside tools.\n   * Mutating the context object can lead to race conditions and unexpected results\n   * when tools are called in parallel.\n   *\n   * If you need to mutate the context, analyze the tool calls and results\n   * in `prepareStep` and update it there.\n   *\n   * Experimental (can break in patch releases).\n   */\n  experimental_context?: unknown;\n}\n\n/**\n * Function that is called to determine if the tool needs approval before it can be executed.\n */\nexport type ToolNeedsApprovalFunction<INPUT> = (\n  input: INPUT,\n  options: {\n    /**\n     * The ID of the tool call. You can use it e.g. when sending tool-call related information with stream data.\n     */\n    toolCallId: string;\n\n    /**\n     * Messages that were sent to the language model to initiate the response that contained the tool call.\n     * The messages **do not** include the system prompt nor the assistant response that contained the tool call.\n     */\n    messages: ModelMessage[];\n\n    /**\n     * Additional context.\n     *\n     * Experimental (can break in patch releases).\n     */\n    experimental_context?: unknown;\n  },\n) => boolean | PromiseLike<boolean>;\n\nexport type ToolExecuteFunction<INPUT, OUTPUT> = (\n  input: INPUT,\n  options: ToolExecutionOptions,\n) => AsyncIterable<OUTPUT> | PromiseLike<OUTPUT> | OUTPUT;\n\n// 0 extends 1 & N checks for any\n// [N] extends [never] checks for never\ntype NeverOptional<N, T> = 0 extends 1 & N\n  ? Partial<T>\n  : [N] extends [never]\n    ? Partial<Record<keyof T, undefined>>\n    : T;\n\ntype ToolOutputProperties<INPUT, OUTPUT> = NeverOptional<\n  OUTPUT,\n  | {\n      /**\nAn async function that is called with the arguments from the tool call and produces a result.\nIf not provided, the tool will not be executed automatically.\n\n@args is the input of the tool call.\n@options.abortSignal is a signal that can be used to abort the tool call.\n    */\n      execute: ToolExecuteFunction<INPUT, OUTPUT>;\n\n      outputSchema?: FlexibleSchema<OUTPUT>;\n    }\n  | {\n      outputSchema: FlexibleSchema<OUTPUT>;\n\n      execute?: never;\n    }\n>;\n\n/**\nA tool contains the description and the schema of the input that the tool expects.\nThis enables the language model to generate the input.\n\nThe tool can also contain an optional execute function for the actual execution function of the tool.\n */\nexport type Tool<\n  INPUT extends JSONValue | unknown | never = any,\n  OUTPUT extends JSONValue | unknown | never = any,\n> = {\n  /**\nAn optional description of what the tool does.\nWill be used by the language model to decide whether to use the tool.\nNot used for provider-defined tools.\n   */\n  description?: string;\n\n  /**\n   * An optional title of the tool.\n   */\n  title?: string;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n   */\n  providerOptions?: ProviderOptions;\n\n  /**\n   * The schema of the input that the tool expects.\n   * The language model will use this to generate the input.\n   * It is also used to validate the output of the language model.\n   *\n   * You can use descriptions on the schema properties to make the input understandable for the language model.\n   */\n  inputSchema: FlexibleSchema<INPUT>;\n\n  /**\n   * An optional list of input examples that show the language\n   * model what the input should look like.\n   */\n  inputExamples?: Array<{ input: INPUT }>;\n\n  /**\n   * Whether the tool needs approval before it can be executed.\n   */\n  needsApproval?:\n    | boolean\n    | ToolNeedsApprovalFunction<[INPUT] extends [never] ? unknown : INPUT>;\n\n  /**\n   * Strict mode setting for the tool.\n   *\n   * Providers that support strict mode will use this setting to determine\n   * how the input should be generated. Strict mode will always produce\n   * valid inputs, but it might limit what input schemas are supported.\n   */\n  strict?: boolean;\n\n  /**\n   * Optional function that is called when the argument streaming starts.\n   * Only called when the tool is used in a streaming context.\n   */\n  onInputStart?: (options: ToolExecutionOptions) => void | PromiseLike<void>;\n\n  /**\n   * Optional function that is called when an argument streaming delta is available.\n   * Only called when the tool is used in a streaming context.\n   */\n  onInputDelta?: (\n    options: { inputTextDelta: string } & ToolExecutionOptions,\n  ) => void | PromiseLike<void>;\n\n  /**\n   * Optional function that is called when a tool call can be started,\n   * even if the execute function is not provided.\n   */\n  onInputAvailable?: (\n    options: {\n      input: [INPUT] extends [never] ? unknown : INPUT;\n    } & ToolExecutionOptions,\n  ) => void | PromiseLike<void>;\n} & ToolOutputProperties<INPUT, OUTPUT> & {\n    /**\n     * Optional conversion function that maps the tool result to an output that can be used by the language model.\n     *\n     * If not provided, the tool result will be sent as a JSON object.\n     */\n    toModelOutput?: (options: {\n      /**\n       * The ID of the tool call. You can use it e.g. when sending tool-call related information with stream data.\n       */\n      toolCallId: string;\n\n      /**\n       * The input of the tool call.\n       */\n      input: [INPUT] extends [never] ? unknown : INPUT;\n\n      /**\n       * The output of the tool call.\n       */\n      output: 0 extends 1 & OUTPUT\n        ? any\n        : [OUTPUT] extends [never]\n          ? any\n          : NoInfer<OUTPUT>;\n    }) => ToolResultOutput | PromiseLike<ToolResultOutput>;\n  } & (\n    | {\n        /**\nTool with user-defined input and output schemas.\n     */\n        type?: undefined | 'function';\n      }\n    | {\n        /**\nTool that is defined at runtime (e.g. an MCP tool).\nThe types of input and output are not known at development time.\n       */\n        type: 'dynamic';\n      }\n    | {\n        /**\nTool with provider-defined input and output schemas.\n     */\n        type: 'provider';\n\n        /**\nThe ID of the tool. Must follow the format `<provider-name>.<unique-tool-name>`.\n   */\n        id: `${string}.${string}`;\n\n        /**\nThe arguments for configuring the tool. Must match the expected arguments defined by the provider for this tool.\n     */\n        args: Record<string, unknown>;\n\n        /**\n         * Whether this provider-executed tool supports deferred results.\n         *\n         * When true, the tool result may not be returned in the same turn as the\n         * tool call (e.g., when using programmatic tool calling where a server tool\n         * triggers a client-executed tool, and the server tool's result is deferred\n         * until the client tool is resolved).\n         *\n         * This flag allows the AI SDK to handle tool results that arrive without\n         * a matching tool call in the current response.\n         *\n         * @default false\n         */\n        supportsDeferredResults?: boolean;\n      }\n  );\n\n/**\n * Infer the input type of a tool.\n */\nexport type InferToolInput<TOOL extends Tool> =\n  TOOL extends Tool<infer INPUT, any> ? INPUT : never;\n\n/**\n * Infer the output type of a tool.\n */\nexport type InferToolOutput<TOOL extends Tool> =\n  TOOL extends Tool<any, infer OUTPUT> ? OUTPUT : never;\n\n/**\nHelper function for inferring the execute args of a tool.\n */\n// Note: overload order is important for auto-completion\nexport function tool<INPUT, OUTPUT>(\n  tool: Tool<INPUT, OUTPUT>,\n): Tool<INPUT, OUTPUT>;\nexport function tool<INPUT>(tool: Tool<INPUT, never>): Tool<INPUT, never>;\nexport function tool<OUTPUT>(tool: Tool<never, OUTPUT>): Tool<never, OUTPUT>;\nexport function tool(tool: Tool<never, never>): Tool<never, never>;\nexport function tool(tool: any): any {\n  return tool;\n}\n\n/**\n * Defines a dynamic tool.\n */\nexport function dynamicTool(tool: {\n  description?: string;\n  title?: string;\n  providerOptions?: ProviderOptions;\n  inputSchema: FlexibleSchema<unknown>;\n  execute: ToolExecuteFunction<unknown, unknown>;\n\n  /**\n   * Optional conversion function that maps the tool result to an output that can be used by the language model.\n   *\n   * If not provided, the tool result will be sent as a JSON object.\n   */\n  toModelOutput?: (options: {\n    /**\n     * The ID of the tool call. You can use it e.g. when sending tool-call related information with stream data.\n     */\n    toolCallId: string;\n\n    /**\n     * The input of the tool call.\n     */\n    input: unknown;\n\n    /**\n     * The output of the tool call.\n     */\n    output: unknown;\n  }) => ToolResultOutput | PromiseLike<ToolResultOutput>;\n\n  /**\n   * Whether the tool needs approval before it can be executed.\n   */\n  needsApproval?: boolean | ToolNeedsApprovalFunction<unknown>;\n}): Tool<unknown, unknown> & {\n  type: 'dynamic';\n} {\n  return { ...tool, type: 'dynamic' };\n}\n","import { tool, Tool, ToolExecuteFunction } from './types/tool';\nimport { FlexibleSchema } from './schema';\n\nexport type ProviderToolFactory<INPUT, ARGS extends object> = <OUTPUT>(\n  options: ARGS & {\n    execute?: ToolExecuteFunction<INPUT, OUTPUT>;\n    needsApproval?: Tool<INPUT, OUTPUT>['needsApproval'];\n    toModelOutput?: Tool<INPUT, OUTPUT>['toModelOutput'];\n    onInputStart?: Tool<INPUT, OUTPUT>['onInputStart'];\n    onInputDelta?: Tool<INPUT, OUTPUT>['onInputDelta'];\n    onInputAvailable?: Tool<INPUT, OUTPUT>['onInputAvailable'];\n  },\n) => Tool<INPUT, OUTPUT>;\n\nexport function createProviderToolFactory<INPUT, ARGS extends object>({\n  id,\n  inputSchema,\n}: {\n  id: `${string}.${string}`;\n  inputSchema: FlexibleSchema<INPUT>;\n}): ProviderToolFactory<INPUT, ARGS> {\n  return <OUTPUT>({\n    execute,\n    outputSchema,\n    needsApproval,\n    toModelOutput,\n    onInputStart,\n    onInputDelta,\n    onInputAvailable,\n    ...args\n  }: ARGS & {\n    execute?: ToolExecuteFunction<INPUT, OUTPUT>;\n    outputSchema?: FlexibleSchema<OUTPUT>;\n    needsApproval?: Tool<INPUT, OUTPUT>['needsApproval'];\n    toModelOutput?: Tool<INPUT, OUTPUT>['toModelOutput'];\n    onInputStart?: Tool<INPUT, OUTPUT>['onInputStart'];\n    onInputDelta?: Tool<INPUT, OUTPUT>['onInputDelta'];\n    onInputAvailable?: Tool<INPUT, OUTPUT>['onInputAvailable'];\n  }): Tool<INPUT, OUTPUT> =>\n    tool({\n      type: 'provider',\n      id,\n      args,\n      inputSchema,\n      outputSchema,\n      execute,\n      needsApproval,\n      toModelOutput,\n      onInputStart,\n      onInputDelta,\n      onInputAvailable,\n    });\n}\n\nexport type ProviderToolFactoryWithOutputSchema<\n  INPUT,\n  OUTPUT,\n  ARGS extends object,\n> = (\n  options: ARGS & {\n    execute?: ToolExecuteFunction<INPUT, OUTPUT>;\n    needsApproval?: Tool<INPUT, OUTPUT>['needsApproval'];\n    toModelOutput?: Tool<INPUT, OUTPUT>['toModelOutput'];\n    onInputStart?: Tool<INPUT, OUTPUT>['onInputStart'];\n    onInputDelta?: Tool<INPUT, OUTPUT>['onInputDelta'];\n    onInputAvailable?: Tool<INPUT, OUTPUT>['onInputAvailable'];\n  },\n) => Tool<INPUT, OUTPUT>;\n\nexport function createProviderToolFactoryWithOutputSchema<\n  INPUT,\n  OUTPUT,\n  ARGS extends object,\n>({\n  id,\n  inputSchema,\n  outputSchema,\n  supportsDeferredResults,\n}: {\n  id: `${string}.${string}`;\n  inputSchema: FlexibleSchema<INPUT>;\n  outputSchema: FlexibleSchema<OUTPUT>;\n  /**\n   * Whether this provider-executed tool supports deferred results.\n   *\n   * When true, the tool result may not be returned in the same turn as the\n   * tool call (e.g., when using programmatic tool calling where a server tool\n   * triggers a client-executed tool, and the server tool's result is deferred\n   * until the client tool is resolved).\n   *\n   * @default false\n   */\n  supportsDeferredResults?: boolean;\n}): ProviderToolFactoryWithOutputSchema<INPUT, OUTPUT, ARGS> {\n  return ({\n    execute,\n    needsApproval,\n    toModelOutput,\n    onInputStart,\n    onInputDelta,\n    onInputAvailable,\n    ...args\n  }: ARGS & {\n    execute?: ToolExecuteFunction<INPUT, OUTPUT>;\n    needsApproval?: Tool<INPUT, OUTPUT>['needsApproval'];\n    toModelOutput?: Tool<INPUT, OUTPUT>['toModelOutput'];\n    onInputStart?: Tool<INPUT, OUTPUT>['onInputStart'];\n    onInputDelta?: Tool<INPUT, OUTPUT>['onInputDelta'];\n    onInputAvailable?: Tool<INPUT, OUTPUT>['onInputAvailable'];\n  }): Tool<INPUT, OUTPUT> =>\n    tool({\n      type: 'provider',\n      id,\n      args,\n      inputSchema,\n      outputSchema,\n      execute,\n      needsApproval,\n      toModelOutput,\n      onInputStart,\n      onInputDelta,\n      onInputAvailable,\n      supportsDeferredResults,\n    });\n}\n","/**\n * Removes entries from a record where the value is null or undefined.\n * @param record - The input object whose entries may be null or undefined.\n * @returns A new object containing only entries with non-null and non-undefined values.\n */\nexport function removeUndefinedEntries<T>(\n  record: Record<string, T | undefined>,\n): Record<string, T> {\n  return Object.fromEntries(\n    Object.entries(record).filter(([_key, value]) => value != null),\n  ) as Record<string, T>;\n}\n","import { MaybePromiseLike } from './maybe-promise-like';\n\nexport type Resolvable<T> = MaybePromiseLike<T> | (() => MaybePromiseLike<T>);\n\n/**\n * Resolves a value that could be a raw value, a Promise, a function returning a value,\n * or a function returning a Promise.\n */\nexport async function resolve<T>(value: Resolvable<T>): Promise<T> {\n  // If it's a function, call it to get the value/promise\n  if (typeof value === 'function') {\n    value = (value as Function)();\n  }\n\n  // Otherwise just resolve whatever we got (value or promise)\n  return Promise.resolve(value as T);\n}\n","import { APICallError, EmptyResponseBodyError } from '@ai-sdk/provider';\nimport { ZodType } from 'zod/v4';\nimport { extractResponseHeaders } from './extract-response-headers';\nimport { parseJSON, ParseResult, safeParseJSON } from './parse-json';\nimport { parseJsonEventStream } from './parse-json-event-stream';\nimport { FlexibleSchema } from './schema';\n\nexport type ResponseHandler<RETURN_TYPE> = (options: {\n  url: string;\n  requestBodyValues: unknown;\n  response: Response;\n}) => PromiseLike<{\n  value: RETURN_TYPE;\n  rawValue?: unknown;\n  responseHeaders?: Record<string, string>;\n}>;\n\nexport const createJsonErrorResponseHandler =\n  <T>({\n    errorSchema,\n    errorToMessage,\n    isRetryable,\n  }: {\n    errorSchema: FlexibleSchema<T>;\n    errorToMessage: (error: T) => string;\n    isRetryable?: (response: Response, error?: T) => boolean;\n  }): ResponseHandler<APICallError> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseBody = await response.text();\n    const responseHeaders = extractResponseHeaders(response);\n\n    // Some providers return an empty response body for some errors:\n    if (responseBody.trim() === '') {\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: response.statusText,\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          isRetryable: isRetryable?.(response),\n        }),\n      };\n    }\n\n    // resilient parsing in case the response is not JSON or does not match the schema:\n    try {\n      const parsedError = await parseJSON({\n        text: responseBody,\n        schema: errorSchema,\n      });\n\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: errorToMessage(parsedError),\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          data: parsedError,\n          isRetryable: isRetryable?.(response, parsedError),\n        }),\n      };\n    } catch (parseError) {\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: response.statusText,\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          isRetryable: isRetryable?.(response),\n        }),\n      };\n    }\n  };\n\nexport const createEventSourceResponseHandler =\n  <T>(\n    chunkSchema: FlexibleSchema<T>,\n  ): ResponseHandler<ReadableStream<ParseResult<T>>> =>\n  async ({ response }: { response: Response }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (response.body == null) {\n      throw new EmptyResponseBodyError({});\n    }\n\n    return {\n      responseHeaders,\n      value: parseJsonEventStream({\n        stream: response.body,\n        schema: chunkSchema,\n      }),\n    };\n  };\n\nexport const createJsonResponseHandler =\n  <T>(responseSchema: FlexibleSchema<T>): ResponseHandler<T> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseBody = await response.text();\n\n    const parsedResult = await safeParseJSON({\n      text: responseBody,\n      schema: responseSchema,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!parsedResult.success) {\n      throw new APICallError({\n        message: 'Invalid JSON response',\n        cause: parsedResult.error,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        url,\n        requestBodyValues,\n      });\n    }\n\n    return {\n      responseHeaders,\n      value: parsedResult.value,\n      rawValue: parsedResult.rawValue,\n    };\n  };\n\nexport const createBinaryResponseHandler =\n  (): ResponseHandler<Uint8Array> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.body) {\n      throw new APICallError({\n        message: 'Response body is empty',\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody: undefined,\n      });\n    }\n\n    try {\n      const buffer = await response.arrayBuffer();\n      return {\n        responseHeaders,\n        value: new Uint8Array(buffer),\n      };\n    } catch (error) {\n      throw new APICallError({\n        message: 'Failed to read response as array buffer',\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody: undefined,\n        cause: error,\n      });\n    }\n  };\n\nexport const createStatusCodeErrorResponseHandler =\n  (): ResponseHandler<APICallError> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseHeaders = extractResponseHeaders(response);\n    const responseBody = await response.text();\n\n    return {\n      responseHeaders,\n      value: new APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues: requestBodyValues as Record<string, unknown>,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n      }),\n    };\n  };\n","export function withoutTrailingSlash(url: string | undefined) {\n  return url?.replace(/\\/$/, '');\n}\n","export function isAsyncIterable<T = any>(obj: any): obj is AsyncIterable<T> {\n  return obj != null && typeof obj[Symbol.asyncIterator] === 'function';\n}\n","import { isAsyncIterable } from '../is-async-iterable';\nimport { ToolExecutionOptions, ToolExecuteFunction } from './tool';\n\nexport async function* executeTool<INPUT, OUTPUT>({\n  execute,\n  input,\n  options,\n}: {\n  execute: ToolExecuteFunction<INPUT, OUTPUT>;\n  input: INPUT;\n  options: ToolExecutionOptions;\n}): AsyncGenerator<\n  { type: 'preliminary'; output: OUTPUT } | { type: 'final'; output: OUTPUT }\n> {\n  const result = execute(input, options);\n\n  if (isAsyncIterable(result)) {\n    let lastOutput: OUTPUT | undefined;\n    for await (const output of result) {\n      lastOutput = output;\n      yield { type: 'preliminary', output };\n    }\n    yield { type: 'final', output: lastOutput! };\n  } else {\n    yield { type: 'final', output: await result };\n  }\n}\n","export * from './combine-headers';\nexport { convertAsyncIteratorToReadableStream } from './convert-async-iterator-to-readable-stream';\nexport {\n  createToolNameMapping,\n  type ToolNameMapping,\n} from './create-tool-name-mapping';\nexport * from './delay';\nexport { DelayedPromise } from './delayed-promise';\nexport * from './extract-response-headers';\nexport { convertImageModelFileToDataUri } from './convert-image-model-file-to-data-uri';\nexport { convertToFormData } from './convert-to-form-data';\nexport { downloadBlob } from './download-blob';\nexport { DownloadError } from './download-error';\nexport * from './fetch-function';\nexport { createIdGenerator, generateId, type IdGenerator } from './generate-id';\nexport * from './get-error-message';\nexport * from './get-from-api';\nexport { getRuntimeEnvironmentUserAgent } from './get-runtime-environment-user-agent';\nexport { injectJsonInstructionIntoMessages } from './inject-json-instruction';\nexport * from './is-abort-error';\nexport { isNonNullable } from './is-non-nullable';\nexport { isUrlSupported } from './is-url-supported';\nexport * from './load-api-key';\nexport { loadOptionalSetting } from './load-optional-setting';\nexport { loadSetting } from './load-setting';\nexport { type MaybePromiseLike } from './maybe-promise-like';\nexport { mediaTypeToExtension } from './media-type-to-extension';\nexport { normalizeHeaders } from './normalize-headers';\nexport * from './parse-json';\nexport { parseJsonEventStream } from './parse-json-event-stream';\nexport { parseProviderOptions } from './parse-provider-options';\nexport * from './post-to-api';\nexport {\n  createProviderToolFactory,\n  createProviderToolFactoryWithOutputSchema,\n  type ProviderToolFactory,\n  type ProviderToolFactoryWithOutputSchema,\n} from './provider-tool-factory';\nexport * from './remove-undefined-entries';\nexport * from './resolve';\nexport * from './response-handler';\nexport {\n  asSchema,\n  jsonSchema,\n  lazySchema,\n  zodSchema,\n  type FlexibleSchema,\n  type InferSchema,\n  type LazySchema,\n  type Schema,\n  type ValidationResult,\n} from './schema';\nexport * from './uint8-utils';\nexport * from './validate-types';\nexport { VERSION } from './version';\nexport { withUserAgentSuffix } from './with-user-agent-suffix';\nexport * from './without-trailing-slash';\n\n// folder re-exports\nexport * from './types';\n\n// external re-exports\nexport * from '@standard-schema/spec';\nexport {\n  EventSourceParserStream,\n  type EventSourceMessage,\n} from 'eventsource-parser/stream';\n","/**\n * The type of error that occurred.\n * @public\n */\nexport type ErrorType = 'invalid-retry' | 'unknown-field'\n\n/**\n * Error thrown when encountering an issue during parsing.\n *\n * @public\n */\nexport class ParseError extends Error {\n  /**\n   * The type of error that occurred.\n   */\n  type: ErrorType\n\n  /**\n   * In the case of an unknown field encountered in the stream, this will be the field name.\n   */\n  field?: string | undefined\n\n  /**\n   * In the case of an unknown field encountered in the stream, this will be the value of the field.\n   */\n  value?: string | undefined\n\n  /**\n   * The line that caused the error, if available.\n   */\n  line?: string | undefined\n\n  constructor(\n    message: string,\n    options: {type: ErrorType; field?: string; value?: string; line?: string},\n  ) {\n    super(message)\n    this.name = 'ParseError'\n    this.type = options.type\n    this.field = options.field\n    this.value = options.value\n    this.line = options.line\n  }\n}\n","/**\n * EventSource/Server-Sent Events parser\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n */\nimport {ParseError} from './errors.ts'\nimport type {EventSourceParser, ParserCallbacks} from './types.ts'\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction noop(_arg: unknown) {\n  // intentional noop\n}\n\n/**\n * Creates a new EventSource parser.\n *\n * @param callbacks - Callbacks to invoke on different parsing events:\n *   - `onEvent` when a new event is parsed\n *   - `onError` when an error occurs\n *   - `onRetry` when a new reconnection interval has been sent from the server\n *   - `onComment` when a comment is encountered in the stream\n *\n * @returns A new EventSource parser, with `parse` and `reset` methods.\n * @public\n */\nexport function createParser(callbacks: ParserCallbacks): EventSourceParser {\n  if (typeof callbacks === 'function') {\n    throw new TypeError(\n      '`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?',\n    )\n  }\n\n  const {onEvent = noop, onError = noop, onRetry = noop, onComment} = callbacks\n\n  let incompleteLine = ''\n\n  let isFirstChunk = true\n  let id: string | undefined\n  let data = ''\n  let eventType = ''\n\n  function feed(newChunk: string) {\n    // Strip any UTF8 byte order mark (BOM) at the start of the stream\n    const chunk = isFirstChunk ? newChunk.replace(/^\\xEF\\xBB\\xBF/, '') : newChunk\n\n    // If there was a previous incomplete line, append it to the new chunk,\n    // so we may process it together as a new (hopefully complete) chunk.\n    const [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`)\n\n    for (const line of complete) {\n      parseLine(line)\n    }\n\n    incompleteLine = incomplete\n    isFirstChunk = false\n  }\n\n  function parseLine(line: string) {\n    // If the line is empty (a blank line), dispatch the event\n    if (line === '') {\n      dispatchEvent()\n      return\n    }\n\n    // If the line starts with a U+003A COLON character (:), ignore the line.\n    if (line.startsWith(':')) {\n      if (onComment) {\n        onComment(line.slice(line.startsWith(': ') ? 2 : 1))\n      }\n      return\n    }\n\n    // If the line contains a U+003A COLON character (:)\n    const fieldSeparatorIndex = line.indexOf(':')\n    if (fieldSeparatorIndex !== -1) {\n      // Collect the characters on the line before the first U+003A COLON character (:),\n      // and let `field` be that string.\n      const field = line.slice(0, fieldSeparatorIndex)\n\n      // Collect the characters on the line after the first U+003A COLON character (:),\n      // and let `value` be that string. If value starts with a U+0020 SPACE character,\n      // remove it from value.\n      const offset = line[fieldSeparatorIndex + 1] === ' ' ? 2 : 1\n      const value = line.slice(fieldSeparatorIndex + offset)\n\n      processField(field, value, line)\n      return\n    }\n\n    // Otherwise, the string is not empty but does not contain a U+003A COLON character (:)\n    // Process the field using the whole line as the field name, and an empty string as the field value.\n    //  This is according to spec. That means that a line that has the value `data` will result in\n    // a newline being added to the current `data` buffer, for instance.\n    processField(line, '', line)\n  }\n\n  function processField(field: string, value: string, line: string) {\n    // Field names must be compared literally, with no case folding performed.\n    switch (field) {\n      case 'event':\n        // Set the `event type` buffer to field value\n        eventType = value\n        break\n      case 'data':\n        // Append the field value to the `data` buffer, then append a single U+000A LINE FEED(LF)\n        // character to the `data` buffer.\n        data = `${data}${value}\\n`\n        break\n      case 'id':\n        // If the field value does not contain U+0000 NULL, then set the `ID` buffer to\n        // the field value. Otherwise, ignore the field.\n        id = value.includes('\\0') ? undefined : value\n        break\n      case 'retry':\n        // If the field value consists of only ASCII digits, then interpret the field value as an\n        // integer in base ten, and set the event stream's reconnection time to that integer.\n        // Otherwise, ignore the field.\n        if (/^\\d+$/.test(value)) {\n          onRetry(parseInt(value, 10))\n        } else {\n          onError(\n            new ParseError(`Invalid \\`retry\\` value: \"${value}\"`, {\n              type: 'invalid-retry',\n              value,\n              line,\n            }),\n          )\n        }\n        break\n      default:\n        // Otherwise, the field is ignored.\n        onError(\n          new ParseError(\n            `Unknown field \"${field.length > 20 ? `${field.slice(0, 20)}` : field}\"`,\n            {type: 'unknown-field', field, value, line},\n          ),\n        )\n        break\n    }\n  }\n\n  function dispatchEvent() {\n    const shouldDispatch = data.length > 0\n    if (shouldDispatch) {\n      onEvent({\n        id,\n        event: eventType || undefined,\n        // If the data buffer's last character is a U+000A LINE FEED (LF) character,\n        // then remove the last character from the data buffer.\n        data: data.endsWith('\\n') ? data.slice(0, -1) : data,\n      })\n    }\n\n    // Reset for the next event\n    id = undefined\n    data = ''\n    eventType = ''\n  }\n\n  function reset(options: {consume?: boolean} = {}) {\n    if (incompleteLine && options.consume) {\n      parseLine(incompleteLine)\n    }\n\n    isFirstChunk = true\n    id = undefined\n    data = ''\n    eventType = ''\n    incompleteLine = ''\n  }\n\n  return {feed, reset}\n}\n\n/**\n * For the given `chunk`, split it into lines according to spec, and return any remaining incomplete line.\n *\n * @param chunk - The chunk to split into lines\n * @returns A tuple containing an array of complete lines, and any remaining incomplete line\n * @internal\n */\nfunction splitLines(chunk: string): [complete: Array<string>, incomplete: string] {\n  /**\n   * According to the spec, a line is terminated by either:\n   * - U+000D CARRIAGE RETURN U+000A LINE FEED (CRLF) character pair\n   * - a single U+000A LINE FEED(LF) character not preceded by a U+000D CARRIAGE RETURN(CR) character\n   * - a single U+000D CARRIAGE RETURN(CR) character not followed by a U+000A LINE FEED(LF) character\n   */\n  const lines: Array<string> = []\n  let incompleteLine = ''\n  let searchIndex = 0\n\n  while (searchIndex < chunk.length) {\n    // Find next line terminator\n    const crIndex = chunk.indexOf('\\r', searchIndex)\n    const lfIndex = chunk.indexOf('\\n', searchIndex)\n\n    // Determine line end\n    let lineEnd = -1\n    if (crIndex !== -1 && lfIndex !== -1) {\n      // CRLF case\n      lineEnd = Math.min(crIndex, lfIndex)\n    } else if (crIndex !== -1) {\n      // CR at the end of a chunk might be part of a CRLF sequence that spans chunks,\n      // so we shouldn't treat it as a line terminator (yet)\n      if (crIndex === chunk.length - 1) {\n        lineEnd = -1\n      } else {\n        lineEnd = crIndex\n      }\n    } else if (lfIndex !== -1) {\n      lineEnd = lfIndex\n    }\n\n    // Extract line if terminator found\n    if (lineEnd === -1) {\n      // No terminator found, rest is incomplete\n      incompleteLine = chunk.slice(searchIndex)\n      break\n    } else {\n      const line = chunk.slice(searchIndex, lineEnd)\n      lines.push(line)\n\n      // Move past line terminator\n      searchIndex = lineEnd + 1\n      if (chunk[searchIndex - 1] === '\\r' && chunk[searchIndex] === '\\n') {\n        searchIndex++\n      }\n    }\n  }\n\n  return [lines, incompleteLine]\n}\n","import {createParser} from './parse.ts'\nimport type {EventSourceMessage, EventSourceParser} from './types.ts'\n\n/**\n * Options for the EventSourceParserStream.\n *\n * @public\n */\nexport interface StreamOptions {\n  /**\n   * Behavior when a parsing error occurs.\n   *\n   * - A custom function can be provided to handle the error.\n   * - `'terminate'` will error the stream and stop parsing.\n   * - Any other value will ignore the error and continue parsing.\n   *\n   * @defaultValue `undefined`\n   */\n  onError?: ('terminate' | ((error: Error) => void)) | undefined\n\n  /**\n   * Callback for when a reconnection interval is sent from the server.\n   *\n   * @param retry - The number of milliseconds to wait before reconnecting.\n   */\n  onRetry?: ((retry: number) => void) | undefined\n\n  /**\n   * Callback for when a comment is encountered in the stream.\n   *\n   * @param comment - The comment encountered in the stream.\n   */\n  onComment?: ((comment: string) => void) | undefined\n}\n\n/**\n * A TransformStream that ingests a stream of strings and produces a stream of `EventSourceMessage`.\n *\n * @example Basic usage\n * ```\n * const eventStream =\n *   response.body\n *     .pipeThrough(new TextDecoderStream())\n *     .pipeThrough(new EventSourceParserStream())\n * ```\n *\n * @example Terminate stream on parsing errors\n * ```\n * const eventStream =\n *  response.body\n *   .pipeThrough(new TextDecoderStream())\n *   .pipeThrough(new EventSourceParserStream({terminateOnError: true}))\n * ```\n *\n * @public\n */\nexport class EventSourceParserStream extends TransformStream<string, EventSourceMessage> {\n  constructor({onError, onRetry, onComment}: StreamOptions = {}) {\n    let parser!: EventSourceParser\n\n    super({\n      start(controller) {\n        parser = createParser({\n          onEvent: (event) => {\n            controller.enqueue(event)\n          },\n          onError(error) {\n            if (onError === 'terminate') {\n              controller.error(error)\n            } else if (typeof onError === 'function') {\n              onError(error)\n            }\n\n            // Ignore by default\n          },\n          onRetry,\n          onComment,\n        })\n      },\n      transform(chunk) {\n        parser.feed(chunk)\n      },\n    })\n  }\n}\n\nexport {type ErrorType, ParseError} from './errors.ts'\nexport type {EventSourceMessage} from './types.ts'\n","import { z } from 'zod/v4';\nimport { isDefinedOrNotNull } from '../utils/type-guards';\nimport { ReasoningFormat } from './format';\n\nexport enum ReasoningDetailType {\n  Summary = 'reasoning.summary',\n  Encrypted = 'reasoning.encrypted',\n  Text = 'reasoning.text',\n}\n\nexport const CommonReasoningDetailSchema = z\n  .object({\n    id: z.string().nullish(),\n    format: z.enum(ReasoningFormat).nullish(),\n    index: z.number().optional(),\n  })\n  .loose();\n\nexport const ReasoningDetailSummarySchema = z\n  .object({\n    type: z.literal(ReasoningDetailType.Summary),\n    summary: z.string(),\n  })\n  .extend(CommonReasoningDetailSchema.shape);\nexport type ReasoningDetailSummary = z.infer<\n  typeof ReasoningDetailSummarySchema\n>;\n\nexport const ReasoningDetailEncryptedSchema = z\n  .object({\n    type: z.literal(ReasoningDetailType.Encrypted),\n    data: z.string(),\n  })\n  .extend(CommonReasoningDetailSchema.shape);\n\nexport type ReasoningDetailEncrypted = z.infer<\n  typeof ReasoningDetailEncryptedSchema\n>;\n\nexport const ReasoningDetailTextSchema = z\n  .object({\n    type: z.literal(ReasoningDetailType.Text),\n    text: z.string().nullish(),\n    signature: z.string().nullish(),\n  })\n  .extend(CommonReasoningDetailSchema.shape);\n\nexport type ReasoningDetailText = z.infer<typeof ReasoningDetailTextSchema>;\n\nexport const ReasoningDetailUnionSchema = z.union([\n  ReasoningDetailSummarySchema,\n  ReasoningDetailEncryptedSchema,\n  ReasoningDetailTextSchema,\n]);\n\nexport type ReasoningDetailUnion = z.infer<typeof ReasoningDetailUnionSchema>;\n\nconst ReasoningDetailsWithUnknownSchema = z.union([\n  ReasoningDetailUnionSchema,\n  z.unknown().transform(() => null),\n]);\n\nexport const ReasoningDetailArraySchema = z\n  .array(ReasoningDetailsWithUnknownSchema)\n  .transform((d) => d.filter((d): d is ReasoningDetailUnion => !!d));\n\nexport const OutputUnionToReasoningDetailsSchema = z.union([\n  z\n    .object({\n      delta: z.object({\n        reasoning_details: z.array(ReasoningDetailsWithUnknownSchema),\n      }),\n    })\n    .transform((data) =>\n      data.delta.reasoning_details.filter(isDefinedOrNotNull),\n    ),\n  z\n    .object({\n      message: z.object({\n        reasoning_details: z.array(ReasoningDetailsWithUnknownSchema),\n      }),\n    })\n    .transform((data) =>\n      data.message.reasoning_details.filter(isDefinedOrNotNull),\n    ),\n  z\n    .object({\n      text: z.string(),\n      reasoning_details: z.array(ReasoningDetailsWithUnknownSchema),\n    })\n    .transform((data) => data.reasoning_details.filter(isDefinedOrNotNull)),\n]);\n","/**\n * Type guard to check if a value is defined and not null\n */\nexport function isDefinedOrNotNull<T>(value: T | null | undefined): value is T {\n  return value !== null && value !== undefined;\n}\n","export enum ReasoningFormat {\n  Unknown = 'unknown',\n  OpenAIResponsesV1 = 'openai-responses-v1',\n  XAIResponsesV1 = 'xai-responses-v1',\n  AnthropicClaudeV1 = 'anthropic-claude-v1',\n  GoogleGeminiV1 = 'google-gemini-v1',\n}\n\n// Anthropic Claude was the first reasoning that we're\n// passing back and forth\nexport const DEFAULT_REASONING_FORMAT = ReasoningFormat.AnthropicClaudeV1;\n","import type { ChatErrorError } from '../types/openrouter-api-types';\n\nimport { createJsonErrorResponseHandler } from '@ai-sdk/provider-utils';\nimport { z } from 'zod/v4';\n\nexport const OpenRouterErrorResponseSchema = z\n  .object({\n    error: z\n      .object({\n        code: z\n          .union([z.string(), z.number()])\n          .nullable()\n          .optional()\n          .default(null),\n        message: z.string(),\n        type: z.string().nullable().optional().default(null),\n        param: z.any().nullable().optional().default(null),\n      })\n      .passthrough() satisfies z.ZodType<\n      Omit<ChatErrorError, 'code'> & { code: string | number | null }\n    >,\n  })\n  .passthrough();\n\nexport type OpenRouterErrorData = z.infer<typeof OpenRouterErrorResponseSchema>;\n\nexport const openrouterFailedResponseHandler = createJsonErrorResponseHandler({\n  errorSchema: OpenRouterErrorResponseSchema,\n  errorToMessage: (data: OpenRouterErrorData) => data.error.message,\n});\n","import { z } from 'zod/v4';\nimport { ReasoningDetailUnionSchema } from './reasoning-details';\n\n/**\n * Schema for file annotations from FileParserPlugin\n */\nexport const FileAnnotationSchema = z\n  .object({\n    type: z.literal('file'),\n    file: z\n      .object({\n        hash: z.string(),\n        name: z.string(),\n        content: z\n          .array(\n            z\n              .object({\n                type: z.string(),\n                text: z.string().optional(),\n              })\n              .catchall(z.any()),\n          )\n          .optional(),\n      })\n      .catchall(z.any()),\n  })\n  .catchall(z.any());\n\nexport type FileAnnotation = z.infer<typeof FileAnnotationSchema>;\n\n/**\n * Schema for OpenRouter provider metadata attached to responses\n */\nexport const OpenRouterProviderMetadataSchema = z\n  .object({\n    provider: z.string(),\n    reasoning_details: z.array(ReasoningDetailUnionSchema).optional(),\n    annotations: z.array(FileAnnotationSchema).optional(),\n    usage: z\n      .object({\n        promptTokens: z.number(),\n        promptTokensDetails: z\n          .object({\n            cachedTokens: z.number(),\n          })\n          .catchall(z.any())\n          .optional(),\n        completionTokens: z.number(),\n        completionTokensDetails: z\n          .object({\n            reasoningTokens: z.number(),\n          })\n          .catchall(z.any())\n          .optional(),\n        totalTokens: z.number(),\n        cost: z.number().optional(),\n        costDetails: z\n          .object({\n            upstreamInferenceCost: z.number(),\n          })\n          .catchall(z.any())\n          .optional(),\n      })\n      .catchall(z.any()),\n  })\n  .catchall(z.any());\n\nexport type OpenRouterProviderMetadata = z.infer<\n  typeof OpenRouterProviderMetadataSchema\n>;\n\n/**\n * Schema for parsing provider options that may contain reasoning_details and annotations\n */\nexport const OpenRouterProviderOptionsSchema = z\n  .object({\n    openrouter: z\n      .object({\n        reasoning_details: z.array(ReasoningDetailUnionSchema).optional(),\n        annotations: z.array(FileAnnotationSchema).optional(),\n      })\n      .optional(),\n  })\n  .optional();\n","import type { LanguageModelV3FinishReason } from '@ai-sdk/provider';\n\ntype UnifiedFinishReason =\n  | 'stop'\n  | 'length'\n  | 'content-filter'\n  | 'tool-calls'\n  | 'error'\n  | 'other';\n\nfunction mapToUnified(\n  finishReason: string | null | undefined,\n): UnifiedFinishReason {\n  switch (finishReason) {\n    case 'stop':\n      return 'stop';\n    case 'length':\n      return 'length';\n    case 'content_filter':\n      return 'content-filter';\n    case 'function_call':\n    case 'tool_calls':\n      return 'tool-calls';\n    default:\n      return 'other';\n  }\n}\n\nexport function mapOpenRouterFinishReason(\n  finishReason: string | null | undefined,\n): LanguageModelV3FinishReason {\n  return {\n    unified: mapToUnified(finishReason),\n    raw: finishReason ?? undefined,\n  };\n}\n\nexport function createFinishReason(\n  unified: UnifiedFinishReason,\n  raw?: string,\n): LanguageModelV3FinishReason {\n  return { unified, raw };\n}\n","import type { ReasoningDetailUnion } from '../schemas/reasoning-details';\n\nimport { ReasoningDetailType } from '../schemas/reasoning-details';\n\n/**\n * Tracks ReasoningDetailUnion entries and deduplicates them based\n * on a derived canonical key.\n *\n * This is used when converting messages to ensure the API request only\n * contains unique reasoning details, preventing \"Duplicate item found with id\"\n * errors in multi-turn conversations.\n *\n * The canonical key logic matches the OpenRouter API's deduplication exactly\n * (see openrouter-web/packages/llm-interfaces/reasonings/duplicate-tracker.ts):\n * - Summary: key = summary field\n * - Encrypted: key = id field (if truthy) or data field\n * - Text: key = text field (if truthy) or signature field (if truthy)\n */\nexport class ReasoningDetailsDuplicateTracker {\n  readonly #seenKeys = new Set<string>();\n\n  /**\n   * Attempts to track a detail.\n   * Returns true if this is a NEW detail (not seen before and has valid key),\n   * false if it was skipped (no valid key) or already seen (duplicate).\n   */\n  upsert(detail: ReasoningDetailUnion): boolean {\n    const key = this.getCanonicalKey(detail);\n    if (key === null) {\n      return false;\n    }\n\n    if (this.#seenKeys.has(key)) {\n      return false;\n    }\n\n    this.#seenKeys.add(key);\n    return true;\n  }\n\n  private getCanonicalKey(detail: ReasoningDetailUnion): string | null {\n    // This logic matches the OpenRouter API's deduplication exactly.\n    // See: openrouter-web/packages/llm-interfaces/reasonings/duplicate-tracker.ts\n    switch (detail.type) {\n      case ReasoningDetailType.Summary:\n        return detail.summary;\n\n      case ReasoningDetailType.Encrypted:\n        if (detail.id) {\n          return detail.id;\n        }\n        return detail.data;\n\n      case ReasoningDetailType.Text: {\n        if (detail.text) {\n          return detail.text;\n        }\n        if (detail.signature) {\n          return detail.signature;\n        }\n        return null;\n      }\n\n      default: {\n        // Handle unknown types gracefully\n        return null;\n      }\n    }\n  }\n}\n","import type { FileAnnotation } from '@/src/schemas/provider-metadata';\nimport type { ReasoningDetailUnion } from '@/src/schemas/reasoning-details';\n\n// Type for OpenRouter Cache Control following Anthropic's pattern\nexport type OpenRouterCacheControl = { type: 'ephemeral' };\n\nexport type OpenRouterChatCompletionsInput = Array<ChatCompletionMessageParam>;\n\nexport type ChatCompletionMessageParam =\n  | ChatCompletionSystemMessageParam\n  | ChatCompletionUserMessageParam\n  | ChatCompletionAssistantMessageParam\n  | ChatCompletionToolMessageParam;\n\nexport interface ChatCompletionSystemMessageParam {\n  role: 'system';\n  content: string;\n  cache_control?: OpenRouterCacheControl;\n}\n\nexport interface ChatCompletionUserMessageParam {\n  role: 'user';\n  content: string | Array<ChatCompletionContentPart>;\n  cache_control?: OpenRouterCacheControl;\n}\n\nexport type ChatCompletionContentPart =\n  | ChatCompletionContentPartText\n  | ChatCompletionContentPartImage\n  | ChatCompletionContentPartFile\n  | ChatCompletionContentPartInputAudio;\n\nexport interface ChatCompletionContentPartFile {\n  type: 'file';\n  file: {\n    filename?: string;\n    file_data?: string;\n    file_id?: string;\n  };\n  cache_control?: OpenRouterCacheControl;\n}\n\nexport interface ChatCompletionContentPartImage {\n  type: 'image_url';\n  image_url: {\n    url: string;\n  };\n  cache_control?: OpenRouterCacheControl;\n}\n\nexport interface ChatCompletionContentPartText {\n  type: 'text';\n  text: string;\n  reasoning?: string | null;\n  cache_control?: OpenRouterCacheControl;\n}\n\n/** https://openrouter.ai/docs/guides/overview/multimodal/audio */\nexport const OPENROUTER_AUDIO_FORMATS = [\n  'wav',\n  'mp3',\n  'aiff',\n  'aac',\n  'ogg',\n  'flac',\n  'm4a',\n  'pcm16',\n  'pcm24',\n] as const;\n\nexport type OpenRouterAudioFormat = (typeof OPENROUTER_AUDIO_FORMATS)[number];\n\nexport interface ChatCompletionContentPartInputAudio {\n  type: 'input_audio';\n  input_audio: {\n    data: string;\n    format: OpenRouterAudioFormat;\n  };\n  cache_control?: OpenRouterCacheControl;\n}\n\nexport interface ChatCompletionAssistantMessageParam {\n  role: 'assistant';\n  content?: string | null;\n  reasoning?: string | null;\n  reasoning_details?: ReasoningDetailUnion[];\n  annotations?: FileAnnotation[];\n  tool_calls?: Array<ChatCompletionMessageToolCall>;\n  cache_control?: OpenRouterCacheControl;\n}\n\nexport interface ChatCompletionMessageToolCall {\n  type: 'function';\n  id: string;\n  function: {\n    arguments: string;\n    name: string;\n  };\n}\n\nexport interface ChatCompletionToolMessageParam {\n  role: 'tool';\n  content: string;\n  tool_call_id: string;\n  cache_control?: OpenRouterCacheControl;\n}\n","export function isUrl({\n  url,\n  protocols,\n}: {\n  url: string | URL;\n  protocols: Set<`${string}:`>;\n}): boolean {\n  try {\n    const urlObj = new URL(url);\n    // Cast to the literal string due to Set inferred input type\n    return protocols.has(urlObj.protocol as `${string}:`);\n  } catch (_) {\n    return false;\n  }\n}\n","import type { LanguageModelV3FilePart } from '@ai-sdk/provider';\nimport type { OpenRouterAudioFormat } from '../types/openrouter-chat-completions-input';\n\nimport { convertUint8ArrayToBase64 } from '@ai-sdk/provider-utils';\nimport { OPENROUTER_AUDIO_FORMATS } from '../types/openrouter-chat-completions-input';\nimport { isUrl } from './is-url';\n\nexport function getFileUrl({\n  part,\n  defaultMediaType,\n}: {\n  part: LanguageModelV3FilePart;\n  defaultMediaType: string;\n}) {\n  if (part.data instanceof Uint8Array) {\n    const base64 = convertUint8ArrayToBase64(part.data);\n    return `data:${part.mediaType ?? defaultMediaType};base64,${base64}`;\n  }\n\n  const stringUrl = part.data.toString();\n\n  if (\n    isUrl({\n      url: stringUrl,\n      protocols: new Set(['http:', 'https:'] as const),\n    })\n  ) {\n    return stringUrl;\n  }\n\n  return stringUrl.startsWith('data:')\n    ? stringUrl\n    : `data:${part.mediaType ?? defaultMediaType};base64,${stringUrl}`;\n}\n\nexport function getMediaType(\n  dataUrl: string,\n  defaultMediaType: string,\n): string {\n  const match = dataUrl.match(/^data:([^;]+)/);\n  return match ? (match[1] ?? defaultMediaType) : defaultMediaType;\n}\n\nexport function getBase64FromDataUrl(dataUrl: string): string {\n  const match = dataUrl.match(/^data:[^;]*;base64,(.+)$/);\n  return match ? match[1]! : dataUrl;\n}\n\n/** MIME type to format mapping for normalization */\nexport const MIME_TO_FORMAT: Record<string, OpenRouterAudioFormat> = {\n  // MP3 variants\n  mpeg: 'mp3',\n  mp3: 'mp3',\n  // WAV variants\n  'x-wav': 'wav',\n  wave: 'wav',\n  wav: 'wav',\n  // OGG variants\n  ogg: 'ogg',\n  vorbis: 'ogg',\n  // AAC variants\n  aac: 'aac',\n  'x-aac': 'aac',\n  // M4A variants\n  m4a: 'm4a',\n  'x-m4a': 'm4a',\n  mp4: 'm4a',\n  // AIFF variants\n  aiff: 'aiff',\n  'x-aiff': 'aiff',\n  // FLAC\n  flac: 'flac',\n  'x-flac': 'flac',\n  // PCM variants\n  pcm16: 'pcm16',\n  pcm24: 'pcm24',\n};\n\n/**\n * Converts an audio file part to OpenRouter's input_audio data format.\n *\n * This function extracts base64-encoded audio data from a file part and\n * normalizes the format to one of the supported OpenRouter audio formats.\n *\n * @param part - The file part containing audio data. Must have a mediaType\n *   starting with \"audio/\" and contain either base64 data or a data URL.\n *\n * @returns An object with `data` (base64-encoded audio) and `format`\n *   suitable for use in OpenRouter's `input_audio` field.\n *\n * @throws {Error} When audio is provided as an HTTP/HTTPS URL. OpenRouter requires\n *   audio to be base64-encoded inline. The error message includes instructions for\n *   downloading and encoding the audio locally.\n *\n * @throws {Error} When the audio format is not supported.\n *\n * @example\n * ```ts\n * const audioData = getInputAudioData(filePart);\n * // Returns: { data: \"base64string...\", format: \"mp3\" }\n * ```\n */\nexport function getInputAudioData(part: LanguageModelV3FilePart): {\n  data: string;\n  format: OpenRouterAudioFormat;\n} {\n  const fileData = getFileUrl({\n    part,\n    defaultMediaType: 'audio/mpeg',\n  });\n\n  // OpenRouter's input_audio doesn't support URLs directly\n  if (\n    isUrl({\n      url: fileData,\n      protocols: new Set(['http:', 'https:'] as const),\n    })\n  ) {\n    throw new Error(\n      `Audio files cannot be provided as URLs.\\n\\n` +\n        `OpenRouter requires audio to be base64-encoded. Please:\\n` +\n        `1. Download the audio file locally\\n` +\n        `2. Read it as a Buffer or Uint8Array\\n` +\n        `3. Pass it as the data parameter\\n\\n` +\n        `The AI SDK will automatically handle base64 encoding.\\n\\n` +\n        `Learn more: https://openrouter.ai/docs/features/multimodal/audio`,\n    );\n  }\n\n  // Extract base64 data (handles both data URLs and raw base64)\n  const data = getBase64FromDataUrl(fileData);\n\n  // Map media type to format\n  const mediaType = part.mediaType || 'audio/mpeg';\n  const rawFormat = mediaType.replace('audio/', '');\n\n  // Normalize format names for OpenRouter using MIME type mapping\n  const format = MIME_TO_FORMAT[rawFormat];\n\n  if (format === undefined) {\n    const supportedList = OPENROUTER_AUDIO_FORMATS.join(', ');\n    throw new Error(\n      `Unsupported audio format: \"${mediaType}\"\\n\\n` +\n        `OpenRouter supports the following audio formats: ${supportedList}\\n\\n` +\n        `Learn more: https://openrouter.ai/docs/features/multimodal/audio`,\n    );\n  }\n\n  return { data, format };\n}\n","import type {\n  LanguageModelV3FilePart,\n  LanguageModelV3Prompt,\n  LanguageModelV3TextPart,\n  LanguageModelV3ToolResultPart,\n  SharedV3ProviderMetadata,\n} from '@ai-sdk/provider';\nimport type { ReasoningDetailUnion } from '../schemas/reasoning-details';\nimport type {\n  ChatCompletionContentPart,\n  OpenRouterChatCompletionsInput,\n} from '../types/openrouter-chat-completions-input';\n\nimport { OpenRouterProviderOptionsSchema } from '../schemas/provider-metadata';\nimport { ReasoningDetailsDuplicateTracker } from '../utils/reasoning-details-duplicate-tracker';\nimport { getFileUrl, getInputAudioData } from './file-url-utils';\nimport { isUrl } from './is-url';\n\n// Type for OpenRouter Cache Control following Anthropic's pattern\nexport type OpenRouterCacheControl = { type: 'ephemeral' };\n\nfunction getCacheControl(\n  providerMetadata: SharedV3ProviderMetadata | undefined,\n): OpenRouterCacheControl | undefined {\n  const anthropic = providerMetadata?.anthropic;\n  const openrouter = providerMetadata?.openrouter;\n\n  // Allow both cacheControl and cache_control:\n  return (openrouter?.cacheControl ??\n    openrouter?.cache_control ??\n    anthropic?.cacheControl ??\n    anthropic?.cache_control) as OpenRouterCacheControl | undefined;\n}\n\nexport function convertToOpenRouterChatMessages(\n  prompt: LanguageModelV3Prompt,\n): OpenRouterChatCompletionsInput {\n  const messages: OpenRouterChatCompletionsInput = [];\n\n  // Track reasoning_details across all messages in this conversion to prevent duplicates.\n  // This fixes issue #254 where the same reasoning ID appears in multiple\n  // assistant messages during multi-turn conversations, causing the API\n  // to reject the request with \"Duplicate item found with id\" error.\n  const reasoningDetailsTracker = new ReasoningDetailsDuplicateTracker();\n\n  for (const { role, content, providerOptions } of prompt) {\n    switch (role) {\n      case 'system': {\n        messages.push({\n          role: 'system',\n          content,\n          cache_control: getCacheControl(providerOptions),\n        });\n        break;\n      }\n\n      case 'user': {\n        if (content.length === 1 && content[0]?.type === 'text') {\n          const cacheControl =\n            getCacheControl(providerOptions) ??\n            getCacheControl(content[0].providerOptions);\n          const contentWithCacheControl: string | ChatCompletionContentPart[] =\n            cacheControl\n              ? [\n                  {\n                    type: 'text',\n                    text: content[0].text,\n                    cache_control: cacheControl,\n                  },\n                ]\n              : content[0].text;\n          messages.push({\n            role: 'user',\n            content: contentWithCacheControl,\n          });\n          break;\n        }\n\n        // Get message level cache control\n        const messageCacheControl = getCacheControl(providerOptions);\n\n        // Find the index of the last text part for applying message-level cache control\n        let lastTextPartIndex = -1;\n        for (let i = content.length - 1; i >= 0; i--) {\n          if (content[i]?.type === 'text') {\n            lastTextPartIndex = i;\n            break;\n          }\n        }\n\n        const contentParts: ChatCompletionContentPart[] = content.map(\n          (part: LanguageModelV3TextPart | LanguageModelV3FilePart, index) => {\n            const isLastTextPart =\n              part.type === 'text' && index === lastTextPartIndex;\n            const partCacheControl = getCacheControl(part.providerOptions);\n\n            const cacheControl =\n              part.type === 'text'\n                ? (partCacheControl ??\n                  (isLastTextPart ? messageCacheControl : undefined))\n                : partCacheControl;\n\n            switch (part.type) {\n              case 'text':\n                return {\n                  type: 'text' as const,\n                  text: part.text,\n                  ...(cacheControl && { cache_control: cacheControl }),\n                };\n              case 'file': {\n                if (part.mediaType?.startsWith('image/')) {\n                  const url = getFileUrl({\n                    part,\n                    defaultMediaType: 'image/jpeg',\n                  });\n                  return {\n                    type: 'image_url' as const,\n                    image_url: {\n                      url,\n                    },\n                    ...(cacheControl && { cache_control: cacheControl }),\n                  };\n                }\n\n                // Handle audio files for input_audio format\n                if (part.mediaType?.startsWith('audio/')) {\n                  return {\n                    type: 'input_audio' as const,\n                    input_audio: getInputAudioData(part),\n                    ...(cacheControl && { cache_control: cacheControl }),\n                  };\n                }\n\n                const fileName = String(\n                  part.providerOptions?.openrouter?.filename ??\n                    part.filename ??\n                    '',\n                );\n\n                const fileData = getFileUrl({\n                  part,\n                  defaultMediaType: 'application/pdf',\n                });\n\n                if (\n                  isUrl({\n                    url: fileData,\n                    protocols: new Set(['http:', 'https:'] as const),\n                  })\n                ) {\n                  return {\n                    type: 'file' as const,\n                    file: {\n                      filename: fileName,\n                      file_data: fileData,\n                    },\n                  } satisfies ChatCompletionContentPart;\n                }\n\n                return {\n                  type: 'file' as const,\n                  file: {\n                    filename: fileName,\n                    file_data: fileData,\n                  },\n                  ...(cacheControl && { cache_control: cacheControl }),\n                } satisfies ChatCompletionContentPart;\n              }\n              default: {\n                return {\n                  type: 'text' as const,\n                  text: '',\n                  ...(cacheControl && { cache_control: cacheControl }),\n                };\n              }\n            }\n          },\n        );\n\n        // For multi-part messages, don't add cache_control at the root level\n        messages.push({\n          role: 'user',\n          content: contentParts,\n        });\n\n        break;\n      }\n\n      case 'assistant': {\n        let text = '';\n        let reasoning = '';\n        const toolCalls: Array<{\n          id: string;\n          type: 'function';\n          function: { name: string; arguments: string };\n        }> = [];\n\n        for (const part of content) {\n          switch (part.type) {\n            case 'text': {\n              text += part.text;\n              break;\n            }\n            case 'tool-call': {\n              toolCalls.push({\n                id: part.toolCallId,\n                type: 'function',\n                function: {\n                  name: part.toolName,\n                  arguments: JSON.stringify(part.input),\n                },\n              });\n              break;\n            }\n            case 'reasoning': {\n              reasoning += part.text;\n              break;\n            }\n            case 'file':\n              break;\n            default: {\n              break;\n            }\n          }\n        }\n\n        // Check message-level providerOptions for preserved reasoning_details and annotations\n        const parsedProviderOptions =\n          OpenRouterProviderOptionsSchema.safeParse(providerOptions);\n        const messageReasoningDetails = parsedProviderOptions.success\n          ? parsedProviderOptions.data?.openrouter?.reasoning_details\n          : undefined;\n        const messageAnnotations = parsedProviderOptions.success\n          ? parsedProviderOptions.data?.openrouter?.annotations\n          : undefined;\n\n        // Use message-level reasoning_details if available, otherwise find from parts\n        // Priority: message-level > first tool call > first reasoning part\n        // This prevents duplicate thinking blocks when Claude makes parallel tool calls\n        const candidateReasoningDetails =\n          messageReasoningDetails &&\n          Array.isArray(messageReasoningDetails) &&\n          messageReasoningDetails.length > 0\n            ? messageReasoningDetails\n            : findFirstReasoningDetails(content);\n\n        // Deduplicate reasoning_details across all messages to prevent\n        // \"Duplicate item found with id\" errors in multi-turn conversations.\n        // upsert() returns true only for NEW details (not seen before and has valid key).\n        // Details without valid keys or duplicates are skipped.\n        let finalReasoningDetails: ReasoningDetailUnion[] | undefined;\n        if (candidateReasoningDetails && candidateReasoningDetails.length > 0) {\n          const uniqueDetails: ReasoningDetailUnion[] = [];\n          for (const detail of candidateReasoningDetails) {\n            if (reasoningDetailsTracker.upsert(detail)) {\n              uniqueDetails.push(detail);\n            }\n          }\n          finalReasoningDetails =\n            uniqueDetails.length > 0 ? uniqueDetails : undefined;\n        }\n\n        messages.push({\n          role: 'assistant',\n          content: text,\n          tool_calls: toolCalls.length > 0 ? toolCalls : undefined,\n          reasoning: reasoning || undefined,\n          reasoning_details: finalReasoningDetails,\n          annotations: messageAnnotations,\n          cache_control: getCacheControl(providerOptions),\n        });\n\n        break;\n      }\n\n      case 'tool': {\n        for (const toolResponse of content) {\n          // Skip tool approval responses - only process tool results\n          if (toolResponse.type === 'tool-approval-response') {\n            continue;\n          }\n          const content = getToolResultContent(toolResponse);\n\n          messages.push({\n            role: 'tool',\n            tool_call_id: toolResponse.toolCallId,\n            content,\n            cache_control:\n              getCacheControl(providerOptions) ??\n              getCacheControl(toolResponse.providerOptions),\n          });\n        }\n        break;\n      }\n\n      default: {\n        break;\n      }\n    }\n  }\n\n  return messages;\n}\n\nfunction getToolResultContent(input: LanguageModelV3ToolResultPart): string {\n  switch (input.output.type) {\n    case 'text':\n    case 'error-text':\n      return input.output.value;\n    case 'json':\n    case 'error-json':\n    case 'content':\n      return JSON.stringify(input.output.value);\n    case 'execution-denied':\n      return input.output.reason ?? 'Tool execution denied';\n  }\n}\n\n/**\n * Find the first reasoning_details from content parts.\n * Priority: tool calls (complete accumulated data) > reasoning parts (delta data)\n *\n * This prevents duplicate thinking blocks when Claude makes parallel tool calls,\n * as each tool call may have the same reasoning_details attached.\n */\nfunction findFirstReasoningDetails(\n  content: Array<{\n    type: string;\n    providerOptions?: Record<string, unknown>;\n  }>,\n): ReasoningDetailUnion[] | undefined {\n  // First, try tool calls - they have complete accumulated reasoning_details\n  for (const part of content) {\n    if (part.type === 'tool-call') {\n      const openrouter = part.providerOptions?.openrouter as\n        | Record<string, unknown>\n        | undefined;\n      const details = openrouter?.reasoning_details;\n      if (Array.isArray(details) && details.length > 0) {\n        return details as ReasoningDetailUnion[];\n      }\n    }\n  }\n\n  // Fall back to reasoning parts - they have delta reasoning_details\n  for (const part of content) {\n    if (part.type === 'reasoning') {\n      const parsed = OpenRouterProviderOptionsSchema.safeParse(\n        part.providerOptions,\n      );\n      if (\n        parsed.success &&\n        parsed.data?.openrouter?.reasoning_details &&\n        parsed.data.openrouter.reasoning_details.length > 0\n      ) {\n        return parsed.data.openrouter.reasoning_details;\n      }\n    }\n  }\n\n  return undefined;\n}\n","import type { LanguageModelV3ToolChoice } from '@ai-sdk/provider';\n\nimport { InvalidArgumentError } from '@ai-sdk/provider';\nimport { z } from 'zod/v4';\n\nconst ChatCompletionToolChoiceSchema = z.union([\n  z.literal('auto'),\n  z.literal('none'),\n  z.literal('required'),\n  z.object({\n    type: z.literal('function'),\n    function: z.object({\n      name: z.string(),\n    }),\n  }),\n]);\n\ntype ChatCompletionToolChoice = z.infer<typeof ChatCompletionToolChoiceSchema>;\n\nexport function getChatCompletionToolChoice(\n  toolChoice: LanguageModelV3ToolChoice,\n): ChatCompletionToolChoice {\n  switch (toolChoice.type) {\n    case 'auto':\n    case 'none':\n    case 'required':\n      return toolChoice.type;\n    case 'tool': {\n      return {\n        type: 'function',\n        function: { name: toolChoice.toolName },\n      };\n    }\n    default: {\n      toolChoice satisfies never;\n      throw new InvalidArgumentError({\n        argument: 'toolChoice',\n        message: `Invalid tool choice type: ${JSON.stringify(toolChoice)}`,\n      });\n    }\n  }\n}\n","import { z } from 'zod/v4';\nimport { OpenRouterErrorResponseSchema } from '../schemas/error-response';\nimport { ImageResponseArraySchema } from '../schemas/image';\nimport { ReasoningDetailArraySchema } from '../schemas/reasoning-details';\n\nconst OpenRouterChatCompletionBaseResponseSchema = z\n  .object({\n    id: z.string().optional(),\n    model: z.string().optional(),\n    provider: z.string().optional(),\n    usage: z\n      .object({\n        prompt_tokens: z.number(),\n        prompt_tokens_details: z\n          .object({\n            cached_tokens: z.number(),\n          })\n          .passthrough()\n          .nullish(),\n        completion_tokens: z.number(),\n        completion_tokens_details: z\n          .object({\n            reasoning_tokens: z.number(),\n          })\n          .passthrough()\n          .nullish(),\n        total_tokens: z.number(),\n        cost: z.number().optional(),\n        cost_details: z\n          .object({\n            upstream_inference_cost: z.number().nullish(),\n          })\n          .passthrough()\n          .nullish(),\n      })\n      .passthrough()\n      .nullish(),\n  })\n  .passthrough();\n// limited version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nexport const OpenRouterNonStreamChatCompletionResponseSchema = z.union([\n  // Success response with choices\n  OpenRouterChatCompletionBaseResponseSchema.extend({\n    choices: z.array(\n      z\n        .object({\n          message: z\n            .object({\n              role: z.literal('assistant'),\n              content: z.string().nullable().optional(),\n              reasoning: z.string().nullable().optional(),\n              reasoning_details: ReasoningDetailArraySchema.nullish(),\n              images: ImageResponseArraySchema.nullish(),\n\n              tool_calls: z\n                .array(\n                  z\n                    .object({\n                      id: z.string().optional().nullable(),\n                      type: z.literal('function'),\n                      function: z\n                        .object({\n                          name: z.string(),\n                          arguments: z.string().optional(),\n                        })\n                        .passthrough(),\n                    })\n                    .passthrough(),\n                )\n                .optional(),\n\n              annotations: z\n                .array(\n                  z.union([\n                    // URL citation from web search\n                    // title, start_index, end_index are optional as some upstream providers may omit them\n                    z\n                      .object({\n                        type: z.literal('url_citation'),\n                        url_citation: z\n                          .object({\n                            url: z.string(),\n                            title: z.string().optional(),\n                            start_index: z.number().optional(),\n                            end_index: z.number().optional(),\n                            content: z.string().optional(),\n                          })\n                          .passthrough(),\n                      })\n                      .passthrough(),\n                    // File annotation from FileParserPlugin (old format)\n                    z\n                      .object({\n                        type: z.literal('file_annotation'),\n                        file_annotation: z\n                          .object({\n                            file_id: z.string(),\n                            quote: z.string().optional(),\n                          })\n                          .passthrough(),\n                      })\n                      .passthrough(),\n                    // File annotation from FileParserPlugin (new format)\n                    z\n                      .object({\n                        type: z.literal('file'),\n                        file: z\n                          .object({\n                            hash: z.string(),\n                            name: z.string(),\n                            content: z\n                              .array(\n                                z\n                                  .object({\n                                    type: z.string(),\n                                    text: z.string().optional(),\n                                  })\n                                  .passthrough(),\n                              )\n                              .optional(),\n                          })\n                          .passthrough(),\n                      })\n                      .passthrough(),\n                  ]),\n                )\n                .nullish(),\n            })\n            .passthrough(),\n          index: z.number().nullish(),\n          logprobs: z\n            .object({\n              content: z\n                .array(\n                  z\n                    .object({\n                      token: z.string(),\n                      logprob: z.number(),\n                      top_logprobs: z.array(\n                        z\n                          .object({\n                            token: z.string(),\n                            logprob: z.number(),\n                          })\n                          .passthrough(),\n                      ),\n                    })\n                    .passthrough(),\n                )\n                .nullable(),\n            })\n            .passthrough()\n            .nullable()\n            .optional(),\n          finish_reason: z.string().optional().nullable(),\n        })\n        .passthrough(),\n    ),\n  }),\n  // Error response (HTTP 200 with error payload)\n  OpenRouterErrorResponseSchema.extend({\n    user_id: z.string().optional(),\n  }),\n]);\n// limited version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nexport const OpenRouterStreamChatCompletionChunkSchema = z.union([\n  OpenRouterChatCompletionBaseResponseSchema.extend({\n    choices: z.array(\n      z\n        .object({\n          delta: z\n            .object({\n              role: z.enum(['assistant']).optional(),\n              content: z.string().nullish(),\n              reasoning: z.string().nullish().optional(),\n              reasoning_details: ReasoningDetailArraySchema.nullish(),\n              images: ImageResponseArraySchema.nullish(),\n              tool_calls: z\n                .array(\n                  z\n                    .object({\n                      index: z.number().nullish(),\n                      id: z.string().nullish(),\n                      type: z.literal('function').optional(),\n                      function: z\n                        .object({\n                          name: z.string().nullish(),\n                          arguments: z.string().nullish(),\n                        })\n                        .passthrough(),\n                    })\n                    .passthrough(),\n                )\n                .nullish(),\n\n              annotations: z\n                .array(\n                  z.union([\n                    // URL citation from web search\n                    // title, start_index, end_index are optional as some upstream providers may omit them\n                    z\n                      .object({\n                        type: z.literal('url_citation'),\n                        url_citation: z\n                          .object({\n                            url: z.string(),\n                            title: z.string().optional(),\n                            start_index: z.number().optional(),\n                            end_index: z.number().optional(),\n                            content: z.string().optional(),\n                          })\n                          .passthrough(),\n                      })\n                      .passthrough(),\n                    // File annotation from FileParserPlugin (old format)\n                    z\n                      .object({\n                        type: z.literal('file_annotation'),\n                        file_annotation: z\n                          .object({\n                            file_id: z.string(),\n                            quote: z.string().optional(),\n                          })\n                          .passthrough(),\n                      })\n                      .passthrough(),\n                    // File annotation from FileParserPlugin (new format)\n                    z\n                      .object({\n                        type: z.literal('file'),\n                        file: z\n                          .object({\n                            hash: z.string(),\n                            name: z.string(),\n                            content: z\n                              .array(\n                                z\n                                  .object({\n                                    type: z.string(),\n                                    text: z.string().optional(),\n                                  })\n                                  .passthrough(),\n                              )\n                              .optional(),\n                          })\n                          .passthrough(),\n                      })\n                      .passthrough(),\n                  ]),\n                )\n                .nullish(),\n            })\n            .passthrough()\n            .nullish(),\n          logprobs: z\n            .object({\n              content: z\n                .array(\n                  z\n                    .object({\n                      token: z.string(),\n                      logprob: z.number(),\n                      top_logprobs: z.array(\n                        z\n                          .object({\n                            token: z.string(),\n                            logprob: z.number(),\n                          })\n                          .passthrough(),\n                      ),\n                    })\n                    .passthrough(),\n                )\n                .nullable(),\n            })\n            .passthrough()\n            .nullish(),\n          finish_reason: z.string().nullable().optional(),\n          index: z.number().nullish(),\n        })\n        .passthrough(),\n    ),\n  }),\n  OpenRouterErrorResponseSchema,\n]);\n","import { z } from 'zod/v4';\n\nconst ImageResponseSchema = z\n  .object({\n    type: z.literal('image_url'),\n    image_url: z\n      .object({\n        url: z.string(),\n      })\n      .passthrough(),\n  })\n  .passthrough();\n\nexport type ImageResponse = z.infer<typeof ImageResponseSchema>;\n\nconst ImageResponseWithUnknownSchema = z.union([\n  ImageResponseSchema,\n  z.unknown().transform(() => null),\n]);\n\nexport const ImageResponseArraySchema = z\n  .array(ImageResponseWithUnknownSchema)\n  .transform((d) => d.filter((d): d is ImageResponse => !!d));\n","import type {\n  JSONObject,\n  LanguageModelV3,\n  LanguageModelV3CallOptions,\n  LanguageModelV3Content,\n  LanguageModelV3FinishReason,\n  LanguageModelV3FunctionTool,\n  LanguageModelV3ResponseMetadata,\n  LanguageModelV3StreamPart,\n  LanguageModelV3Usage,\n  SharedV3Headers,\n  SharedV3ProviderMetadata,\n  SharedV3Warning,\n} from '@ai-sdk/provider';\nimport type { ParseResult } from '@ai-sdk/provider-utils';\nimport type { z } from 'zod/v4';\nimport type { ReasoningDetailUnion } from '@/src/schemas/reasoning-details';\nimport type { OpenRouterUsageAccounting } from '@/src/types/index';\nimport type { FileAnnotation } from '../schemas/provider-metadata';\nimport type {\n  OpenRouterChatModelId,\n  OpenRouterChatSettings,\n} from '../types/openrouter-chat-settings';\n\nimport {\n  APICallError,\n  InvalidResponseDataError,\n  NoContentGeneratedError,\n} from '@ai-sdk/provider';\nimport {\n  combineHeaders,\n  createEventSourceResponseHandler,\n  createJsonResponseHandler,\n  generateId,\n  isParsableJson,\n  postJsonToApi,\n} from '@ai-sdk/provider-utils';\nimport { ReasoningDetailType } from '@/src/schemas/reasoning-details';\nimport { openrouterFailedResponseHandler } from '../schemas/error-response';\nimport { OpenRouterProviderMetadataSchema } from '../schemas/provider-metadata';\nimport {\n  createFinishReason,\n  mapOpenRouterFinishReason,\n} from '../utils/map-finish-reason';\nimport { convertToOpenRouterChatMessages } from './convert-to-openrouter-chat-messages';\nimport { getBase64FromDataUrl, getMediaType } from './file-url-utils';\nimport { getChatCompletionToolChoice } from './get-tool-choice';\nimport {\n  OpenRouterNonStreamChatCompletionResponseSchema,\n  OpenRouterStreamChatCompletionChunkSchema,\n} from './schemas';\n\ntype OpenRouterChatConfig = {\n  provider: string;\n  compatibility: 'strict' | 'compatible';\n  headers: () => Record<string, string | undefined>;\n  url: (options: { modelId: string; path: string }) => string;\n  fetch?: typeof fetch;\n  extraBody?: Record<string, unknown>;\n};\n\nexport class OpenRouterChatLanguageModel implements LanguageModelV3 {\n  readonly specificationVersion = 'v3' as const;\n  readonly provider = 'openrouter';\n  readonly defaultObjectGenerationMode = 'tool' as const;\n\n  readonly modelId: OpenRouterChatModelId;\n  readonly supportsImageUrls = true;\n  readonly supportedUrls: Record<string, RegExp[]> = {\n    'image/*': [\n      /^data:image\\/[a-zA-Z]+;base64,/,\n      /^https?:\\/\\/.+\\.(jpg|jpeg|png|gif|webp)$/i,\n    ],\n    // 'text/*': [/^data:text\\//, /^https?:\\/\\/.+$/],\n    'application/*': [/^data:application\\//, /^https?:\\/\\/.+$/],\n  };\n  readonly settings: OpenRouterChatSettings;\n\n  private readonly config: OpenRouterChatConfig;\n\n  constructor(\n    modelId: OpenRouterChatModelId,\n    settings: OpenRouterChatSettings,\n    config: OpenRouterChatConfig,\n  ) {\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n  }\n\n  private getArgs({\n    prompt,\n    maxOutputTokens,\n    temperature,\n    topP,\n    frequencyPenalty,\n    presencePenalty,\n    seed,\n    stopSequences,\n    responseFormat,\n    topK,\n    tools,\n    toolChoice,\n  }: LanguageModelV3CallOptions) {\n    const baseArgs = {\n      // model id:\n      model: this.modelId,\n      models: this.settings.models,\n\n      // model specific settings:\n      logit_bias: this.settings.logitBias,\n      logprobs:\n        this.settings.logprobs === true ||\n        typeof this.settings.logprobs === 'number'\n          ? true\n          : undefined,\n      top_logprobs:\n        typeof this.settings.logprobs === 'number'\n          ? this.settings.logprobs\n          : typeof this.settings.logprobs === 'boolean'\n            ? this.settings.logprobs\n              ? 0\n              : undefined\n            : undefined,\n      user: this.settings.user,\n      parallel_tool_calls: this.settings.parallelToolCalls,\n\n      // standardized settings:\n      max_tokens: maxOutputTokens,\n      temperature,\n      top_p: topP,\n      frequency_penalty: frequencyPenalty,\n      presence_penalty: presencePenalty,\n      seed,\n\n      stop: stopSequences,\n      response_format:\n        responseFormat?.type === 'json'\n          ? responseFormat.schema != null\n            ? {\n                type: 'json_schema',\n                json_schema: {\n                  schema: responseFormat.schema,\n                  strict: true,\n                  name: responseFormat.name ?? 'response',\n                  ...(responseFormat.description && {\n                    description: responseFormat.description,\n                  }),\n                },\n              }\n            : { type: 'json_object' }\n          : undefined,\n      top_k: topK,\n\n      // messages:\n      messages: convertToOpenRouterChatMessages(prompt),\n\n      // OpenRouter specific settings:\n      include_reasoning: this.settings.includeReasoning,\n      reasoning: this.settings.reasoning,\n      usage: this.settings.usage,\n\n      // Web search settings:\n      plugins: this.settings.plugins,\n      web_search_options: this.settings.web_search_options,\n      // Provider routing settings:\n      provider: this.settings.provider,\n      // Debug settings:\n      debug: this.settings.debug,\n\n      // extra body:\n      ...this.config.extraBody,\n      ...this.settings.extraBody,\n    };\n\n    if (tools && tools.length > 0) {\n      // TODO: support built-in tools\n      const mappedTools = tools\n        .filter(\n          (tool): tool is LanguageModelV3FunctionTool =>\n            tool.type === 'function',\n        )\n        .map((tool) => ({\n          type: 'function' as const,\n          function: {\n            name: tool.name,\n            description: tool.description,\n            parameters: tool.inputSchema,\n          },\n        }));\n\n      return {\n        ...baseArgs,\n        tools: mappedTools,\n        tool_choice: toolChoice\n          ? getChatCompletionToolChoice(toolChoice)\n          : undefined,\n      };\n    }\n\n    return baseArgs;\n  }\n\n  async doGenerate(options: LanguageModelV3CallOptions): Promise<{\n    content: Array<LanguageModelV3Content>;\n    finishReason: LanguageModelV3FinishReason;\n    usage: LanguageModelV3Usage;\n    warnings: Array<SharedV3Warning>;\n    providerMetadata?: {\n      openrouter: {\n        provider: string;\n        reasoning_details?: ReasoningDetailUnion[];\n        usage: OpenRouterUsageAccounting;\n      };\n    };\n    request?: { body?: unknown };\n    response?: LanguageModelV3ResponseMetadata & {\n      headers?: SharedV3Headers;\n      body?: unknown;\n    };\n  }> {\n    const providerOptions = options.providerOptions || {};\n    const openrouterOptions = providerOptions.openrouter || {};\n\n    const args = {\n      ...this.getArgs(options),\n      ...openrouterOptions,\n    };\n\n    const { value: responseValue, responseHeaders } = await postJsonToApi({\n      url: this.config.url({\n        path: '/chat/completions',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body: args,\n      failedResponseHandler: openrouterFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        OpenRouterNonStreamChatCompletionResponseSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    // Check if response is an error (HTTP 200 with error payload)\n    if ('error' in responseValue) {\n      const errorData = responseValue.error as {\n        message: string;\n        code?: string;\n      };\n      throw new APICallError({\n        message: errorData.message,\n        url: this.config.url({\n          path: '/chat/completions',\n          modelId: this.modelId,\n        }),\n        requestBodyValues: args,\n        statusCode: 200,\n        responseHeaders,\n        data: errorData,\n      });\n    }\n\n    // Now TypeScript knows this is the success response\n    const response = responseValue;\n\n    const choice = response.choices[0];\n\n    if (!choice) {\n      throw new NoContentGeneratedError({\n        message: 'No choice in response',\n      });\n    }\n\n    // Extract detailed usage information\n    const usageInfo: LanguageModelV3Usage = response.usage\n      ? {\n          inputTokens: {\n            total: response.usage.prompt_tokens ?? 0,\n            noCache: undefined,\n            cacheRead:\n              response.usage.prompt_tokens_details?.cached_tokens ?? undefined,\n            cacheWrite: undefined,\n          },\n          outputTokens: {\n            total: response.usage.completion_tokens ?? 0,\n            text: undefined,\n            reasoning:\n              response.usage.completion_tokens_details?.reasoning_tokens ??\n              undefined,\n          },\n          raw: response.usage as JSONObject,\n        }\n      : {\n          inputTokens: {\n            total: 0,\n            noCache: undefined,\n            cacheRead: undefined,\n            cacheWrite: undefined,\n          },\n          outputTokens: {\n            total: 0,\n            text: undefined,\n            reasoning: undefined,\n          },\n          raw: undefined,\n        };\n\n    const reasoningDetails = choice.message.reasoning_details ?? [];\n\n    const reasoning: Array<LanguageModelV3Content> =\n      reasoningDetails.length > 0\n        ? (reasoningDetails\n            .map((detail) => {\n              switch (detail.type) {\n                case ReasoningDetailType.Text: {\n                  if (detail.text) {\n                    return {\n                      type: 'reasoning' as const,\n                      text: detail.text,\n                      providerMetadata: {\n                        openrouter: {\n                          reasoning_details: [detail],\n                        },\n                      },\n                    };\n                  }\n                  break;\n                }\n                case ReasoningDetailType.Summary: {\n                  if (detail.summary) {\n                    return {\n                      type: 'reasoning' as const,\n                      text: detail.summary,\n                      providerMetadata: {\n                        openrouter: {\n                          reasoning_details: [detail],\n                        },\n                      },\n                    };\n                  }\n                  break;\n                }\n                case ReasoningDetailType.Encrypted: {\n                  // For encrypted reasoning, we include a redacted placeholder\n                  if (detail.data) {\n                    return {\n                      type: 'reasoning' as const,\n                      text: '[REDACTED]',\n                      providerMetadata: {\n                        openrouter: {\n                          reasoning_details: [detail],\n                        },\n                      },\n                    };\n                  }\n                  break;\n                }\n                default: {\n                  detail satisfies never;\n                }\n              }\n              return null;\n            })\n            .filter((p) => p !== null) as Array<LanguageModelV3Content>)\n        : choice.message.reasoning\n          ? [\n              {\n                type: 'reasoning' as const,\n                text: choice.message.reasoning,\n              },\n            ]\n          : [];\n\n    const content: Array<LanguageModelV3Content> = [];\n\n    // Add reasoning content first\n    content.push(...reasoning);\n\n    if (choice.message.content) {\n      content.push({\n        type: 'text' as const,\n        text: choice.message.content,\n      });\n    }\n\n    if (choice.message.tool_calls) {\n      // Only attach reasoning_details to the first tool call to avoid\n      // duplicating thinking blocks for parallel tool calls (Claude)\n      let reasoningDetailsAttachedToToolCall = false;\n      for (const toolCall of choice.message.tool_calls) {\n        content.push({\n          type: 'tool-call' as const,\n          toolCallId: toolCall.id ?? generateId(),\n          toolName: toolCall.function.name,\n          input: toolCall.function.arguments ?? '{}',\n          providerMetadata: !reasoningDetailsAttachedToToolCall\n            ? {\n                openrouter: {\n                  reasoning_details: reasoningDetails,\n                },\n              }\n            : undefined,\n        });\n        reasoningDetailsAttachedToToolCall = true;\n      }\n    }\n\n    if (choice.message.images) {\n      for (const image of choice.message.images) {\n        content.push({\n          type: 'file' as const,\n          mediaType: getMediaType(image.image_url.url, 'image/jpeg'),\n          data: getBase64FromDataUrl(image.image_url.url),\n        });\n      }\n    }\n\n    if (choice.message.annotations) {\n      for (const annotation of choice.message.annotations) {\n        if (annotation.type === 'url_citation') {\n          content.push({\n            type: 'source' as const,\n            sourceType: 'url' as const,\n            id: annotation.url_citation.url,\n            url: annotation.url_citation.url,\n            title: annotation.url_citation.title ?? '',\n            providerMetadata: {\n              openrouter: {\n                content: annotation.url_citation.content ?? '',\n                startIndex: annotation.url_citation.start_index ?? 0,\n                endIndex: annotation.url_citation.end_index ?? 0,\n              },\n            },\n          });\n        }\n      }\n    }\n\n    // Extract file annotations to expose in providerMetadata\n    const fileAnnotations = choice.message.annotations?.filter(\n      (\n        a,\n      ): a is {\n        type: 'file';\n        file: {\n          hash: string;\n          name: string;\n          content?: Array<{ type: string; text?: string }>;\n        };\n      } => a.type === 'file',\n    );\n\n    // Fix for Gemini 3 thoughtSignature: when there are tool calls with encrypted\n    // reasoning (thoughtSignature), the model returns 'stop' but expects continuation.\n    // Override to 'tool-calls' so the SDK knows to continue the conversation.\n    const hasToolCalls =\n      choice.message.tool_calls && choice.message.tool_calls.length > 0;\n    const hasEncryptedReasoning = reasoningDetails.some(\n      (d) => d.type === ReasoningDetailType.Encrypted && d.data,\n    );\n    const shouldOverrideFinishReason =\n      hasToolCalls && hasEncryptedReasoning && choice.finish_reason === 'stop';\n\n    const effectiveFinishReason = shouldOverrideFinishReason\n      ? createFinishReason('tool-calls', choice.finish_reason ?? undefined)\n      : mapOpenRouterFinishReason(choice.finish_reason);\n\n    return {\n      content,\n      finishReason: effectiveFinishReason,\n      usage: usageInfo,\n      warnings: [],\n      providerMetadata: {\n        openrouter: OpenRouterProviderMetadataSchema.parse({\n          provider: response.provider ?? '',\n          reasoning_details: choice.message.reasoning_details ?? [],\n          annotations:\n            fileAnnotations && fileAnnotations.length > 0\n              ? fileAnnotations\n              : undefined,\n          usage: {\n            promptTokens: usageInfo.inputTokens.total ?? 0,\n            completionTokens: usageInfo.outputTokens.total ?? 0,\n            totalTokens:\n              (usageInfo.inputTokens.total ?? 0) +\n              (usageInfo.outputTokens.total ?? 0),\n            ...(response.usage?.cost != null\n              ? { cost: response.usage.cost }\n              : {}),\n            ...(response.usage?.prompt_tokens_details?.cached_tokens != null\n              ? {\n                  promptTokensDetails: {\n                    cachedTokens:\n                      response.usage.prompt_tokens_details.cached_tokens,\n                  },\n                }\n              : {}),\n            ...(response.usage?.completion_tokens_details?.reasoning_tokens !=\n            null\n              ? {\n                  completionTokensDetails: {\n                    reasoningTokens:\n                      response.usage.completion_tokens_details.reasoning_tokens,\n                  },\n                }\n              : {}),\n            ...(response.usage?.cost_details?.upstream_inference_cost != null\n              ? {\n                  costDetails: {\n                    upstreamInferenceCost:\n                      response.usage.cost_details.upstream_inference_cost,\n                  },\n                }\n              : {}),\n          },\n        }),\n      },\n      request: { body: args },\n      response: {\n        id: response.id,\n        modelId: response.model,\n        headers: responseHeaders,\n      },\n    };\n  }\n\n  async doStream(options: LanguageModelV3CallOptions): Promise<{\n    stream: ReadableStream<LanguageModelV3StreamPart>;\n    warnings: Array<SharedV3Warning>;\n    request?: { body?: unknown };\n    response?: LanguageModelV3ResponseMetadata & {\n      headers?: SharedV3Headers;\n      body?: unknown;\n    };\n  }> {\n    const providerOptions = options.providerOptions || {};\n    const openrouterOptions = providerOptions.openrouter || {};\n\n    const args = {\n      ...this.getArgs(options),\n      ...openrouterOptions,\n    };\n\n    const { value: response, responseHeaders } = await postJsonToApi({\n      url: this.config.url({\n        path: '/chat/completions',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body: {\n        ...args,\n        stream: true,\n\n        // only include stream_options when in strict compatibility mode:\n        stream_options:\n          this.config.compatibility === 'strict'\n            ? {\n                include_usage: true,\n                // If user has requested usage accounting, make sure we get it in the stream\n                ...(this.settings.usage?.include\n                  ? { include_usage: true }\n                  : {}),\n              }\n            : undefined,\n      },\n      failedResponseHandler: openrouterFailedResponseHandler,\n      successfulResponseHandler: createEventSourceResponseHandler(\n        OpenRouterStreamChatCompletionChunkSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const toolCalls: Array<{\n      id: string;\n      type: 'function';\n      function: {\n        name: string;\n        arguments: string;\n      };\n      inputStarted: boolean;\n      sent: boolean;\n    }> = [];\n\n    let finishReason: LanguageModelV3FinishReason = createFinishReason('other');\n    const usage: LanguageModelV3Usage = {\n      inputTokens: {\n        total: undefined,\n        noCache: undefined,\n        cacheRead: undefined,\n        cacheWrite: undefined,\n      },\n      outputTokens: {\n        total: undefined,\n        text: undefined,\n        reasoning: undefined,\n      },\n      raw: undefined,\n    };\n\n    // Track provider-specific usage information\n    const openrouterUsage: Partial<OpenRouterUsageAccounting> = {};\n\n    // Track raw usage from the API response for usage.raw\n    let rawUsage: JSONObject | undefined;\n\n    // Track reasoning details to preserve for multi-turn conversations\n    const accumulatedReasoningDetails: ReasoningDetailUnion[] = [];\n\n    // Track whether reasoning_details have been attached to a tool call\n    // For parallel tool calls (e.g., Claude with thinking), only the first tool call\n    // should have reasoning_details to avoid duplicating thinking blocks\n    let reasoningDetailsAttachedToToolCall = false;\n\n    // Track file annotations to expose in providerMetadata\n    const accumulatedFileAnnotations: FileAnnotation[] = [];\n\n    let textStarted = false;\n    let reasoningStarted = false;\n    let textId: string | undefined;\n    let reasoningId: string | undefined;\n    let openrouterResponseId: string | undefined;\n    let provider: string | undefined;\n\n    return {\n      stream: response.pipeThrough(\n        new TransformStream<\n          ParseResult<\n            z.infer<typeof OpenRouterStreamChatCompletionChunkSchema>\n          >,\n          LanguageModelV3StreamPart\n        >({\n          transform(chunk, controller) {\n            // Emit raw chunk if requested (before anything else)\n            if (options.includeRawChunks) {\n              controller.enqueue({ type: 'raw', rawValue: chunk.rawValue });\n            }\n\n            // handle failed chunk parsing / validation:\n            if (!chunk.success) {\n              finishReason = createFinishReason('error');\n              controller.enqueue({ type: 'error', error: chunk.error });\n              return;\n            }\n\n            const value = chunk.value;\n\n            // handle error chunks:\n            if ('error' in value) {\n              finishReason = createFinishReason('error');\n              controller.enqueue({ type: 'error', error: value.error });\n              return;\n            }\n\n            if (value.provider) {\n              provider = value.provider;\n            }\n\n            if (value.id) {\n              openrouterResponseId = value.id;\n              controller.enqueue({\n                type: 'response-metadata',\n                id: value.id,\n              });\n            }\n\n            if (value.model) {\n              controller.enqueue({\n                type: 'response-metadata',\n                modelId: value.model,\n              });\n            }\n\n            if (value.usage != null) {\n              usage.inputTokens.total = value.usage.prompt_tokens;\n              usage.outputTokens.total = value.usage.completion_tokens;\n\n              // Store raw usage from the API response (cast to JSONObject since schema uses passthrough)\n              rawUsage = value.usage as JSONObject;\n\n              // Collect OpenRouter specific usage information\n              openrouterUsage.promptTokens = value.usage.prompt_tokens;\n\n              if (value.usage.prompt_tokens_details) {\n                const cachedInputTokens =\n                  value.usage.prompt_tokens_details.cached_tokens ?? 0;\n\n                usage.inputTokens.cacheRead = cachedInputTokens;\n                openrouterUsage.promptTokensDetails = {\n                  cachedTokens: cachedInputTokens,\n                };\n              }\n\n              openrouterUsage.completionTokens = value.usage.completion_tokens;\n              if (value.usage.completion_tokens_details) {\n                const reasoningTokens =\n                  value.usage.completion_tokens_details.reasoning_tokens ?? 0;\n\n                usage.outputTokens.reasoning = reasoningTokens;\n                openrouterUsage.completionTokensDetails = {\n                  reasoningTokens,\n                };\n              }\n\n              if (value.usage.cost != null) {\n                openrouterUsage.cost = value.usage.cost;\n              }\n              openrouterUsage.totalTokens = value.usage.total_tokens;\n              const upstreamInferenceCost =\n                value.usage.cost_details?.upstream_inference_cost;\n              if (upstreamInferenceCost != null) {\n                openrouterUsage.costDetails = {\n                  upstreamInferenceCost,\n                };\n              }\n            }\n\n            const choice = value.choices[0];\n\n            if (choice?.finish_reason != null) {\n              finishReason = mapOpenRouterFinishReason(choice.finish_reason);\n            }\n\n            if (choice?.delta == null) {\n              return;\n            }\n\n            const delta = choice.delta;\n\n            const emitReasoningChunk = (\n              chunkText: string,\n              providerMetadata?: SharedV3ProviderMetadata,\n            ) => {\n              if (!reasoningStarted) {\n                reasoningId = openrouterResponseId || generateId();\n                controller.enqueue({\n                  providerMetadata,\n                  type: 'reasoning-start',\n                  id: reasoningId,\n                });\n                reasoningStarted = true;\n              }\n              controller.enqueue({\n                providerMetadata,\n                type: 'reasoning-delta',\n                delta: chunkText,\n                id: reasoningId || generateId(),\n              });\n            };\n\n            if (delta.reasoning_details && delta.reasoning_details.length > 0) {\n              // Accumulate reasoning_details to preserve for multi-turn conversations\n              // Merge consecutive reasoning.text items into a single entry\n              for (const detail of delta.reasoning_details) {\n                if (detail.type === ReasoningDetailType.Text) {\n                  const lastDetail =\n                    accumulatedReasoningDetails[\n                      accumulatedReasoningDetails.length - 1\n                    ];\n                  if (lastDetail?.type === ReasoningDetailType.Text) {\n                    // Merge with the previous text detail\n                    lastDetail.text =\n                      (lastDetail.text || '') + (detail.text || '');\n\n                    lastDetail.signature =\n                      lastDetail.signature || detail.signature;\n\n                    lastDetail.format = lastDetail.format || detail.format;\n                  } else {\n                    // Start a new text detail\n                    accumulatedReasoningDetails.push({ ...detail });\n                  }\n                } else {\n                  // Non-text details (encrypted, summary) are pushed as-is\n                  accumulatedReasoningDetails.push(detail);\n                }\n              }\n\n              // Emit reasoning_details in providerMetadata for each delta chunk\n              // so users can accumulate them on their end before sending back\n              const reasoningMetadata: SharedV3ProviderMetadata = {\n                openrouter: {\n                  reasoning_details: delta.reasoning_details,\n                },\n              };\n\n              for (const detail of delta.reasoning_details) {\n                switch (detail.type) {\n                  case ReasoningDetailType.Text: {\n                    if (detail.text) {\n                      emitReasoningChunk(detail.text, reasoningMetadata);\n                    }\n                    break;\n                  }\n                  case ReasoningDetailType.Encrypted: {\n                    if (detail.data) {\n                      emitReasoningChunk('[REDACTED]', reasoningMetadata);\n                    }\n                    break;\n                  }\n                  case ReasoningDetailType.Summary: {\n                    if (detail.summary) {\n                      emitReasoningChunk(detail.summary, reasoningMetadata);\n                    }\n                    break;\n                  }\n                  default: {\n                    detail satisfies never;\n                    break;\n                  }\n                }\n              }\n            } else if (delta.reasoning) {\n              emitReasoningChunk(delta.reasoning);\n            }\n\n            if (delta.content) {\n              // If reasoning was previously active and now we're starting text content,\n              // we should end the reasoning first to maintain proper order\n              if (reasoningStarted && !textStarted) {\n                controller.enqueue({\n                  type: 'reasoning-end',\n                  id: reasoningId || generateId(),\n                });\n                reasoningStarted = false; // Mark as ended so we don't end it again in flush\n              }\n\n              if (!textStarted) {\n                textId = openrouterResponseId || generateId();\n                controller.enqueue({\n                  type: 'text-start',\n                  id: textId,\n                });\n                textStarted = true;\n              }\n              controller.enqueue({\n                type: 'text-delta',\n                delta: delta.content,\n                id: textId || generateId(),\n              });\n            }\n\n            if (delta.annotations) {\n              for (const annotation of delta.annotations) {\n                if (annotation.type === 'url_citation') {\n                  controller.enqueue({\n                    type: 'source',\n                    sourceType: 'url' as const,\n                    id: annotation.url_citation.url,\n                    url: annotation.url_citation.url,\n                    title: annotation.url_citation.title ?? '',\n                    providerMetadata: {\n                      openrouter: {\n                        content: annotation.url_citation.content ?? '',\n                        startIndex: annotation.url_citation.start_index ?? 0,\n                        endIndex: annotation.url_citation.end_index ?? 0,\n                      },\n                    },\n                  });\n                } else if (annotation.type === 'file') {\n                  // Accumulate file annotations to expose in providerMetadata\n                  // Type guard to validate structure matches expected shape\n                  const file = (annotation as { file?: unknown }).file;\n                  if (\n                    file &&\n                    typeof file === 'object' &&\n                    'hash' in file &&\n                    'name' in file\n                  ) {\n                    accumulatedFileAnnotations.push(\n                      annotation as FileAnnotation,\n                    );\n                  }\n                }\n              }\n            }\n\n            if (delta.tool_calls != null) {\n              for (const toolCallDelta of delta.tool_calls) {\n                const index = toolCallDelta.index ?? toolCalls.length - 1;\n\n                // Tool call start. OpenRouter returns all information except the arguments in the first chunk.\n                if (toolCalls[index] == null) {\n                  if (toolCallDelta.type !== 'function') {\n                    throw new InvalidResponseDataError({\n                      data: toolCallDelta,\n                      message: `Expected 'function' type.`,\n                    });\n                  }\n\n                  if (toolCallDelta.id == null) {\n                    throw new InvalidResponseDataError({\n                      data: toolCallDelta,\n                      message: `Expected 'id' to be a string.`,\n                    });\n                  }\n\n                  if (toolCallDelta.function?.name == null) {\n                    throw new InvalidResponseDataError({\n                      data: toolCallDelta,\n                      message: `Expected 'function.name' to be a string.`,\n                    });\n                  }\n\n                  toolCalls[index] = {\n                    id: toolCallDelta.id,\n                    type: 'function',\n                    function: {\n                      name: toolCallDelta.function.name,\n                      arguments: toolCallDelta.function.arguments ?? '',\n                    },\n                    inputStarted: false,\n                    sent: false,\n                  };\n\n                  const toolCall = toolCalls[index];\n\n                  if (toolCall == null) {\n                    throw new InvalidResponseDataError({\n                      data: { index, toolCallsLength: toolCalls.length },\n                      message: `Tool call at index ${index} is missing after creation.`,\n                    });\n                  }\n\n                  // check if tool call is complete (some providers send the full tool call in one chunk)\n                  if (\n                    toolCall.function?.name != null &&\n                    toolCall.function?.arguments != null &&\n                    isParsableJson(toolCall.function.arguments)\n                  ) {\n                    toolCall.inputStarted = true;\n\n                    controller.enqueue({\n                      type: 'tool-input-start',\n                      id: toolCall.id,\n                      toolName: toolCall.function.name,\n                    });\n\n                    // send delta\n                    controller.enqueue({\n                      type: 'tool-input-delta',\n                      id: toolCall.id,\n                      delta: toolCall.function.arguments,\n                    });\n\n                    controller.enqueue({\n                      type: 'tool-input-end',\n                      id: toolCall.id,\n                    });\n\n                    // send tool call\n                    // Only attach reasoning_details to the first tool call to avoid\n                    // duplicating thinking blocks for parallel tool calls (Claude)\n                    controller.enqueue({\n                      type: 'tool-call',\n                      toolCallId: toolCall.id,\n                      toolName: toolCall.function.name,\n                      input: toolCall.function.arguments,\n                      providerMetadata: !reasoningDetailsAttachedToToolCall\n                        ? {\n                            openrouter: {\n                              reasoning_details: accumulatedReasoningDetails,\n                            },\n                          }\n                        : undefined,\n                    });\n\n                    reasoningDetailsAttachedToToolCall = true;\n                    toolCall.sent = true;\n                  }\n\n                  continue;\n                }\n\n                // existing tool call, merge\n                const toolCall = toolCalls[index];\n\n                if (toolCall == null) {\n                  throw new InvalidResponseDataError({\n                    data: {\n                      index,\n                      toolCallsLength: toolCalls.length,\n                      toolCallDelta,\n                    },\n                    message: `Tool call at index ${index} is missing during merge.`,\n                  });\n                }\n\n                if (!toolCall.inputStarted) {\n                  toolCall.inputStarted = true;\n                  controller.enqueue({\n                    type: 'tool-input-start',\n                    id: toolCall.id,\n                    toolName: toolCall.function.name,\n                  });\n                }\n\n                if (toolCallDelta.function?.arguments != null) {\n                  toolCall.function.arguments +=\n                    toolCallDelta.function?.arguments ?? '';\n                }\n\n                // send delta\n                controller.enqueue({\n                  type: 'tool-input-delta',\n                  id: toolCall.id,\n                  delta: toolCallDelta.function.arguments ?? '',\n                });\n\n                // check if tool call is complete\n                if (\n                  toolCall.function?.name != null &&\n                  toolCall.function?.arguments != null &&\n                  isParsableJson(toolCall.function.arguments)\n                ) {\n                  // Only attach reasoning_details to the first tool call to avoid\n                  // duplicating thinking blocks for parallel tool calls (Claude)\n                  controller.enqueue({\n                    type: 'tool-call',\n                    toolCallId: toolCall.id ?? generateId(),\n                    toolName: toolCall.function.name,\n                    input: toolCall.function.arguments,\n                    providerMetadata: !reasoningDetailsAttachedToToolCall\n                      ? {\n                          openrouter: {\n                            reasoning_details: accumulatedReasoningDetails,\n                          },\n                        }\n                      : undefined,\n                  });\n\n                  reasoningDetailsAttachedToToolCall = true;\n                  toolCall.sent = true;\n                }\n              }\n            }\n\n            if (delta.images != null) {\n              for (const image of delta.images) {\n                controller.enqueue({\n                  type: 'file',\n                  mediaType: getMediaType(image.image_url.url, 'image/jpeg'),\n                  data: getBase64FromDataUrl(image.image_url.url),\n                });\n              }\n            }\n          },\n\n          flush(controller) {\n            // Fix for Gemini 3 thoughtSignature: when there are tool calls with encrypted\n            // reasoning (thoughtSignature), the model returns 'stop' but expects continuation.\n            // Override to 'tool-calls' so the SDK knows to continue the conversation.\n            const hasToolCalls = toolCalls.length > 0;\n            const hasEncryptedReasoning = accumulatedReasoningDetails.some(\n              (d) => d.type === ReasoningDetailType.Encrypted && d.data,\n            );\n            if (\n              hasToolCalls &&\n              hasEncryptedReasoning &&\n              finishReason.unified === 'stop'\n            ) {\n              finishReason = createFinishReason('tool-calls', finishReason.raw);\n            }\n\n            // Forward any unsent tool calls if finish reason is 'tool-calls'\n            if (finishReason.unified === 'tool-calls') {\n              for (const toolCall of toolCalls) {\n                if (toolCall && !toolCall.sent) {\n                  // Only attach reasoning_details to the first tool call to avoid\n                  // duplicating thinking blocks for parallel tool calls (Claude)\n                  controller.enqueue({\n                    type: 'tool-call',\n                    toolCallId: toolCall.id ?? generateId(),\n                    toolName: toolCall.function.name,\n                    // Coerce invalid arguments to an empty JSON object\n                    input: isParsableJson(toolCall.function.arguments)\n                      ? toolCall.function.arguments\n                      : '{}',\n                    providerMetadata: !reasoningDetailsAttachedToToolCall\n                      ? {\n                          openrouter: {\n                            reasoning_details: accumulatedReasoningDetails,\n                          },\n                        }\n                      : undefined,\n                  });\n                  reasoningDetailsAttachedToToolCall = true;\n                  toolCall.sent = true;\n                }\n              }\n            }\n\n            // End reasoning first if it was started, to maintain proper order\n            if (reasoningStarted) {\n              controller.enqueue({\n                type: 'reasoning-end',\n                id: reasoningId || generateId(),\n              });\n            }\n            if (textStarted) {\n              controller.enqueue({\n                type: 'text-end',\n                id: textId || generateId(),\n              });\n            }\n\n            const openrouterMetadata: {\n              usage: Partial<OpenRouterUsageAccounting>;\n              provider?: string;\n              reasoning_details?: ReasoningDetailUnion[];\n              annotations?: FileAnnotation[];\n            } = {\n              usage: openrouterUsage,\n            };\n\n            // Only include provider if it's actually set\n            if (provider !== undefined) {\n              openrouterMetadata.provider = provider;\n            }\n\n            // Include accumulated reasoning_details if any were received\n            if (accumulatedReasoningDetails.length > 0) {\n              openrouterMetadata.reasoning_details =\n                accumulatedReasoningDetails;\n            }\n\n            // Include accumulated file annotations if any were received\n            if (accumulatedFileAnnotations.length > 0) {\n              openrouterMetadata.annotations = accumulatedFileAnnotations;\n            }\n\n            // Set raw usage before emitting finish event\n            usage.raw = rawUsage;\n\n            controller.enqueue({\n              type: 'finish',\n              finishReason,\n              usage,\n              providerMetadata: {\n                openrouter: openrouterMetadata,\n              },\n            });\n          },\n        }),\n      ),\n      warnings: [],\n      request: { body: args },\n      response: { headers: responseHeaders },\n    };\n  }\n}\n","import type {\n  LanguageModelV3FilePart,\n  LanguageModelV3Prompt,\n  LanguageModelV3ReasoningPart,\n  LanguageModelV3TextPart,\n  LanguageModelV3ToolCallPart,\n  LanguageModelV3ToolResultPart,\n} from '@ai-sdk/provider';\n\nimport {\n  InvalidPromptError,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\n\nexport function convertToOpenRouterCompletionPrompt({\n  prompt,\n  inputFormat,\n  user = 'user',\n  assistant = 'assistant',\n}: {\n  prompt: LanguageModelV3Prompt;\n  inputFormat: 'prompt' | 'messages';\n  user?: string;\n  assistant?: string;\n}): {\n  prompt: string;\n} {\n  // When the user supplied a prompt input, we don't transform it:\n  if (\n    inputFormat === 'prompt' &&\n    prompt.length === 1 &&\n    prompt[0] &&\n    prompt[0].role === 'user' &&\n    prompt[0].content.length === 1 &&\n    prompt[0].content[0] &&\n    prompt[0].content[0].type === 'text'\n  ) {\n    return { prompt: prompt[0].content[0].text };\n  }\n\n  // otherwise transform to a chat message format:\n  let text = '';\n\n  // if first message is a system message, add it to the text:\n  if (prompt[0] && prompt[0].role === 'system') {\n    text += `${prompt[0].content}\\n\\n`;\n    prompt = prompt.slice(1);\n  }\n\n  for (const { role, content } of prompt) {\n    switch (role) {\n      case 'system': {\n        throw new InvalidPromptError({\n          message: `Unexpected system message in prompt: ${content}`,\n          prompt,\n        });\n      }\n\n      case 'user': {\n        const userMessage = content\n          .map((part: LanguageModelV3TextPart | LanguageModelV3FilePart) => {\n            switch (part.type) {\n              case 'text': {\n                return part.text;\n              }\n\n              case 'file': {\n                throw new UnsupportedFunctionalityError({\n                  functionality: 'file attachments',\n                });\n              }\n              default: {\n                return '';\n              }\n            }\n          })\n          .join('');\n\n        text += `${user}:\\n${userMessage}\\n\\n`;\n        break;\n      }\n\n      case 'assistant': {\n        const assistantMessage = content\n          .map(\n            (\n              part:\n                | LanguageModelV3TextPart\n                | LanguageModelV3FilePart\n                | LanguageModelV3ReasoningPart\n                | LanguageModelV3ToolCallPart\n                | LanguageModelV3ToolResultPart,\n            ) => {\n              switch (part.type) {\n                case 'text': {\n                  return part.text;\n                }\n                case 'tool-call': {\n                  throw new UnsupportedFunctionalityError({\n                    functionality: 'tool-call messages',\n                  });\n                }\n                case 'tool-result': {\n                  throw new UnsupportedFunctionalityError({\n                    functionality: 'tool-result messages',\n                  });\n                }\n                case 'reasoning': {\n                  throw new UnsupportedFunctionalityError({\n                    functionality: 'reasoning messages',\n                  });\n                }\n\n                case 'file': {\n                  throw new UnsupportedFunctionalityError({\n                    functionality: 'file attachments',\n                  });\n                }\n\n                default: {\n                  return '';\n                }\n              }\n            },\n          )\n          .join('');\n\n        text += `${assistant}:\\n${assistantMessage}\\n\\n`;\n        break;\n      }\n\n      case 'tool': {\n        throw new UnsupportedFunctionalityError({\n          functionality: 'tool messages',\n        });\n      }\n\n      default: {\n        break;\n      }\n    }\n  }\n\n  // Assistant message prefix:\n  text += `${assistant}:\\n`;\n\n  return {\n    prompt: text,\n  };\n}\n","import { z } from 'zod/v4';\nimport { OpenRouterErrorResponseSchema } from '../schemas/error-response';\nimport { ReasoningDetailArraySchema } from '../schemas/reasoning-details';\n\n// limited version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nexport const OpenRouterCompletionChunkSchema = z.union([\n  z\n    .object({\n      id: z.string().optional(),\n      model: z.string().optional(),\n      provider: z.string().optional(),\n      choices: z.array(\n        z\n          .object({\n            text: z.string(),\n            reasoning: z.string().nullish().optional(),\n            reasoning_details: ReasoningDetailArraySchema.nullish(),\n\n            finish_reason: z.string().nullish(),\n            index: z.number().nullish(),\n            logprobs: z\n              .object({\n                tokens: z.array(z.string()),\n                token_logprobs: z.array(z.number()),\n                top_logprobs: z\n                  .array(z.record(z.string(), z.number()))\n                  .nullable(),\n              })\n              .passthrough()\n              .nullable()\n              .optional(),\n          })\n          .passthrough(),\n      ),\n      usage: z\n        .object({\n          prompt_tokens: z.number(),\n          prompt_tokens_details: z\n            .object({\n              cached_tokens: z.number(),\n            })\n            .passthrough()\n            .nullish(),\n          completion_tokens: z.number(),\n          completion_tokens_details: z\n            .object({\n              reasoning_tokens: z.number(),\n            })\n            .passthrough()\n            .nullish(),\n          total_tokens: z.number(),\n          cost: z.number().optional(),\n          cost_details: z\n            .object({\n              upstream_inference_cost: z.number().nullish(),\n            })\n            .passthrough()\n            .nullish(),\n        })\n        .passthrough()\n        .nullish(),\n    })\n    .passthrough(),\n  OpenRouterErrorResponseSchema,\n]);\n","import type {\n  JSONObject,\n  LanguageModelV3,\n  LanguageModelV3CallOptions,\n  LanguageModelV3FinishReason,\n  LanguageModelV3StreamPart,\n  LanguageModelV3Usage,\n} from '@ai-sdk/provider';\nimport type { ParseResult } from '@ai-sdk/provider-utils';\nimport type { z } from 'zod/v4';\nimport type { OpenRouterUsageAccounting } from '../types';\nimport type {\n  OpenRouterCompletionModelId,\n  OpenRouterCompletionSettings,\n} from '../types/openrouter-completion-settings';\n\nimport {\n  APICallError,\n  NoContentGeneratedError,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport {\n  combineHeaders,\n  createEventSourceResponseHandler,\n  createJsonResponseHandler,\n  generateId,\n  postJsonToApi,\n} from '@ai-sdk/provider-utils';\nimport { openrouterFailedResponseHandler } from '../schemas/error-response';\nimport { OpenRouterProviderMetadataSchema } from '../schemas/provider-metadata';\nimport {\n  createFinishReason,\n  mapOpenRouterFinishReason,\n} from '../utils/map-finish-reason';\nimport { convertToOpenRouterCompletionPrompt } from './convert-to-openrouter-completion-prompt';\nimport { OpenRouterCompletionChunkSchema } from './schemas';\n\ntype OpenRouterCompletionConfig = {\n  provider: string;\n  compatibility: 'strict' | 'compatible';\n  headers: () => Record<string, string | undefined>;\n  url: (options: { modelId: string; path: string }) => string;\n  fetch?: typeof fetch;\n  extraBody?: Record<string, unknown>;\n};\n\nexport class OpenRouterCompletionLanguageModel implements LanguageModelV3 {\n  readonly specificationVersion = 'v3' as const;\n  readonly provider = 'openrouter';\n  readonly modelId: OpenRouterCompletionModelId;\n  readonly supportsImageUrls = true;\n  readonly supportedUrls: Record<string, RegExp[]> = {\n    'image/*': [\n      /^data:image\\/[a-zA-Z]+;base64,/,\n      /^https?:\\/\\/.+\\.(jpg|jpeg|png|gif|webp)$/i,\n    ],\n    'text/*': [/^data:text\\//, /^https?:\\/\\/.+$/],\n    'application/*': [/^data:application\\//, /^https?:\\/\\/.+$/],\n  };\n  readonly defaultObjectGenerationMode = undefined;\n  readonly settings: OpenRouterCompletionSettings;\n\n  private readonly config: OpenRouterCompletionConfig;\n\n  constructor(\n    modelId: OpenRouterCompletionModelId,\n    settings: OpenRouterCompletionSettings,\n    config: OpenRouterCompletionConfig,\n  ) {\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n  }\n\n  private getArgs({\n    prompt,\n    maxOutputTokens,\n    temperature,\n    topP,\n    frequencyPenalty,\n    presencePenalty,\n    seed,\n    responseFormat,\n    topK,\n    stopSequences,\n    tools,\n    toolChoice,\n  }: LanguageModelV3CallOptions) {\n    const { prompt: completionPrompt } = convertToOpenRouterCompletionPrompt({\n      prompt,\n      inputFormat: 'prompt',\n    });\n\n    if (tools?.length) {\n      throw new UnsupportedFunctionalityError({\n        functionality: 'tools',\n      });\n    }\n\n    if (toolChoice) {\n      throw new UnsupportedFunctionalityError({\n        functionality: 'toolChoice',\n      });\n    }\n\n    return {\n      // model id:\n      model: this.modelId,\n      models: this.settings.models,\n\n      // model specific settings:\n      logit_bias: this.settings.logitBias,\n      logprobs:\n        typeof this.settings.logprobs === 'number'\n          ? this.settings.logprobs\n          : typeof this.settings.logprobs === 'boolean'\n            ? this.settings.logprobs\n              ? 0\n              : undefined\n            : undefined,\n      suffix: this.settings.suffix,\n      user: this.settings.user,\n\n      // standardized settings:\n      max_tokens: maxOutputTokens,\n      temperature,\n      top_p: topP,\n      frequency_penalty: frequencyPenalty,\n      presence_penalty: presencePenalty,\n      seed,\n\n      stop: stopSequences,\n      response_format: responseFormat,\n      top_k: topK,\n\n      // prompt:\n      prompt: completionPrompt,\n\n      // OpenRouter specific settings:\n      include_reasoning: this.settings.includeReasoning,\n      reasoning: this.settings.reasoning,\n\n      // extra body:\n      ...this.config.extraBody,\n      ...this.settings.extraBody,\n    };\n  }\n\n  async doGenerate(\n    options: LanguageModelV3CallOptions,\n  ): Promise<Awaited<ReturnType<LanguageModelV3['doGenerate']>>> {\n    const providerOptions = options.providerOptions || {};\n    const openrouterOptions = providerOptions.openrouter || {};\n\n    const args = {\n      ...this.getArgs(options),\n      ...openrouterOptions,\n    };\n\n    const { value: response, responseHeaders } = await postJsonToApi({\n      url: this.config.url({\n        path: '/completions',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body: args,\n      failedResponseHandler: openrouterFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        OpenRouterCompletionChunkSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    if ('error' in response) {\n      const errorData = response.error as { message: string; code?: string };\n      throw new APICallError({\n        message: errorData.message,\n        url: this.config.url({\n          path: '/completions',\n          modelId: this.modelId,\n        }),\n        requestBodyValues: args,\n        statusCode: 200,\n        responseHeaders,\n        data: errorData,\n      });\n    }\n\n    const choice = response.choices[0];\n\n    if (!choice) {\n      throw new NoContentGeneratedError({\n        message: 'No choice in OpenRouter completion response',\n      });\n    }\n\n    return {\n      content: [\n        {\n          type: 'text',\n          text: choice.text ?? '',\n        },\n      ],\n      finishReason: mapOpenRouterFinishReason(choice.finish_reason),\n      usage: {\n        inputTokens: {\n          total: response.usage?.prompt_tokens ?? 0,\n          noCache: undefined,\n          cacheRead:\n            response.usage?.prompt_tokens_details?.cached_tokens ?? undefined,\n          cacheWrite: undefined,\n        },\n        outputTokens: {\n          total: response.usage?.completion_tokens ?? 0,\n          text: undefined,\n          reasoning:\n            response.usage?.completion_tokens_details?.reasoning_tokens ??\n            undefined,\n        },\n        raw: (response.usage as JSONObject) ?? undefined,\n      },\n      warnings: [],\n      providerMetadata: {\n        openrouter: OpenRouterProviderMetadataSchema.parse({\n          provider: response.provider ?? '',\n          usage: {\n            promptTokens: response.usage?.prompt_tokens ?? 0,\n            completionTokens: response.usage?.completion_tokens ?? 0,\n            totalTokens:\n              (response.usage?.prompt_tokens ?? 0) +\n              (response.usage?.completion_tokens ?? 0),\n            ...(response.usage?.cost != null\n              ? { cost: response.usage.cost }\n              : {}),\n            ...(response.usage?.prompt_tokens_details?.cached_tokens != null\n              ? {\n                  promptTokensDetails: {\n                    cachedTokens:\n                      response.usage.prompt_tokens_details.cached_tokens,\n                  },\n                }\n              : {}),\n            ...(response.usage?.completion_tokens_details?.reasoning_tokens !=\n            null\n              ? {\n                  completionTokensDetails: {\n                    reasoningTokens:\n                      response.usage.completion_tokens_details.reasoning_tokens,\n                  },\n                }\n              : {}),\n            ...(response.usage?.cost_details?.upstream_inference_cost != null\n              ? {\n                  costDetails: {\n                    upstreamInferenceCost:\n                      response.usage.cost_details.upstream_inference_cost,\n                  },\n                }\n              : {}),\n          },\n        }),\n      },\n      response: {\n        headers: responseHeaders,\n      },\n    };\n  }\n\n  async doStream(\n    options: LanguageModelV3CallOptions,\n  ): Promise<Awaited<ReturnType<LanguageModelV3['doStream']>>> {\n    const providerOptions = options.providerOptions || {};\n    const openrouterOptions = providerOptions.openrouter || {};\n\n    const args = {\n      ...this.getArgs(options),\n      ...openrouterOptions,\n    };\n\n    const { value: response, responseHeaders } = await postJsonToApi({\n      url: this.config.url({\n        path: '/completions',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body: {\n        ...args,\n        stream: true,\n\n        // only include stream_options when in strict compatibility mode:\n        stream_options:\n          this.config.compatibility === 'strict'\n            ? { include_usage: true }\n            : undefined,\n      },\n      failedResponseHandler: openrouterFailedResponseHandler,\n      successfulResponseHandler: createEventSourceResponseHandler(\n        OpenRouterCompletionChunkSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    let finishReason: LanguageModelV3FinishReason = createFinishReason('other');\n    const usage: LanguageModelV3Usage = {\n      inputTokens: {\n        total: undefined,\n        noCache: undefined,\n        cacheRead: undefined,\n        cacheWrite: undefined,\n      },\n      outputTokens: {\n        total: undefined,\n        text: undefined,\n        reasoning: undefined,\n      },\n      raw: undefined,\n    };\n\n    const openrouterUsage: Partial<OpenRouterUsageAccounting> = {};\n    let provider: string | undefined;\n\n    // Track raw usage from the API response for usage.raw\n    let rawUsage: JSONObject | undefined;\n\n    return {\n      stream: response.pipeThrough(\n        new TransformStream<\n          ParseResult<z.infer<typeof OpenRouterCompletionChunkSchema>>,\n          LanguageModelV3StreamPart\n        >({\n          transform(chunk, controller) {\n            // Emit raw chunk if requested (before anything else)\n            if (options.includeRawChunks) {\n              controller.enqueue({ type: 'raw', rawValue: chunk.rawValue });\n            }\n\n            // handle failed chunk parsing / validation:\n            if (!chunk.success) {\n              finishReason = createFinishReason('error');\n              controller.enqueue({ type: 'error', error: chunk.error });\n              return;\n            }\n\n            const value = chunk.value;\n\n            // handle error chunks:\n            if ('error' in value) {\n              finishReason = createFinishReason('error');\n              controller.enqueue({ type: 'error', error: value.error });\n              return;\n            }\n\n            if (value.provider) {\n              provider = value.provider;\n            }\n\n            if (value.usage != null) {\n              usage.inputTokens.total = value.usage.prompt_tokens;\n              usage.outputTokens.total = value.usage.completion_tokens;\n\n              // Store raw usage from the API response (cast to JSONObject since schema uses passthrough)\n              rawUsage = value.usage as JSONObject;\n\n              // Collect OpenRouter specific usage information\n              openrouterUsage.promptTokens = value.usage.prompt_tokens;\n\n              if (value.usage.prompt_tokens_details) {\n                const cachedInputTokens =\n                  value.usage.prompt_tokens_details.cached_tokens ?? 0;\n\n                usage.inputTokens.cacheRead = cachedInputTokens;\n                openrouterUsage.promptTokensDetails = {\n                  cachedTokens: cachedInputTokens,\n                };\n              }\n\n              openrouterUsage.completionTokens = value.usage.completion_tokens;\n              if (value.usage.completion_tokens_details) {\n                const reasoningTokens =\n                  value.usage.completion_tokens_details.reasoning_tokens ?? 0;\n\n                usage.outputTokens.reasoning = reasoningTokens;\n                openrouterUsage.completionTokensDetails = {\n                  reasoningTokens,\n                };\n              }\n\n              if (value.usage.cost != null) {\n                openrouterUsage.cost = value.usage.cost;\n              }\n              openrouterUsage.totalTokens = value.usage.total_tokens;\n              const upstreamInferenceCost =\n                value.usage.cost_details?.upstream_inference_cost;\n              if (upstreamInferenceCost != null) {\n                openrouterUsage.costDetails = {\n                  upstreamInferenceCost,\n                };\n              }\n            }\n\n            const choice = value.choices[0];\n\n            if (choice?.finish_reason != null) {\n              finishReason = mapOpenRouterFinishReason(choice.finish_reason);\n            }\n\n            if (choice?.text != null) {\n              controller.enqueue({\n                type: 'text-delta',\n                delta: choice.text,\n                id: generateId(),\n              });\n            }\n          },\n\n          flush(controller) {\n            // Set raw usage before emitting finish event\n            usage.raw = rawUsage;\n\n            const openrouterMetadata: {\n              usage: Partial<OpenRouterUsageAccounting>;\n              provider?: string;\n            } = {\n              usage: openrouterUsage,\n            };\n\n            // Only include provider if it's actually set\n            if (provider !== undefined) {\n              openrouterMetadata.provider = provider;\n            }\n\n            controller.enqueue({\n              type: 'finish',\n              finishReason,\n              usage,\n              providerMetadata: {\n                openrouter: openrouterMetadata,\n              },\n            });\n          },\n        }),\n      ),\n      response: {\n        headers: responseHeaders,\n      },\n    };\n  }\n}\n","import { z } from 'zod/v4';\n\nconst openrouterEmbeddingUsageSchema = z.object({\n  prompt_tokens: z.number(),\n  total_tokens: z.number(),\n  cost: z.number().optional(),\n});\n\nconst openrouterEmbeddingDataSchema = z.object({\n  object: z.literal('embedding'),\n  embedding: z.array(z.number()),\n  index: z.number().optional(),\n});\n\nexport const OpenRouterEmbeddingResponseSchema = z.object({\n  id: z.string().optional(),\n  object: z.literal('list'),\n  data: z.array(openrouterEmbeddingDataSchema),\n  model: z.string(),\n  provider: z.string().optional(),\n  usage: openrouterEmbeddingUsageSchema.optional(),\n});\n\nexport type OpenRouterEmbeddingResponse = z.infer<\n  typeof OpenRouterEmbeddingResponseSchema\n>;\n","import type {\n  EmbeddingModelV3,\n  SharedV3Headers,\n  SharedV3ProviderMetadata,\n} from '@ai-sdk/provider';\nimport type {\n  OpenRouterEmbeddingModelId,\n  OpenRouterEmbeddingSettings,\n} from '../types/openrouter-embedding-settings';\n\nimport {\n  combineHeaders,\n  createJsonResponseHandler,\n  postJsonToApi,\n} from '@ai-sdk/provider-utils';\nimport { openrouterFailedResponseHandler } from '../schemas/error-response';\nimport { OpenRouterProviderMetadataSchema } from '../schemas/provider-metadata';\nimport { OpenRouterEmbeddingResponseSchema } from './schemas';\n\ntype OpenRouterEmbeddingConfig = {\n  provider: string;\n  headers: () => Record<string, string | undefined>;\n  url: (options: { modelId: string; path: string }) => string;\n  fetch?: typeof fetch;\n  extraBody?: Record<string, unknown>;\n};\n\nexport class OpenRouterEmbeddingModel implements EmbeddingModelV3 {\n  readonly specificationVersion = 'v3' as const;\n  readonly provider = 'openrouter';\n  readonly modelId: OpenRouterEmbeddingModelId;\n  readonly settings: OpenRouterEmbeddingSettings;\n  readonly maxEmbeddingsPerCall = undefined;\n  readonly supportsParallelCalls = true;\n\n  private readonly config: OpenRouterEmbeddingConfig;\n\n  constructor(\n    modelId: OpenRouterEmbeddingModelId,\n    settings: OpenRouterEmbeddingSettings,\n    config: OpenRouterEmbeddingConfig,\n  ) {\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n  }\n\n  async doEmbed(options: {\n    values: Array<string>;\n    abortSignal?: AbortSignal;\n    headers?: Record<string, string | undefined>;\n  }): Promise<{\n    embeddings: Array<Array<number>>;\n    usage?: { tokens: number };\n    providerMetadata?: SharedV3ProviderMetadata;\n    response?: {\n      headers?: SharedV3Headers;\n      body?: unknown;\n    };\n    warnings: Array<import('@ai-sdk/provider').SharedV3Warning>;\n  }> {\n    const { values, abortSignal, headers } = options;\n\n    const args = {\n      model: this.modelId,\n      input: values,\n      user: this.settings.user,\n      provider: this.settings.provider,\n      ...this.config.extraBody,\n      ...this.settings.extraBody,\n    };\n\n    const { value: responseValue, responseHeaders } = await postJsonToApi({\n      url: this.config.url({\n        path: '/embeddings',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), headers),\n      body: args,\n      failedResponseHandler: openrouterFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        OpenRouterEmbeddingResponseSchema,\n      ),\n      abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    return {\n      embeddings: responseValue.data.map((item) => item.embedding),\n      usage: responseValue.usage\n        ? { tokens: responseValue.usage.prompt_tokens }\n        : undefined,\n      providerMetadata: {\n        openrouter: OpenRouterProviderMetadataSchema.parse({\n          provider: responseValue.provider ?? '',\n          usage: {\n            promptTokens: responseValue.usage?.prompt_tokens ?? 0,\n            completionTokens: 0,\n            totalTokens: responseValue.usage?.total_tokens ?? 0,\n            ...(responseValue.usage?.cost != null\n              ? { cost: responseValue.usage.cost }\n              : {}),\n          },\n        }),\n      },\n      response: {\n        headers: responseHeaders,\n        body: responseValue,\n      },\n      warnings: [],\n    };\n  }\n}\n","import { z } from 'zod/v4';\n\nexport const OpenRouterImageResponseSchema = z\n  .object({\n    id: z.string().optional(),\n    object: z.string().optional(),\n    created: z.number().optional(),\n    model: z.string(),\n    choices: z.array(\n      z\n        .object({\n          index: z.number(),\n          message: z\n            .object({\n              role: z.string(),\n              content: z.string().nullable().optional(),\n              images: z\n                .array(\n                  z\n                    .object({\n                      type: z.literal('image_url'),\n                      image_url: z.object({\n                        url: z.string(),\n                      }),\n                    })\n                    .passthrough(),\n                )\n                .optional(),\n            })\n            .passthrough(),\n          finish_reason: z.string().nullable().optional(),\n        })\n        .passthrough(),\n    ),\n    usage: z\n      .object({\n        prompt_tokens: z.number(),\n        completion_tokens: z.number(),\n        total_tokens: z.number(),\n      })\n      .passthrough()\n      .optional(),\n  })\n  .passthrough();\n\nexport type OpenRouterImageResponse = z.infer<\n  typeof OpenRouterImageResponseSchema\n>;\n","import type {\n  ImageModelV3,\n  ImageModelV3CallOptions,\n  ImageModelV3ProviderMetadata,\n  ImageModelV3Usage,\n  SharedV3Warning,\n} from '@ai-sdk/provider';\nimport type {\n  OpenRouterImageModelId,\n  OpenRouterImageSettings,\n} from '../types/openrouter-image-settings';\n\nimport {\n  NoContentGeneratedError,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport {\n  combineHeaders,\n  createJsonResponseHandler,\n  postJsonToApi,\n} from '@ai-sdk/provider-utils';\nimport { getBase64FromDataUrl } from '../chat/file-url-utils';\nimport { openrouterFailedResponseHandler } from '../schemas/error-response';\nimport { OpenRouterImageResponseSchema } from './schemas';\n\ntype OpenRouterImageConfig = {\n  provider: string;\n  headers: () => Record<string, string | undefined>;\n  url: (options: { modelId: string; path: string }) => string;\n  fetch?: typeof fetch;\n  extraBody?: Record<string, unknown>;\n};\n\nexport class OpenRouterImageModel implements ImageModelV3 {\n  readonly specificationVersion = 'v3' as const;\n  readonly provider = 'openrouter';\n  readonly modelId: OpenRouterImageModelId;\n  readonly settings: OpenRouterImageSettings;\n  readonly maxImagesPerCall = 1;\n\n  private readonly config: OpenRouterImageConfig;\n\n  constructor(\n    modelId: OpenRouterImageModelId,\n    settings: OpenRouterImageSettings,\n    config: OpenRouterImageConfig,\n  ) {\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n  }\n\n  async doGenerate(options: ImageModelV3CallOptions): Promise<{\n    images: Array<string>;\n    warnings: Array<SharedV3Warning>;\n    providerMetadata?: ImageModelV3ProviderMetadata;\n    response: {\n      timestamp: Date;\n      modelId: string;\n      headers: Record<string, string> | undefined;\n    };\n    usage?: ImageModelV3Usage;\n  }> {\n    const {\n      prompt,\n      n,\n      size,\n      aspectRatio,\n      seed,\n      files,\n      mask,\n      abortSignal,\n      headers,\n      providerOptions,\n    } = options;\n\n    const openrouterOptions =\n      (providerOptions?.openrouter as Record<string, unknown>) || {};\n\n    const warnings: SharedV3Warning[] = [];\n\n    if (files !== undefined && files.length > 0) {\n      throw new UnsupportedFunctionalityError({\n        functionality: 'image editing (files parameter)',\n      });\n    }\n\n    if (mask !== undefined) {\n      throw new UnsupportedFunctionalityError({\n        functionality: 'image inpainting (mask parameter)',\n      });\n    }\n\n    if (n > 1) {\n      warnings.push({\n        type: 'unsupported',\n        feature: 'n > 1',\n        details: `OpenRouter image generation returns 1 image per call. Requested ${n} images.`,\n      });\n    }\n\n    if (size !== undefined) {\n      warnings.push({\n        type: 'unsupported',\n        feature: 'size',\n        details:\n          'Use aspectRatio instead. Size parameter is not supported by OpenRouter image generation.',\n      });\n    }\n\n    const imageConfig: Record<string, string> | undefined =\n      aspectRatio !== undefined ? { aspect_ratio: aspectRatio } : undefined;\n\n    const body: Record<string, unknown> = {\n      model: this.modelId,\n      messages: [\n        {\n          role: 'user',\n          content: prompt ?? '',\n        },\n      ],\n      modalities: ['image', 'text'],\n      ...(imageConfig !== undefined && { image_config: imageConfig }),\n      ...(seed !== undefined && { seed }),\n      ...(this.settings.user !== undefined && { user: this.settings.user }),\n      ...(this.settings.provider !== undefined && {\n        provider: this.settings.provider,\n      }),\n      ...this.config.extraBody,\n      ...this.settings.extraBody,\n      ...openrouterOptions,\n    };\n\n    const { value: responseValue, responseHeaders } = await postJsonToApi({\n      url: this.config.url({\n        path: '/chat/completions',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), headers),\n      body,\n      failedResponseHandler: openrouterFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        OpenRouterImageResponseSchema,\n      ),\n      abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const choice = responseValue.choices[0];\n\n    if (!choice) {\n      throw new NoContentGeneratedError({\n        message: 'No choice in response',\n      });\n    }\n\n    const images: string[] = [];\n\n    if (choice.message?.images) {\n      for (const image of choice.message.images) {\n        const dataUrl = image.image_url.url;\n        images.push(getBase64FromDataUrl(dataUrl));\n      }\n    }\n\n    const usage: ImageModelV3Usage | undefined = responseValue.usage\n      ? {\n          inputTokens: responseValue.usage.prompt_tokens,\n          outputTokens: responseValue.usage.completion_tokens,\n          totalTokens: responseValue.usage.total_tokens,\n        }\n      : undefined;\n\n    return {\n      images,\n      warnings,\n      response: {\n        timestamp: new Date(),\n        modelId: responseValue.model,\n        headers: responseHeaders as Record<string, string> | undefined,\n      },\n      usage,\n    };\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACIA,IAAM,SAAS;AACf,IAAM,SAAS,OAAO,IAAI,MAAM;AALhC,IAAA;AAAA,IAAA;AAWO,IAAM,aAAN,MAAM,qBAAmB,KAAA,OACZ,KAAA,QADY,IAAM;;;;;;;;;EAgBpC,YAAY;IACV,MAAAA;IACA;IACA;EACF,GAIG;AACD,UAAM,OAAO;AAxBf,SAAkB,EAAA,IAAU;AA0B1B,SAAK,OAAOA;AACZ,SAAK,QAAQ;EACf;;;;;;EAOA,OAAO,WAAW,OAAqC;AACrD,WAAO,YAAW,UAAU,OAAO,MAAM;EAC3C;EAEA,OAAiB,UAAU,OAAgBC,WAAyB;AAClE,UAAM,eAAe,OAAO,IAAIA,SAAM;AACtC,WACE,SAAS,QACT,OAAO,UAAU,YACjB,gBAAgB,SAChB,OAAO,MAAM,YAAY,MAAM,aAC/B,MAAM,YAAY,MAAM;EAE5B;AACF;AC3DA,IAAM,OAAO;AACb,IAAMA,UAAS,mBAAmB,IAAI;AACtC,IAAMC,UAAS,OAAO,IAAID,OAAM;AAJhC,IAAAE;AAAA,IAAAC;AAMO,IAAM,eAAN,eAA2BA,MAAA,YACdD,MAAAD,SADcE,KAAW;EAa3C,YAAY;IACV;IACA;IACA;IACA;IACA;IACA;IACA;IACA,cAAc,cAAc,SACzB,eAAe;IACd,eAAe;IACf,eAAe;IACf,cAAc;;IAClB;EACF,GAUG;AACD,UAAM,EAAE,MAAM,SAAS,MAAM,CAAC;AArChC,SAAkBD,GAAAA,IAAU;AAuC1B,SAAK,MAAM;AACX,SAAK,oBAAoB;AACzB,SAAK,aAAa;AAClB,SAAK,kBAAkB;AACvB,SAAK,eAAe;AACpB,SAAK,cAAc;AACnB,SAAK,OAAO;EACd;EAEA,OAAO,WAAW,OAAuC;AACvD,WAAO,WAAW,UAAU,OAAOF,OAAM;EAC3C;AACF;ACxDA,IAAMD,QAAO;AACb,IAAMC,UAAS,mBAAmBD,KAAI;AACtC,IAAME,UAAS,OAAO,IAAID,OAAM;AAJhC,IAAAE;AAAA,IAAAC;AAMO,IAAM,yBAAN,eAAqCA,MAAA,YACxBD,MAAAD,SADwBE,KAAW;;EAGrD,YAAY,EAAE,UAAU,sBAAsB,IAA0B,CAAC,GAAG;AAC1E,UAAM,EAAE,MAAAJ,OAAM,QAAQ,CAAC;AAHzB,SAAkBG,GAAAA,IAAU;EAI5B;EAEA,OAAO,WAAW,OAAiD;AACjE,WAAO,WAAW,UAAU,OAAOF,OAAM;EAC3C;AACF;AChBO,SAAS,gBAAgB,OAA4B;AAC1D,MAAI,SAAS,MAAM;AACjB,WAAO;EACT;AAEA,MAAI,OAAO,UAAU,UAAU;AAC7B,WAAO;EACT;AAEA,MAAI,iBAAiB,OAAO;AAC1B,WAAO,MAAM;EACf;AAEA,SAAO,KAAK,UAAU,KAAK;AAC7B;ACZA,IAAMD,QAAO;AACb,IAAMC,UAAS,mBAAmBD,KAAI;AACtC,IAAME,UAAS,OAAO,IAAID,OAAM;AAJhC,IAAAE;AAAA,IAAAC;AASO,IAAM,uBAAN,eAAmCA,MAAA,YACtBD,MAAAD,SADsBE,KAAW;EAKnD,YAAY;IACV;IACA;IACA;EACF,GAIG;AACD,UAAM,EAAE,MAAAJ,OAAM,SAAS,MAAM,CAAC;AAbhC,SAAkBG,GAAAA,IAAU;AAe1B,SAAK,WAAW;EAClB;EAEA,OAAO,WAAW,OAA+C;AAC/D,WAAO,WAAW,UAAU,OAAOF,OAAM;EAC3C;AACF;AC7BA,IAAMD,QAAO;AACb,IAAMC,UAAS,mBAAmBD,KAAI;AACtC,IAAME,UAAS,OAAO,IAAID,OAAM;AAJhC,IAAAE;AAAA,IAAAC;AAUO,IAAM,qBAAN,eAAiCA,MAAA,YACpBD,MAAAD,SADoBE,KAAW;EAKjD,YAAY;IACV;IACA;IACA;EACF,GAIG;AACD,UAAM,EAAE,MAAAJ,OAAM,SAAS,mBAAmB,OAAO,IAAI,MAAM,CAAC;AAb9D,SAAkBG,GAAAA,IAAU;AAe1B,SAAK,SAAS;EAChB;EAEA,OAAO,WAAW,OAA6C;AAC7D,WAAO,WAAW,UAAU,OAAOF,OAAM;EAC3C;AACF;AC9BA,IAAMD,QAAO;AACb,IAAMC,UAAS,mBAAmBD,KAAI;AACtC,IAAME,UAAS,OAAO,IAAID,OAAM;AAJhC,IAAAE;AAAA,IAAAC;AAUO,IAAM,2BAAN,eAAuCA,MAAA,YAC1BD,MAAAD,SAD0BE,KAAW;EAKvD,YAAY;IACV;IACA,UAAU,0BAA0B,KAAK,UAAU,IAAI,CAAC;EAC1D,GAGG;AACD,UAAM,EAAE,MAAAJ,OAAM,QAAQ,CAAC;AAXzB,SAAkBG,GAAAA,IAAU;AAa1B,SAAK,OAAO;EACd;EAEA,OAAO,WAAW,OAAmD;AACnE,WAAO,WAAW,UAAU,OAAOF,OAAM;EAC3C;AACF;AC3BA,IAAMD,QAAO;AACb,IAAMC,UAAS,mBAAmBD,KAAI;AACtC,IAAME,UAAS,OAAO,IAAID,OAAM;AALhC,IAAAE;AAAA,IAAAC;AAOO,IAAM,iBAAN,eAA6BA,MAAA,YAChBD,MAAAD,SADgBE,KAAW;EAK7C,YAAY,EAAE,MAAM,MAAM,GAAqC;AAC7D,UAAM;MACJ,MAAAJ;MACA,SACE,8BACS,IAAI;iBACK,gBAAgB,KAAK,CAAC;MAC1C;IACF,CAAC;AAZH,SAAkBG,GAAAA,IAAU;AAc1B,SAAK,OAAO;EACd;EAEA,OAAO,WAAW,OAAyC;AACzD,WAAO,WAAW,UAAU,OAAOF,OAAM;EAC3C;AACF;AC1BA,IAAMD,QAAO;AACb,IAAMC,UAAS,mBAAmBD,KAAI;AACtC,IAAME,UAAS,OAAO,IAAID,OAAM;AAJhC,IAAAE;AAAA,IAAAC;AAMO,IAAM,kBAAN,eAA8BA,MAAA,YACjBD,MAAAD,SADiBE,KAAW;;EAG9C,YAAY,EAAE,QAAQ,GAAwB;AAC5C,UAAM,EAAE,MAAAJ,OAAM,QAAQ,CAAC;AAHzB,SAAkBG,GAAAA,IAAU;EAI5B;EAEA,OAAO,WAAW,OAA0C;AAC1D,WAAO,WAAW,UAAU,OAAOF,OAAM;EAC3C;AACF;ACdA,IAAMD,QAAO;AACb,IAAMC,UAAS,mBAAmBD,KAAI;AACtC,IAAME,UAAS,OAAO,IAAID,OAAM;AAJhC,IAAAE;AAAA,IAAAC;AAMO,IAAM,mBAAN,eAA+BA,MAAA,YAClBD,MAAAD,SADkBE,KAAW;;EAG/C,YAAY,EAAE,QAAQ,GAAwB;AAC5C,UAAM,EAAE,MAAAJ,OAAM,QAAQ,CAAC;AAHzB,SAAkBG,GAAAA,IAAU;EAI5B;EAEA,OAAO,WAAW,OAA2C;AAC3D,WAAO,WAAW,UAAU,OAAOF,OAAM;EAC3C;AACF;ACdA,IAAMD,QAAO;AACb,IAAMC,WAAS,mBAAmBD,KAAI;AACtC,IAAME,WAAS,OAAO,IAAID,QAAM;AAJhC,IAAAE;AAAA,IAAAC;AASO,IAAM,0BAAN,eAAsCA,OAAA,YACzBD,OAAAD,UADyBE,MAAW;;EAGtD,YAAY;IACV,UAAU;EACZ,IAA0B,CAAC,GAAG;AAC5B,UAAM,EAAE,MAAAJ,OAAM,QAAQ,CAAC;AALzB,SAAkBG,IAAAA,IAAU;EAM5B;EAEA,OAAO,WAAW,OAAkD;AAClE,WAAO,WAAW,UAAU,OAAOF,QAAM;EAC3C;AACF;ACnBA,IAAMD,SAAO;AACb,IAAMC,WAAS,mBAAmBD,MAAI;AACtC,IAAME,WAAS,OAAO,IAAID,QAAM;AAJhC,IAAAE;AAAA,IAAAC;AAMO,IAAM,mBAAN,eAA+BA,OAAA,YAClBD,OAAAD,UADkBE,MAAW;EAY/C,YAAY;IACV,YAAYJ;IACZ;IACA;IACA,UAAU,WAAW,SAAS,KAAK,OAAO;EAC5C,GAWG;AACD,UAAM,EAAE,MAAM,WAAW,QAAQ,CAAC;AA5BpC,SAAkBG,IAAAA,IAAU;AA8B1B,SAAK,UAAU;AACf,SAAK,YAAY;EACnB;EAEA,OAAO,WAAW,OAA2C;AAC3D,WAAO,WAAW,UAAU,OAAOF,QAAM;EAC3C;AACF;AC1CA,IAAMD,SAAO;AACb,IAAMC,WAAS,mBAAmBD,MAAI;AACtC,IAAME,WAAS,OAAO,IAAID,QAAM;AAJhC,IAAAE;AAAA,IAAAC;AAMO,IAAM,qCAAN,eAAiDA,OAAA,YACpCD,OAAAD,UADoCE,MAAW;EAQjE,YAAY,SAKT;AACD,UAAM;MACJ,MAAAJ;MACA,SACE,oDACO,QAAQ,QAAQ,WAAW,QAAQ,OAAO,0BAC9C,QAAQ,oBAAoB,yBAAyB,QAAQ,OAAO,MAAM;IACjF,CAAC;AAnBH,SAAkBG,IAAAA,IAAU;AAqB1B,SAAK,WAAW,QAAQ;AACxB,SAAK,UAAU,QAAQ;AACvB,SAAK,uBAAuB,QAAQ;AACpC,SAAK,SAAS,QAAQ;EACxB;EAEA,OAAO,WACL,OAC6C;AAC7C,WAAO,WAAW,UAAU,OAAOF,QAAM;EAC3C;AACF;ACpCA,IAAMD,SAAO;AACb,IAAMC,WAAS,mBAAmBD,MAAI;AACtC,IAAME,WAAS,OAAO,IAAID,QAAM;AALhC,IAAAE;AAAA,IAAAC;AAOO,IAAM,sBAAN,MAAM,8BAA4BA,OAAA,YACrBD,OAAAD,UADqBE,MAAW;EAKlD,YAAY,EAAE,OAAO,MAAM,GAAuC;AAChE,UAAM;MACJ,MAAAJ;MACA,SACE,kCACU,KAAK,UAAU,KAAK,CAAC;iBACb,gBAAgB,KAAK,CAAC;MAC1C;IACF,CAAC;AAZH,SAAkBG,IAAAA,IAAU;AAc1B,SAAK,QAAQ;EACf;EAEA,OAAO,WAAW,OAA8C;AAC9D,WAAO,WAAW,UAAU,OAAOF,QAAM;EAC3C;;;;;;;;;;;EAYA,OAAO,KAAK;IACV;IACA;EACF,GAGwB;AACtB,WAAO,qBAAoB,WAAW,KAAK,KAAK,MAAM,UAAU,QAC5D,QACA,IAAI,qBAAoB,EAAE,OAAO,MAAM,CAAC;EAC9C;AACF;AChDA,IAAMD,SAAO;AACb,IAAMC,WAAS,mBAAmBD,MAAI;AACtC,IAAME,WAAS,OAAO,IAAID,QAAM;AAJhC,IAAAE;AAAA,IAAAC;AAMO,IAAM,gCAAN,eAA4CA,OAAA,YAC/BD,OAAAD,UAD+BE,MAAW;EAK5D,YAAY;IACV;IACA,UAAU,IAAI,aAAa;EAC7B,GAGG;AACD,UAAM,EAAE,MAAAJ,QAAM,QAAQ,CAAC;AAXzB,SAAkBG,IAAAA,IAAU;AAY1B,SAAK,gBAAgB;EACvB;EAEA,OAAO,WAAW,OAAwD;AACxE,WAAO,WAAW,UAAU,OAAOF,QAAM;EAC3C;AACF;;;AgCtBA,SAAoB;AGHpB,gBAAsC;AEAtC,IAAAI,aAAmD;AWAnD,IAAAA,aAKO;;;AkCMA,IAAM,aAAN,cAAyB,MAAM;EAqBpC,YACE,SACA,SACA;AACA,UAAM,OAAO,GACb,KAAK,OAAO,cACZ,KAAK,OAAO,QAAQ,MACpB,KAAK,QAAQ,QAAQ,OACrB,KAAK,QAAQ,QAAQ,OACrB,KAAK,OAAO,QAAQ;EACtB;AACF;ACnCA,SAAS,KAAK,MAAe;AAE7B;AAcO,SAAS,aAAa,WAA+C;AAC1E,MAAI,OAAO,aAAc;AACvB,UAAM,IAAI;MACR;IAAA;AAIJ,QAAM,EAAC,UAAU,MAAM,UAAU,MAAM,UAAU,MAAM,UAAA,IAAa;AAEpE,MAAI,iBAAiB,IAEjB,eAAe,MACf,IACA,OAAO,IACP,YAAY;AAEhB,WAAS,KAAK,UAAkB;AAE9B,UAAM,QAAQ,eAAe,SAAS,QAAQ,iBAAiB,EAAE,IAAI,UAI/D,CAAC,UAAU,UAAU,IAAI,WAAW,GAAG,cAAc,GAAG,KAAK,EAAE;AAErE,eAAW,QAAQ;AACjB,gBAAU,IAAI;AAGhB,qBAAiB,YACjB,eAAe;EACjB;AAEA,WAAS,UAAU,MAAc;AAE/B,QAAI,SAAS,IAAI;AACf,oBAAA;AACA;IACF;AAGA,QAAI,KAAK,WAAW,GAAG,GAAG;AACpB,mBACF,UAAU,KAAK,MAAM,KAAK,WAAW,IAAI,IAAI,IAAI,CAAC,CAAC;AAErD;IACF;AAGA,UAAM,sBAAsB,KAAK,QAAQ,GAAG;AAC5C,QAAI,wBAAwB,IAAI;AAG9B,YAAM,QAAQ,KAAK,MAAM,GAAG,mBAAmB,GAKzC,SAAS,KAAK,sBAAsB,CAAC,MAAM,MAAM,IAAI,GACrD,QAAQ,KAAK,MAAM,sBAAsB,MAAM;AAErD,mBAAa,OAAO,OAAO,IAAI;AAC/B;IACF;AAMA,iBAAa,MAAM,IAAI,IAAI;EAC7B;AAEA,WAAS,aAAa,OAAe,OAAe,MAAc;AAEhE,YAAQ,OAAA;MACN,KAAK;AAEH,oBAAY;AACZ;MACF,KAAK;AAGH,eAAO,GAAG,IAAI,GAAG,KAAK;;AACtB;MACF,KAAK;AAGH,aAAK,MAAM,SAAS,IAAI,IAAI,SAAY;AACxC;MACF,KAAK;AAIC,gBAAQ,KAAK,KAAK,IACpB,QAAQ,SAAS,OAAO,EAAE,CAAC,IAE3B;UACE,IAAI,WAAW,6BAA6B,KAAK,KAAK;YACpD,MAAM;YACN;YACA;UAAA,CACD;QAAA;AAGL;MACF;AAEE;UACE,IAAI;YACF,kBAAkB,MAAM,SAAS,KAAK,GAAG,MAAM,MAAM,GAAG,EAAE,CAAC,WAAM,KAAK;YACtE,EAAC,MAAM,iBAAiB,OAAO,OAAO,KAAA;UAAI;QAC5C;AAEF;IAAA;EAEN;AAEA,WAAS,gBAAgB;AACA,SAAK,SAAS,KAEnC,QAAQ;MACN;MACA,OAAO,aAAa;;;MAGpB,MAAM,KAAK,SAAS;CAAI,IAAI,KAAK,MAAM,GAAG,EAAE,IAAI;IAAA,CACjD,GAIH,KAAK,QACL,OAAO,IACP,YAAY;EACd;AAEA,WAAS,MAAM,UAA+B,CAAA,GAAI;AAC5C,sBAAkB,QAAQ,WAC5B,UAAU,cAAc,GAG1B,eAAe,MACf,KAAK,QACL,OAAO,IACP,YAAY,IACZ,iBAAiB;EACnB;AAEA,SAAO,EAAC,MAAM,MAAA;AAChB;AASA,SAAS,WAAW,OAA8D;AAOhF,QAAM,QAAuB,CAAA;AAC7B,MAAI,iBAAiB,IACjB,cAAc;AAElB,SAAO,cAAc,MAAM,UAAQ;AAEjC,UAAM,UAAU,MAAM,QAAQ,MAAM,WAAW,GACzC,UAAU,MAAM,QAAQ;GAAM,WAAW;AAG/C,QAAI,UAAU;AAiBd,QAhBI,YAAY,MAAM,YAAY,KAEhC,UAAU,KAAK,IAAI,SAAS,OAAO,IAC1B,YAAY,KAGjB,YAAY,MAAM,SAAS,IAC7B,UAAU,KAEV,UAAU,UAEH,YAAY,OACrB,UAAU,UAIR,YAAY,IAAI;AAElB,uBAAiB,MAAM,MAAM,WAAW;AACxC;IACF,OAAO;AACL,YAAM,OAAO,MAAM,MAAM,aAAa,OAAO;AAC7C,YAAM,KAAK,IAAI,GAGf,cAAc,UAAU,GACpB,MAAM,cAAc,CAAC,MAAM,QAAQ,MAAM,WAAW,MAAM;KAC5D;IAEJ;EACF;AAEA,SAAO,CAAC,OAAO,cAAc;AAC/B;;;AC/KO,IAAM,0BAAN,cAAsC,gBAA4C;EACvF,YAAY,EAAC,SAAS,SAAS,UAAA,IAA4B,CAAA,GAAI;AAC7D,QAAI;AAEJ,UAAM;MACJ,MAAM,YAAY;AAChB,iBAAS,aAAa;UACpB,SAAS,CAAC,UAAU;AAClB,uBAAW,QAAQ,KAAK;UAC1B;UACA,QAAQ,OAAO;AACT,wBAAY,cACd,WAAW,MAAM,KAAK,IACb,OAAO,WAAY,cAC5B,QAAQ,KAAK;UAIjB;UACA;UACA;QAAA,CACD;MACH;MACA,UAAU,OAAO;AACf,eAAO,KAAK,KAAK;MACnB;IAAA,CACD;EACH;AACF;;;AlFpFO,SAAS,kBACX,SACiC;AACpC,SAAO,QAAQ;IACb,CAAC,iBAAiB,mBAAoB,kCACjC,kBACC,kBAAA,OAAA,iBAAkB,CAAC;IAEzB,CAAC;EACH;AACF;AKJO,SAAS,uBAAuB,UAAoB;AACzD,SAAO,OAAO,YAAoB,CAAC,GAAG,SAAS,OAAO,CAAC;AACzD;ACLA,IAAM,EAAE,MAAM,KAAK,IAAI;AAQhB,SAAS,0BAA0B,OAA2B;AACnE,MAAI,eAAe;AAInB,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,oBAAgB,OAAO,cAAc,MAAM,CAAC,CAAC;EAC/C;AAEA,SAAO,KAAK,YAAY;AAC1B;AGnBA,IAAMC,SAAO;AACb,IAAMC,WAAS,mBAAmBD,MAAI;AACtC,IAAME,WAAS,OAAO,IAAID,QAAM;AAJhC,IAAAE;AAAA,IAAAC;AAMO,IAAM,gBAAN,eAA4BA,OAAA,YACfD,OAAAD,UADeE,MAAW;EAO5C,YAAY;IACV;IACA;IACA;IACA;IACA,UAAU,SAAS,OACf,sBAAsB,GAAG,KAAK,UAAU,IAAI,UAAU,KACtD,sBAAsB,GAAG,KAAK,KAAK;EACzC,GAMG;AACD,UAAM,EAAE,MAAAJ,QAAM,SAAS,MAAM,CAAC;AArBhC,SAAkBG,IAAA,IAAU;AAuB1B,SAAK,MAAM;AACX,SAAK,aAAa;AAClB,SAAK,aAAa;EACpB;EAEA,OAAO,WAAW,OAAwC;AACxD,WAAO,WAAW,UAAU,OAAOF,QAAM;EAC3C;AACF;AE1BO,IAAM,oBAAoB,CAAC;EAChC;EACA,OAAO;EACP,WAAW;EACX,YAAY;AACd,IAKI,CAAC,MAAmB;AACtB,QAAM,YAAY,MAAM;AACtB,UAAM,iBAAiB,SAAS;AAChC,UAAM,QAAQ,IAAI,MAAM,IAAI;AAC5B,aAAS,IAAI,GAAG,IAAI,MAAM,KAAK;AAC7B,YAAM,CAAC,IAAI,SAAU,KAAK,OAAO,IAAI,iBAAkB,CAAC;IAC1D;AACA,WAAO,MAAM,KAAK,EAAE;EACtB;AAEA,MAAI,UAAU,MAAM;AAClB,WAAO;EACT;AAGA,MAAI,SAAS,SAAS,SAAS,GAAG;AAChC,UAAM,IAAI,qBAAqB;MAC7B,UAAU;MACV,SAAS,kBAAkB,SAAS,uCAAuC,QAAQ;IACrF,CAAC;EACH;AAEA,SAAO,MAAM,GAAG,MAAM,GAAG,SAAS,GAAG,UAAU,CAAC;AAClD;AAWO,IAAM,aAAa,kBAAkB;AIxDrC,SAAS,aAAa,OAAgC;AAC3D,UACG,iBAAiB,SAAS,iBAAiB,kBAC3C,MAAM,SAAS,gBACd,MAAM,SAAS;EACf,MAAM,SAAS;AAErB;ADJA,IAAM,8BAA8B,CAAC,gBAAgB,iBAAiB;AAE/D,SAAS,iBAAiB;EAC/B;EACA;EACA;AACF,GAIG;AACD,MAAI,aAAa,KAAK,GAAG;AACvB,WAAO;EACT;AAGA,MACE,iBAAiB,aACjB,4BAA4B,SAAS,MAAM,QAAQ,YAAY,CAAC,GAChE;AACA,UAAM,QAAS,MAAc;AAE7B,QAAI,SAAS,MAAM;AAEjB,aAAO,IAAI,aAAa;QACtB,SAAS,0BAA0B,MAAM,OAAO;QAChD;QACA;QACA;QACA,aAAa;;MACf,CAAC;IACH;EACF;AAEA,SAAO;AACT;AEtCO,SAAS,+BACd,gBAAqB,YACb;AAFV,MAAAI,MAAAC,MAAA;AAIE,MAAI,cAAc,QAAQ;AACxB,WAAO;EACT;AAGA,OAAID,OAAA,cAAc,cAAd,OAAA,SAAAA,KAAyB,WAAW;AACtC,WAAO,WAAW,cAAc,UAAU,UAAU,YAAY,CAAC;EACnE;AAGA,OAAI,MAAAC,OAAA,cAAc,YAAd,OAAA,SAAAA,KAAuB,aAAvB,OAAA,SAAA,GAAiC,MAAM;AACzC,WAAO,mBAAmB,cAAc,QAAQ,QAAQ,UAAU,CAAC,CAAC;EACtE;AAEA,MAAI,cAAc,aAAa;AAC7B,WAAO;EACT;AAEA,SAAO;AACT;AChBO,SAAS,iBACd,SAKwB;AACxB,MAAI,WAAW,MAAM;AACnB,WAAO,CAAC;EACV;AAEA,QAAM,aAAqC,CAAC;AAE5C,MAAI,mBAAmB,SAAS;AAC9B,YAAQ,QAAQ,CAAC,OAAO,QAAQ;AAC9B,iBAAW,IAAI,YAAY,CAAC,IAAI;IAClC,CAAC;EACH,OAAO;AACL,QAAI,CAAC,MAAM,QAAQ,OAAO,GAAG;AAC3B,gBAAU,OAAO,QAAQ,OAAO;IAClC;AAEA,eAAW,CAAC,KAAK,KAAK,KAAK,SAAS;AAClC,UAAI,SAAS,MAAM;AACjB,mBAAW,IAAI,YAAY,CAAC,IAAI;MAClC;IACF;EACF;AAEA,SAAO;AACT;ACzBO,SAAS,oBACd,YACG,sBACqB;AACxB,QAAM,oBAAoB,IAAI,QAAQ,iBAAiB,OAAO,CAAC;AAE/D,QAAM,yBAAyB,kBAAkB,IAAI,YAAY,KAAK;AAEtE,oBAAkB;IAChB;IACA,CAAC,wBAAwB,GAAG,oBAAoB,EAAE,OAAO,OAAO,EAAE,KAAK,GAAG;EAC5E;AAEA,SAAO,OAAO,YAAY,kBAAkB,QAAQ,CAAC;AACvD;ACxBO,IAAM,UACX,OACI,UACA;ASkBN,IAAM,iBAAiB;AACvB,IAAM,uBAAuB;AAE7B,SAAS,OAAO,MAAc;AAE5B,QAAM,MAAM,KAAK,MAAM,IAAI;AAG3B,MAAI,QAAQ,QAAQ,OAAO,QAAQ,UAAU;AAC3C,WAAO;EACT;AAEA,MACE,eAAe,KAAK,IAAI,MAAM,SAC9B,qBAAqB,KAAK,IAAI,MAAM,OACpC;AACA,WAAO;EACT;AAGA,SAAO,OAAO,GAAG;AACnB;AAEA,SAAS,OAAO,KAAU;AACxB,MAAI,OAAO,CAAC,GAAG;AAEf,SAAO,KAAK,QAAQ;AAClB,UAAM,QAAQ;AACd,WAAO,CAAC;AAER,eAAW,QAAQ,OAAO;AACxB,UAAI,OAAO,UAAU,eAAe,KAAK,MAAM,WAAW,GAAG;AAC3D,cAAM,IAAI,YAAY,8CAA8C;MACtE;AAEA,UACE,OAAO,UAAU,eAAe,KAAK,MAAM,aAAa,KACxD,OAAO,UAAU,eAAe,KAAK,KAAK,aAAa,WAAW,GAClE;AACA,cAAM,IAAI,YAAY,8CAA8C;MACtE;AAEA,iBAAW,OAAO,MAAM;AACtB,cAAM,QAAQ,KAAK,GAAG;AACtB,YAAI,SAAS,OAAO,UAAU,UAAU;AACtC,eAAK,KAAK,KAAK;QACjB;MACF;IACF;EACF;AACA,SAAO;AACT;AAEO,SAAS,gBAAgB,MAAc;AAC5C,QAAM,EAAE,gBAAgB,IAAI;AAC5B,MAAI;AAEF,UAAM,kBAAkB;EAC1B,SAAS,GAAG;AAEV,WAAO,OAAO,IAAI;EACpB;AAEA,MAAI;AACF,WAAO,OAAO,IAAI;EACpB,UAAA;AACE,UAAM,kBAAkB;EAC1B;AACF;AGtFO,SAAS,oCACdC,aACa;AACb,MAAIA,YAAW,SAAS,UAAU;AAChCA,gBAAW,uBAAuB;AAClC,UAAM,aAAaA,YAAW;AAC9B,QAAI,cAAc,MAAM;AACtB,iBAAW,YAAY,YAAY;AACjC,mBAAW,QAAQ,IAAI;UACrB,WAAW,QAAQ;QACrB;MACF;IACF;EACF;AACA,MAAIA,YAAW,SAAS,WAAWA,YAAW,SAAS,MAAM;AAC3D,QAAI,MAAM,QAAQA,YAAW,KAAK,GAAG;AACnCA,kBAAW,QAAQA,YAAW,MAAM;QAAI,CAAA,SACtC,oCAAoC,IAAmB;MACzD;IACF,OAAO;AACLA,kBAAW,QAAQ;QACjBA,YAAW;MACb;IACF;EACF;AACA,SAAOA;AACT;ACrBO,IAAM,iBAAiB;EAC5B;AACF;AAoDO,IAAM,iBAA0B;EACrC,MAAM;EACN,cAAc;EACd,UAAU,CAAC,GAAG;EACd,gBAAgB;EAChB,cAAc;EACd,cAAc;EACd,aAAa;EACb,0BAA0B;EAC1B,6BAA6B;EAC7B,8BAA8B;EAC9B,gBAAgB;EAChB,cAAc;EACd,aAAa,CAAC;EACd,eAAe;EACf,iBAAiB;EACjB,iBAAiB;EACjB,eAAe;EACf,gBAAgB;EAChB,cAAc;AAChB;AAEO,IAAM,oBAAoB,CAC/B,YAEC,OAAO,YAAY,WAChB,iCACK,iBADL;EAEE,MAAM;AACR,KACA,kCACK,iBACA;AE9FJ,SAAS,cAAkC;AAChD,SAAO,CAAC;AACV;ACQO,SAAS,cAAc,KAAkB,MAAY;AAZ5D,MAAAC,MAAAC,MAAA;AAaE,QAAM,MAA4B;IAChC,MAAM;EACR;AACA,QACED,OAAA,IAAI,SAAJ,OAAA,SAAAA,KAAU,WACV,MAAAC,OAAA,IAAI,SAAJ,OAAA,SAAAA,KAAU,SAAV,OAAA,SAAA,GAAgB,cAAa,iCAAsB,QACnD;AACA,QAAI,QAAQ,SAAS,IAAI,KAAK,MAAM,iCAC/B,OAD+B;MAElC,aAAa,CAAC,GAAG,KAAK,aAAa,OAAO;IAC5C,EAAC;EACH;AAEA,MAAI,IAAI,WAAW;AACjB,QAAI,WAAW,IAAI,UAAU;EAC/B;AACA,MAAI,IAAI,WAAW;AACjB,QAAI,WAAW,IAAI,UAAU;EAC/B;AACA,MAAI,IAAI,aAAa;AACnB,QAAI,WAAW,IAAI,YAAY;AAC/B,QAAI,WAAW,IAAI,YAAY;EACjC;AACA,SAAO;AACT;ACzBO,SAAS,eAAe,KAA0C;AACvE,QAAM,MAA6B;IACjC,MAAM;IACN,QAAQ;EACV;AAEA,MAAI,CAAC,IAAI,OAAQ,QAAO;AAExB,aAAW,SAAS,IAAI,QAAQ;AAC9B,YAAQ,MAAM,MAAM;MAClB,KAAK;AACH,YAAI,MAAM,WAAW;AACnB,cAAI,UAAU,MAAM;QACtB,OAAO;AACL,cAAI,mBAAmB,MAAM;QAC/B;AACA;MACF,KAAK;AACH,YAAI,MAAM,WAAW;AACnB,cAAI,UAAU,MAAM;QACtB,OAAO;AACL,cAAI,mBAAmB,MAAM;QAC/B;AAEA;MACF,KAAK;AACH,YAAI,aAAa,MAAM;AACvB;IACJ;EACF;AACA,SAAO;AACT;ACvCO,SAAS,kBAA0C;AACxD,SAAO,EAAE,MAAM,UAAU;AAC3B;ACFO,SAAS,gBAAgB,MAA0B,MAAY;AACpE,SAAO,SAAS,KAAK,KAAK,MAAM,IAAI;AACtC;ACFO,IAAM,gBAAgB,CAAC,KAAuB,SAAe;AAClE,SAAO,SAAS,IAAI,UAAU,MAAM,IAAI;AAC1C;ACSO,SAAS,aACd,KACA,MACA,sBACqB;AACrB,QAAM,WAAW,wBAAA,OAAA,uBAAwB,KAAK;AAE9C,MAAI,MAAM,QAAQ,QAAQ,GAAG;AAC3B,WAAO;MACL,OAAO,SAAS,IAAI,CAAC,MAAM,MAAM,aAAa,KAAK,MAAM,IAAI,CAAC;IAChE;EACF;AAEA,UAAQ,UAAU;IAChB,KAAK;IACL,KAAK;AACH,aAAO;QACL,MAAM;QACN,QAAQ;MACV;IACF,KAAK;AACH,aAAO;QACL,MAAM;QACN,QAAQ;MACV;IACF,KAAK;AACH,aAAO,kBAAkB,GAAG;EAChC;AACF;AAEA,IAAM,oBAAoB,CAAC,QAAoB;AAC7C,QAAM,MAA2B;IAC/B,MAAM;IACN,QAAQ;EACV;AAEA,aAAW,SAAS,IAAI,QAAQ;AAC9B,YAAQ,MAAM,MAAM;MAClB,KAAK;AACH,YAAI,UAAU,MAAM;AACpB;MACF,KAAK;AACH,YAAI,UAAU,MAAM;AACpB;IACJ;EACF;AAEA,SAAO;AACT;AC1DO,SAAS,gBACd,MACA,MACoC;AACpC,SAAO,iCACF,SAAS,KAAK,UAAU,MAAM,IAAI,IADhC;IAEL,SAAS,KAAK,aAAa;EAC7B;AACF;ACPO,SAAS,gBACd,MACA,MAC6B;AAC7B,SAAO,KAAK,mBAAmB,UAC3B,SAAS,KAAK,OAAO,MAAM,IAAI,IAC/B,YAAY;AAClB;ACNO,SAAS,aAAa,KAAsC;AACjE,SAAO;IACL,MAAM;IACN,MAAM,MAAM,KAAK,IAAI,MAAM;EAC7B;AACF;ACDA,IAAM,yBAAyB,CAC7B,SACiC;AACjC,MAAI,UAAU,QAAQ,KAAK,SAAS,SAAU,QAAO;AACrD,SAAO,WAAW;AACpB;AAEO,SAAS,qBACd,KACA,MACoD;AACpD,QAAM,QAAQ;IACZ,SAAS,IAAI,KAAK,MAAM,iCACnB,OADmB;MAEtB,aAAa,CAAC,GAAG,KAAK,aAAa,SAAS,GAAG;IACjD,EAAC;IACD,SAAS,IAAI,MAAM,MAAM,iCACpB,OADoB;MAEvB,aAAa,CAAC,GAAG,KAAK,aAAa,SAAS,GAAG;IACjD,EAAC;EACH,EAAE,OAAO,CAAC,MAA4B,CAAC,CAAC,CAAC;AAEzC,QAAM,cAAiC,CAAC;AAExC,QAAM,QAAQ,CAAA,WAAU;AACtB,QAAI,uBAAuB,MAAM,GAAG;AAClC,kBAAY,KAAK,GAAG,OAAO,KAAK;IAClC,OAAO;AACL,UAAI,eAAgC;AACpC,UACE,0BAA0B,UAC1B,OAAO,yBAAyB,OAChC;AACA,cAA0CD,OAAA,QAAlC,2BAAkCA,MAAT,iBAASA,MAAT,CAAzB;AACR,uBAAe;MACjB;AACA,kBAAY,KAAK,YAAY;IAC/B;EACF,CAAC;AACD,SAAO,YAAY,SAAS,EAAE,OAAO,YAAY,IAAI;AACvD;ACxCO,SAAS,gBAAgB,KAA4C;AAC1E,QAAM,aAAa,OAAO,IAAI;AAC9B,MACE,eAAe,YACf,eAAe,YACf,eAAe,aACf,eAAe,UACf;AACA,WAAO;MACL,MAAM,MAAM,QAAQ,IAAI,KAAK,IAAI,UAAU;IAC7C;EACF;AAEA,SAAO;IACL,MAAM,eAAe,WAAW,YAAY;IAC5C,OAAO,IAAI;EACb;AACF;AEzBA,IAAI,aAAiC;AAQ9B,IAAM,cAAc;;;;EAIzB,MAAM;EACN,OAAO;EACP,MAAM;;;;EAIN,OACE;;;;;;;;;;;;EAYF,OAAO,MAAM;AACX,QAAI,eAAe,QAAW;AAC5B,mBAAa;QACX;QACA;MACF;IACF;AACA,WAAO;EACT;;;;EAIA,MAAM;;;;EAIN,MAAM;EACN,UACE;;;;EAIF,MAAM;EACN,UACE;EACF,QAAQ;EACR,WACE;EACF,QAAQ;EACR,KAAK;AACP;AA2BO,SAAS,eACd,KACA,MACuB;AACvB,QAAM,MAA6B;IACjC,MAAM;EACR;AAEA,MAAI,IAAI,QAAQ;AACd,eAAW,SAAS,IAAI,QAAQ;AAC9B,cAAQ,MAAM,MAAM;QAClB,KAAK;AACH,cAAI,YACF,OAAO,IAAI,cAAc,WACrB,KAAK,IAAI,IAAI,WAAW,MAAM,KAAK,IACnC,MAAM;AACZ;QACF,KAAK;AACH,cAAI,YACF,OAAO,IAAI,cAAc,WACrB,KAAK,IAAI,IAAI,WAAW,MAAM,KAAK,IACnC,MAAM;AAEZ;QACF,KAAK;AACH,kBAAQ,KAAK,eAAe;YAC1B,KAAK;AACH,wBAAU,KAAK,SAAS,MAAM,SAAS,IAAI;AAC3C;YACF,KAAK;AACH,wBAAU,KAAK,aAAa,MAAM,SAAS,IAAI;AAC/C;YACF,KAAK;AACH,yBAAW,KAAK,YAAY,OAAO,MAAM,SAAS,IAAI;AACtD;UACJ;AAEA;QACF,KAAK;AACH,oBAAU,KAAK,OAAO,MAAM,SAAS,IAAI;AACzC;QACF,KAAK;AACH,oBAAU,KAAK,QAAQ,MAAM,SAAS,IAAI;AAC1C;QACF,KAAK;AACH,qBAAW,KAAK,MAAM,OAAO,MAAM,SAAS,IAAI;AAChD;QACF,KAAK;AACH,qBAAW,KAAK,YAAY,MAAM,MAAM,SAAS,IAAI;AACrD;QACF,KAAK;AACH,qBAAW,KAAK,YAAY,OAAO,MAAM,SAAS,IAAI;AACtD;QACF,KAAK;AACH;YACE;YACA,OAAO,IAAI,wBAAwB,MAAM,OAAO,IAAI,CAAC,EAAE;YACvD,MAAM;YACN;UACF;AACA;QACF,KAAK;AACH;YACE;YACA,OAAO,GAAG,wBAAwB,MAAM,OAAO,IAAI,CAAC,GAAG;YACvD,MAAM;YACN;UACF;AACA;QACF,KAAK;AACH,oBAAU,KAAK,aAAa,MAAM,SAAS,IAAI;AAC/C;QACF,KAAK;AACH,oBAAU,KAAK,QAAQ,MAAM,SAAS,IAAI;AAC1C;QACF,KAAK;AACH,oBAAU,KAAK,QAAQ,MAAM,SAAS,IAAI;AAC1C;QACF,KAAK;AACH,oBAAU,KAAK,YAAY,MAAM,SAAS,IAAI;AAC9C;QACF,KAAK;AACH,cAAI,YACF,OAAO,IAAI,cAAc,WACrB,KAAK,IAAI,IAAI,WAAW,MAAM,KAAK,IACnC,MAAM;AACZ,cAAI,YACF,OAAO,IAAI,cAAc,WACrB,KAAK,IAAI,IAAI,WAAW,MAAM,KAAK,IACnC,MAAM;AACZ;QACF,KAAK,YAAY;AACf;YACE;YACA,OAAO,wBAAwB,MAAM,OAAO,IAAI,CAAC;YACjD,MAAM;YACN;UACF;AACA;QACF;QACA,KAAK,MAAM;AACT,cAAI,MAAM,YAAY,MAAM;AAC1B,sBAAU,KAAK,QAAQ,MAAM,SAAS,IAAI;UAC5C;AACA,cAAI,MAAM,YAAY,MAAM;AAC1B,sBAAU,KAAK,QAAQ,MAAM,SAAS,IAAI;UAC5C;AACA;QACF;QACA,KAAK;AACH,qBAAW,KAAK,YAAY,WAAW,MAAM,SAAS,IAAI;AAC1D;QACF,KAAK;AACH,qBAAW,KAAK,YAAY,KAAK,MAAM,SAAS,IAAI;AACpD;QACF,KAAK,QAAQ;AACX,cAAI,MAAM,YAAY,MAAM;AAC1B,uBAAW,KAAK,YAAY,UAAU,MAAM,SAAS,IAAI;UAC3D;AACA,cAAI,MAAM,YAAY,MAAM;AAC1B,uBAAW,KAAK,YAAY,UAAU,MAAM,SAAS,IAAI;UAC3D;AACA;QACF;QACA,KAAK;AACH,qBAAW,KAAK,YAAY,MAAM,GAAG,MAAM,SAAS,IAAI;AACxD;QACF,KAAK,QAAQ;AACX,qBAAW,KAAK,YAAY,MAAM,MAAM,SAAS,IAAI;AACrD;QACF;QACA,KAAK,UAAU;AACb,kBAAQ,KAAK,gBAAgB;YAC3B,KAAK,iBAAiB;AACpB,wBAAU,KAAK,UAAiB,MAAM,SAAS,IAAI;AACnD;YACF;YAEA,KAAK,0BAA0B;AAC7B,kBAAI,kBAAkB;AACtB;YACF;YAEA,KAAK,eAAe;AAClB,yBAAW,KAAK,YAAY,QAAQ,MAAM,SAAS,IAAI;AACvD;YACF;UACF;AACA;QACF;QACA,KAAK,UAAU;AACb,qBAAW,KAAK,YAAY,QAAQ,MAAM,SAAS,IAAI;QACzD;QACA,KAAK;QACL,KAAK;QACL,KAAK;AACH;QACF;AAEG,UAAA,kBAAC,MAAa;UAAC,GAAG,KAAK;MAC5B;IACF;EACF;AAEA,SAAO;AACT;AAEA,SAAS,wBAAwB,SAAiB,MAAoB;AACpE,SAAO,KAAK,oBAAoB,WAC5B,sBAAsB,OAAO,IAC7B;AACN;AAEA,IAAM,gBAAgB,IAAI;EACxB;AACF;AAEA,SAAS,sBAAsB,QAAgB;AAC7C,MAAI,SAAS;AAEb,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,QAAI,CAAC,cAAc,IAAI,OAAO,CAAC,CAAC,GAAG;AACjC,gBAAU;IACZ;AAEA,cAAU,OAAO,CAAC;EACpB;AAEA,SAAO;AACT;AAGA,SAAS,UACP,QACA,OACA,SACA,MACA;AAhSF,MAAAA;AAiSE,MAAI,OAAO,YAAUA,OAAA,OAAO,UAAP,OAAA,SAAAA,KAAc,KAAK,CAAA,MAAK,EAAE,MAAA,IAAS;AACtD,QAAI,CAAC,OAAO,OAAO;AACjB,aAAO,QAAQ,CAAC;IAClB;AAEA,QAAI,OAAO,QAAQ;AACjB,aAAO,MAAO,KAAK;QACjB,QAAQ,OAAO;MACjB,CAAC;AACD,aAAO,OAAO;IAChB;AAEA,WAAO,MAAO,KAAK;MACjB,QAAQ;OACJ,WACF,KAAK,iBAAiB,EAAE,cAAc,EAAE,QAAQ,QAAQ,EAAE,EAC7D;EACH,OAAO;AACL,WAAO,SAAS;EAClB;AACF;AAGA,SAAS,WACP,QACA,OACA,SACA,MACA;AA7TF,MAAAA;AA8TE,MAAI,OAAO,aAAWA,OAAA,OAAO,UAAP,OAAA,SAAAA,KAAc,KAAK,CAAA,MAAK,EAAE,OAAA,IAAU;AACxD,QAAI,CAAC,OAAO,OAAO;AACjB,aAAO,QAAQ,CAAC;IAClB;AAEA,QAAI,OAAO,SAAS;AAClB,aAAO,MAAO,KAAK;QACjB,SAAS,OAAO;MAClB,CAAC;AACD,aAAO,OAAO;IAChB;AAEA,WAAO,MAAO,KAAK;MACjB,SAAS,yBAAyB,OAAO,IAAI;OACzC,WACF,KAAK,iBAAiB,EAAE,cAAc,EAAE,SAAS,QAAQ,EAAE,EAC9D;EACH,OAAO;AACL,WAAO,UAAU,yBAAyB,OAAO,IAAI;EACvD;AACF;AAGA,SAAS,yBAAyB,OAAe,MAAoB;AArVrE,MAAAA;AAsVE,MAAI,CAAC,KAAK,mBAAmB,CAAC,MAAM,OAAO;AACzC,WAAO,MAAM;EACf;AAGA,QAAM,QAAQ;IACZ,GAAG,MAAM,MAAM,SAAS,GAAG;;IAC3B,GAAG,MAAM,MAAM,SAAS,GAAG;;IAC3B,GAAG,MAAM,MAAM,SAAS,GAAG;;EAC7B;AAGA,QAAM,SAAS,MAAM,IAAI,MAAM,OAAO,YAAY,IAAI,MAAM;AAC5D,MAAI,UAAU;AACd,MAAI,YAAY;AAChB,MAAI,cAAc;AAClB,MAAI,cAAc;AAElB,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,QAAI,WAAW;AACb,iBAAW,OAAO,CAAC;AACnB,kBAAY;AACZ;IACF;AAEA,QAAI,MAAM,GAAG;AACX,UAAI,aAAa;AACf,YAAI,OAAO,CAAC,EAAE,MAAM,OAAO,GAAG;AAC5B,cAAI,aAAa;AACf,uBAAW,OAAO,CAAC;AACnB,uBAAW,GAAG,OAAO,IAAI,CAAC,CAAC,IAAI,OAAO,CAAC,CAAC,GAAG,YAAY;AACvD,0BAAc;UAChB,WAAW,OAAO,IAAI,CAAC,MAAM,SAAOA,OAAA,OAAO,IAAI,CAAC,MAAZ,OAAA,SAAAA,KAAe,MAAM,OAAA,IAAU;AACjE,uBAAW,OAAO,CAAC;AACnB,0BAAc;UAChB,OAAO;AACL,uBAAW,GAAG,OAAO,CAAC,CAAC,GAAG,OAAO,CAAC,EAAE,YAAY,CAAC;UACnD;AACA;QACF;MACF,WAAW,OAAO,CAAC,EAAE,MAAM,OAAO,GAAG;AACnC,mBAAW,IAAI,OAAO,CAAC,CAAC,GAAG,OAAO,CAAC,EAAE,YAAY,CAAC;AAClD;MACF;IACF;AAEA,QAAI,MAAM,GAAG;AACX,UAAI,OAAO,CAAC,MAAM,KAAK;AACrB,mBAAW;;AACX;MACF,WAAW,OAAO,CAAC,MAAM,KAAK;AAC5B,mBAAW;;AACX;MACF;IACF;AAEA,QAAI,MAAM,KAAK,OAAO,CAAC,MAAM,KAAK;AAChC,iBAAW,cAAc,GAAG,OAAO,CAAC,CAAC;IAAS,IAAI,OAAO,CAAC,CAAC;;AAC3D;IACF;AAEA,eAAW,OAAO,CAAC;AACnB,QAAI,OAAO,CAAC,MAAM,MAAM;AACtB,kBAAY;IACd,WAAW,eAAe,OAAO,CAAC,MAAM,KAAK;AAC3C,oBAAc;IAChB,WAAW,CAAC,eAAe,OAAO,CAAC,MAAM,KAAK;AAC5C,oBAAc;IAChB;EACF;AAEA,MAAI;AACF,QAAI,OAAO,OAAO;EACpB,SAAQ,GAAA;AACN,YAAQ;MACN,sCAAsC,KAAK,YAAY;QACrD;MACF,CAAC;IACH;AACA,WAAO,MAAM;EACf;AAEA,SAAO;AACT;ADlZO,SAAS,eACd,KACA,MACuB;AA1BzB,MAAAA,MAAAC,MAAA,IAAA,IAAA,IAAA;AA2BE,QAAM,SAAgC;IACpC,MAAM;IACN,uBACED,OAAA,SAAS,IAAI,UAAU,MAAM,iCACxB,OADwB;MAE3B,aAAa,CAAC,GAAG,KAAK,aAAa,sBAAsB;IAC3D,EAAC,MAHD,OAAAA,OAGM,KAAK;EACf;AAEA,QACEC,OAAA,IAAI,YAAJ,OAAA,SAAAA,KAAa,KAAK,cAAaC,WAAAA,sBAAsB,eACrD,KAAA,IAAI,QAAQ,KAAK,WAAjB,OAAA,SAAA,GAAyB,SACzB;AACA,UAA6BF,OAAA,eAAe,IAAI,QAAQ,MAAM,IAAI,GAA1D,WAAqBA,MAAZ,oBAAYA,MAAZ,CAAT;AAER,WAAO,iCACF,SADE;MAEL,eAAe;IACjB;EACF,aAAW,KAAA,IAAI,YAAJ,OAAA,SAAA,GAAa,KAAK,cAAaE,WAAAA,sBAAsB,SAAS;AACvE,WAAO,iCACF,SADE;MAEL,eAAe;QACb,MAAM,IAAI,QAAQ,KAAK;MACzB;IACF;EACF,aACE,KAAA,IAAI,YAAJ,OAAA,SAAA,GAAa,KAAK,cAAaA,WAAAA,sBAAsB,cACrD,IAAI,QAAQ,KAAK,KAAK,KAAK,aAAaA,WAAAA,sBAAsB,eAC9D,KAAA,IAAI,QAAQ,KAAK,KAAK,KAAK,WAA3B,OAAA,SAAA,GAAmC,SACnC;AACA,UAA6BD,OAAA;MAC3B,IAAI,QAAQ;MACZ;IACF,GAHQ,WAAqBA,MAAZ,oBAAYA,MAAZ,CAAT;AAKR,WAAO,iCACF,SADE;MAEL,eAAe;IACjB;EACF;AAEA,SAAO;AACT;AEpDO,SAAS,YACd,KACA,MAC4C;AAC5C,MAAI,KAAK,gBAAgB,UAAU;AACjC,WAAO,eAAe,KAAK,IAAI;EACjC;AAEA,QAAM,OACJ,SAAS,IAAI,QAAQ,MAAM,iCACtB,OADsB;IAEzB,aAAa,CAAC,GAAG,KAAK,aAAa,SAAS,SAAS,GAAG;EAC1D,EAAC,KAAK,YAAY;AACpB,QAAM,SACJ,SAAS,IAAI,UAAU,MAAM,iCACxB,OADwB;IAE3B,aAAa,CAAC,GAAG,KAAK,aAAa,SAAS,SAAS,GAAG;EAC1D,EAAC,KAAK,YAAY;AACpB,SAAO;IACL,MAAM;IACN,UAAU;IACV,OAAO;MACL,MAAM;MACN,OAAO,CAAC,MAAM,MAAM;MACpB,UAAU;MACV,UAAU;IACZ;EACF;AACF;ACvCO,SAAS,mBACd,KAC2B;AAC3B,QAAM,SAAS,IAAI;AACnB,QAAM,aAAa,OAAO,KAAK,IAAI,MAAM,EAAE,OAAO,CAAC,QAAgB;AACjE,WAAO,OAAO,OAAO,OAAO,GAAG,CAAC,MAAM;EACxC,CAAC;AAED,QAAM,eAAe,WAAW,IAAI,CAAC,QAAgB,OAAO,GAAG,CAAC;AAEhE,QAAM,cAAc,MAAM;IACxB,IAAI,IAAI,aAAa,IAAI,CAAC,WAA4B,OAAO,MAAM,CAAC;EACtE;AAEA,SAAO;IACL,MACE,YAAY,WAAW,IACnB,YAAY,CAAC,MAAM,WACjB,WACA,WACF,CAAC,UAAU,QAAQ;IACzB,MAAM;EACR;AACF;ACxBO,SAAS,gBAAkD;AAChE,SAAO,EAAE,KAAK,YAAY,EAAE;AAC9B;ACJO,SAAS,eAAoC;AAClD,SAAO;IACL,MAAM;EACR;AACF;ACEO,IAAM,oBAAoB;EAC/B,WAAW;EACX,WAAW;EACX,WAAW;EACX,YAAY;EACZ,SAAS;AACX;AAsBO,SAAS,cACd,KACA,MACkE;AAClE,QAAM,UACJ,IAAI,mBAAmB,MAAM,MAAM,KAAK,IAAI,QAAQ,OAAO,CAAC,IAAI,IAAI;AAGtE,MACE,QAAQ;IACN,CAAA,MACE,EAAE,KAAK,YAAY,sBAClB,CAAC,EAAE,KAAK,UAAU,CAAC,EAAE,KAAK,OAAO;EACtC,GACA;AAGA,UAAM,QAAQ,QAAQ,OAAO,CAACE,QAA+B,MAAM;AACjE,YAAM,OAAO,kBAAkB,EAAE,KAAK,QAAwB;AAC9D,aAAO,QAAQ,CAACA,OAAM,SAAS,IAAI,IAAI,CAAC,GAAGA,QAAO,IAAI,IAAIA;IAC5D,GAAG,CAAC,CAAC;AAEL,WAAO;MACL,MAAM,MAAM,SAAS,IAAI,QAAQ,MAAM,CAAC;IAC1C;EACF,WACE,QAAQ,MAAM,CAAA,MAAK,EAAE,KAAK,aAAa,gBAAgB,CAAC,EAAE,WAAW,GACrE;AAGA,UAAM,QAAQ,QAAQ;MACpB,CAAC,KAA6B,MAA+B;AAC3D,cAAM,OAAO,OAAO,EAAE,KAAK;AAC3B,gBAAQ,MAAM;UACZ,KAAK;UACL,KAAK;UACL,KAAK;AACH,mBAAO,CAAC,GAAG,KAAK,IAAI;UACtB,KAAK;AACH,mBAAO,CAAC,GAAG,KAAK,SAAkB;UACpC,KAAK;AACH,gBAAI,EAAE,KAAK,UAAU,KAAM,QAAO,CAAC,GAAG,KAAK,MAAe;UAC5D,KAAK;UACL,KAAK;UACL,KAAK;UACL;AACE,mBAAO;QACX;MACF;MACA,CAAC;IACH;AAEA,QAAI,MAAM,WAAW,QAAQ,QAAQ;AAGnC,YAAM,cAAc,MAAM,OAAO,CAAC,GAAG,GAAG,MAAM,EAAE,QAAQ,CAAC,MAAM,CAAC;AAChE,aAAO;QACL,MAAM,YAAY,SAAS,IAAI,cAAc,YAAY,CAAC;QAC1D,MAAM,QAAQ;UACZ,CAAC,KAAK,MAAM;AACV,mBAAO,IAAI,SAAS,EAAE,KAAK,KAAK,IAAI,MAAM,CAAC,GAAG,KAAK,EAAE,KAAK,KAAK;UACjE;UACA,CAAC;QACH;MACF;IACF;EACF,WAAW,QAAQ,MAAM,CAAA,MAAK,EAAE,KAAK,aAAa,SAAS,GAAG;AAC5D,WAAO;MACL,MAAM;MACN,MAAM,QAAQ;QACZ,CAAC,KAAe,MAAM;UACpB,GAAG;UACH,GAAG,EAAE,KAAK,OAAO,OAAO,CAACC,OAAc,CAAC,IAAI,SAASA,EAAC,CAAC;QACzD;QACA,CAAC;MACH;IACF;EACF;AAEA,SAAO,QAAQ,KAAK,IAAI;AAC1B;AAEA,IAAM,UAAU,CACd,KACA,SACqE;AACrE,QAAM,SACH,IAAI,mBAAmB,MACpB,MAAM,KAAK,IAAI,QAAQ,OAAO,CAAC,IAC/B,IAAI,SAEP;IAAI,CAAC,GAAG,MACP,SAAS,EAAE,MAAM,iCACZ,OADY;MAEf,aAAa,CAAC,GAAG,KAAK,aAAa,SAAS,GAAG,CAAC,EAAE;IACpD,EAAC;EACH,EACC;IACC,CAAC,MACC,CAAC,CAAC,MACD,CAAC,KAAK,gBACJ,OAAO,MAAM,YAAY,OAAO,KAAK,CAAC,EAAE,SAAS;EACxD;AAEF,SAAO,MAAM,SAAS,EAAE,MAAM,IAAI;AACpC;AChIO,SAAS,iBACd,KACA,MACqC;AACrC,MACE,CAAC,aAAa,aAAa,aAAa,cAAc,SAAS,EAAE;IAC/D,IAAI,UAAU,KAAK;EACrB,MACC,CAAC,IAAI,UAAU,KAAK,UAAU,CAAC,IAAI,UAAU,KAAK,OAAO,SAC1D;AACA,WAAO;MACL,MAAM;QACJ,kBACE,IAAI,UAAU,KAAK,QACrB;QACA;MACF;IACF;EACF;AAEA,QAAM,OAAO,SAAS,IAAI,UAAU,MAAM,iCACrC,OADqC;IAExC,aAAa,CAAC,GAAG,KAAK,aAAa,SAAS,GAAG;EACjD,EAAC;AAED,SAAO,QAAQ,EAAE,OAAO,CAAC,MAAM,EAAE,MAAM,OAAO,CAAC,EAAE;AACnD;AC9BO,SAAS,eAAe,KAA0C;AACvE,QAAM,MAA6B;IACjC,MAAM;EACR;AAEA,MAAI,CAAC,IAAI,OAAQ,QAAO;AAExB,aAAW,SAAS,IAAI,QAAQ;AAC9B,YAAQ,MAAM,MAAM;MAClB,KAAK;AACH,YAAI,OAAO;AACX;MACF,KAAK;AACH,YAAI,MAAM,WAAW;AACnB,cAAI,UAAU,MAAM;QACtB,OAAO;AACL,cAAI,mBAAmB,MAAM;QAC/B;AACA;MACF,KAAK;AACH,YAAI,MAAM,WAAW;AACnB,cAAI,UAAU,MAAM;QACtB,OAAO;AACL,cAAI,mBAAmB,MAAM;QAC/B;AACA;MACF,KAAK;AACH,YAAI,aAAa,MAAM;AACvB;IACJ;EACF;AACA,SAAO;AACT;AC/BO,SAAS,eAAe,KAAmB,MAAY;AAC5D,QAAM,SAAgC;IACpC,MAAM;IACN,YAAY,CAAC;EACf;AAEA,QAAM,WAAqB,CAAC;AAE5B,QAAM,QAAQ,IAAI,MAAM;AAExB,aAAW,YAAY,OAAO;AAC5B,QAAI,UAAU,MAAM,QAAQ;AAE5B,QAAI,YAAY,UAAa,QAAQ,SAAS,QAAW;AACvD;IACF;AAEA,UAAM,eAAe,eAAe,OAAO;AAE3C,UAAM,YAAY,SAAS,QAAQ,MAAM,iCACpC,OADoC;MAEvC,aAAa,CAAC,GAAG,KAAK,aAAa,cAAc,QAAQ;MACzD,cAAc,CAAC,GAAG,KAAK,aAAa,cAAc,QAAQ;IAC5D,EAAC;AAED,QAAI,cAAc,QAAW;AAC3B;IACF;AAEA,WAAO,WAAW,QAAQ,IAAI;AAE9B,QAAI,CAAC,cAAc;AACjB,eAAS,KAAK,QAAQ;IACxB;EACF;AAEA,MAAI,SAAS,QAAQ;AACnB,WAAO,WAAW;EACpB;AAEA,QAAM,uBAAuB,2BAA2B,KAAK,IAAI;AAEjE,MAAI,yBAAyB,QAAW;AACtC,WAAO,uBAAuB;EAChC;AAEA,SAAO;AACT;AAEA,SAAS,2BAA2B,KAAmB,MAAY;AACjE,MAAI,IAAI,SAAS,KAAK,aAAa,YAAY;AAC7C,WAAO,SAAS,IAAI,SAAS,MAAM,iCAC9B,OAD8B;MAEjC,aAAa,CAAC,GAAG,KAAK,aAAa,sBAAsB;IAC3D,EAAC;EACH;AAEA,UAAQ,IAAI,aAAa;IACvB,KAAK;AACH,aAAO,KAAK;IACd,KAAK;AACH,aAAO,KAAK;IACd,KAAK;AACH,aAAO,KAAK,6BAA6B,WACrC,KAAK,8BACL,KAAK;EACb;AACF;AAEA,SAAS,eAAe,QAA6B;AACnD,MAAI;AACF,WAAO,OAAO,WAAW;EAC3B,SAAQ,GAAA;AACN,WAAO;EACT;AACF;ACjFO,IAAM,mBAAmB,CAC9B,KACA,SACgC;AATlC,MAAAJ;AAUE,MAAI,KAAK,YAAY,SAAS,QAAMA,OAAA,KAAK,iBAAL,OAAA,SAAAA,KAAmB,SAAA,IAAY;AACjE,WAAO,SAAS,IAAI,UAAU,MAAM,IAAI;EAC1C;AAEA,QAAM,cAAc,SAAS,IAAI,UAAU,MAAM,iCAC5C,OAD4C;IAE/C,aAAa,CAAC,GAAG,KAAK,aAAa,SAAS,GAAG;EACjD,EAAC;AAED,SAAO,cACH,EAAE,OAAO,CAAC,EAAE,KAAK,YAAY,EAAE,GAAG,WAAW,EAAE,IAC/C,YAAY;AAClB;AChBO,IAAM,mBAAmB,CAC9B,KACA,SACuD;AACvD,MAAI,KAAK,iBAAiB,SAAS;AACjC,WAAO,SAAS,IAAI,GAAG,MAAM,IAAI;EACnC,WAAW,KAAK,iBAAiB,UAAU;AACzC,WAAO,SAAS,IAAI,IAAI,MAAM,IAAI;EACpC;AAEA,QAAM,IAAI,SAAS,IAAI,GAAG,MAAM,iCAC3B,OAD2B;IAE9B,aAAa,CAAC,GAAG,KAAK,aAAa,SAAS,GAAG;EACjD,EAAC;AACD,QAAM,IAAI,SAAS,IAAI,IAAI,MAAM,iCAC5B,OAD4B;IAE/B,aAAa,CAAC,GAAG,KAAK,aAAa,SAAS,IAAI,MAAM,GAAG;EAC3D,EAAC;AAED,SAAO;IACL,OAAO,CAAC,GAAG,CAAC,EAAE,OAAO,CAAC,MAA4B,MAAM,MAAS;EACnE;AACF;ACvBO,SAAS,gBACd,KACA,MAC6B;AAC7B,SAAO,SAAS,IAAI,KAAK,MAAM,IAAI;AACrC;ACGO,SAAS,YAAY,KAAgB,MAAgC;AAC1E,QAAM,QAAQ,SAAS,IAAI,UAAU,MAAM,iCACtC,OADsC;IAEzC,aAAa,CAAC,GAAG,KAAK,aAAa,OAAO;EAC5C,EAAC;AAED,QAAM,SAA6B;IACjC,MAAM;IACN,aAAa;IACb;EACF;AAEA,MAAI,IAAI,SAAS;AACf,WAAO,WAAW,IAAI,QAAQ;EAChC;AAEA,MAAI,IAAI,SAAS;AACf,WAAO,WAAW,IAAI,QAAQ;EAChC;AAEA,SAAO;AACT;AChBO,SAAS,cACd,KACA,MACsB;AACtB,MAAI,IAAI,MAAM;AACZ,WAAO;MACL,MAAM;MACN,UAAU,IAAI,MAAM;MACpB,OAAO,IAAI,MACR;QAAI,CAAC,GAAG,MACP,SAAS,EAAE,MAAM,iCACZ,OADY;UAEf,aAAa,CAAC,GAAG,KAAK,aAAa,SAAS,GAAG,CAAC,EAAE;QACpD,EAAC;MACH,EACC;QACC,CAAC,KAAwB,MAAO,MAAM,SAAY,MAAM,CAAC,GAAG,KAAK,CAAC;QAClE,CAAC;MACH;MACF,iBAAiB,SAAS,IAAI,KAAK,MAAM,iCACpC,OADoC;QAEvC,aAAa,CAAC,GAAG,KAAK,aAAa,iBAAiB;MACtD,EAAC;IACH;EACF,OAAO;AACL,WAAO;MACL,MAAM;MACN,UAAU,IAAI,MAAM;MACpB,UAAU,IAAI,MAAM;MACpB,OAAO,IAAI,MACR;QAAI,CAAC,GAAG,MACP,SAAS,EAAE,MAAM,iCACZ,OADY;UAEf,aAAa,CAAC,GAAG,KAAK,aAAa,SAAS,GAAG,CAAC,EAAE;QACpD,EAAC;MACH,EACC;QACC,CAAC,KAAwB,MAAO,MAAM,SAAY,MAAM,CAAC,GAAG,KAAK,CAAC;QAClE,CAAC;MACH;IACJ;EACF;AACF;ACtDO,SAAS,oBAA8C;AAC5D,SAAO;IACL,KAAK,YAAY;EACnB;AACF;ACNO,SAAS,kBAA0C;AACxD,SAAO,YAAY;AACrB;ACFO,IAAM,mBAAmB,CAAC,KAA0B,SAAe;AACxE,SAAO,SAAS,IAAI,UAAU,MAAM,IAAI;AAC1C;A9B8BO,IAAM,eAAe,CAC1B,KACA,UACA,SACiD;AACjD,UAAQ,UAAU;IAChB,KAAKE,UAAAA,sBAAsB;AACzB,aAAO,eAAe,KAAK,IAAI;IACjC,KAAKA,UAAAA,sBAAsB;AACzB,aAAO,eAAe,GAAG;IAC3B,KAAKA,UAAAA,sBAAsB;AACzB,aAAO,eAAe,KAAK,IAAI;IACjC,KAAKA,UAAAA,sBAAsB;AACzB,aAAO,eAAe,GAAG;IAC3B,KAAKA,UAAAA,sBAAsB;AACzB,aAAO,gBAAgB;IACzB,KAAKA,UAAAA,sBAAsB;AACzB,aAAO,aAAa,KAAK,IAAI;IAC/B,KAAKA,UAAAA,sBAAsB;AACzB,aAAO,kBAAkB;IAC3B,KAAKA,UAAAA,sBAAsB;AACzB,aAAO,aAAa;IACtB,KAAKA,UAAAA,sBAAsB;AACzB,aAAO,cAAc,KAAK,IAAI;IAChC,KAAKA,UAAAA,sBAAsB;IAC3B,KAAKA,UAAAA,sBAAsB;AACzB,aAAO,cAAc,KAAK,IAAI;IAChC,KAAKA,UAAAA,sBAAsB;AACzB,aAAO,qBAAqB,KAAK,IAAI;IACvC,KAAKA,UAAAA,sBAAsB;AACzB,aAAO,cAAc,KAAK,IAAI;IAChC,KAAKA,UAAAA,sBAAsB;AACzB,aAAO,eAAe,KAAK,IAAI;IACjC,KAAKA,UAAAA,sBAAsB;AACzB,aAAO,gBAAgB,GAAG;IAC5B,KAAKA,UAAAA,sBAAsB;AACzB,aAAO,aAAa,GAAG;IACzB,KAAKA,UAAAA,sBAAsB;AACzB,aAAO,mBAAmB,GAAG;IAC/B,KAAKA,UAAAA,sBAAsB;AACzB,aAAO,iBAAiB,KAAK,IAAI;IACnC,KAAKA,UAAAA,sBAAsB;AACzB,aAAO,iBAAiB,KAAK,IAAI;IACnC,KAAKA,UAAAA,sBAAsB;AACzB,aAAO,YAAY,KAAK,IAAI;IAC9B,KAAKA,UAAAA,sBAAsB;AACzB,aAAO,YAAY,KAAK,IAAI;IAC9B,KAAKA,UAAAA,sBAAsB;AACzB,aAAO,MAAO,IAAY,OAAO,EAAE;IACrC,KAAKA,UAAAA,sBAAsB;AACzB,aAAO,gBAAgB,KAAK,IAAI;IAClC,KAAKA,UAAAA,sBAAsB;IAC3B,KAAKA,UAAAA,sBAAsB;AACzB,aAAO,cAAc;IACvB,KAAKA,UAAAA,sBAAsB;AACzB,aAAO,gBAAgB,KAAK,IAAI;IAClC,KAAKA,UAAAA,sBAAsB;AACzB,aAAO,YAAY;IACrB,KAAKA,UAAAA,sBAAsB;AACzB,aAAO,gBAAgB;IACzB,KAAKA,UAAAA,sBAAsB;AACzB,aAAO,gBAAgB,KAAK,IAAI;IAClC,KAAKA,UAAAA,sBAAsB;AACzB,aAAO,gBAAgB,KAAK,IAAI;IAClC,KAAKA,UAAAA,sBAAsB;AACzB,aAAO,iBAAiB,KAAK,IAAI;IACnC,KAAKA,UAAAA,sBAAsB;AACzB,aAAO,cAAc,KAAK,IAAI;IAChC,KAAKA,UAAAA,sBAAsB;AACzB,aAAO,iBAAiB,KAAK,IAAI;IACnC,KAAKA,UAAAA,sBAAsB;IAC3B,KAAKA,UAAAA,sBAAsB;IAC3B,KAAKA,UAAAA,sBAAsB;AACzB,aAAO;IACT;AAEE,aAAQ,kBAAC,MAAa,QAAW,QAAQ;EAC7C;AACF;A+BlHO,IAAM,kBAAkB,CAAC,OAAiB,UAAoB;AACnE,MAAI,IAAI;AACR,SAAO,IAAI,MAAM,UAAU,IAAI,MAAM,QAAQ,KAAK;AAChD,QAAI,MAAM,CAAC,MAAM,MAAM,CAAC,EAAG;EAC7B;AACA,SAAO,EAAE,MAAM,SAAS,GAAG,SAAS,GAAG,GAAG,MAAM,MAAM,CAAC,CAAC,EAAE,KAAK,GAAG;AACpE;ACEO,SAAS,SACd,KACA,MACA,kBAAkB,OACW;AAZ/B,MAAAF;AAaE,QAAM,WAAW,KAAK,KAAK,IAAI,GAAG;AAElC,MAAI,KAAK,UAAU;AACjB,UAAM,kBAAiBA,OAAA,KAAK,aAAL,OAAA,SAAAA,KAAA;MAAA;MACrB;MACA;MACA;MACA;IAAA;AAGF,QAAI,mBAAmB,gBAAgB;AACrC,aAAO;IACT;EACF;AAEA,MAAI,YAAY,CAAC,iBAAiB;AAChC,UAAM,aAAa,QAAQ,UAAU,IAAI;AAEzC,QAAI,eAAe,QAAW;AAC5B,aAAO;IACT;EACF;AAEA,QAAM,UAAgB,EAAE,KAAK,MAAM,KAAK,aAAa,YAAY,OAAU;AAE3E,OAAK,KAAK,IAAI,KAAK,OAAO;AAE1B,QAAM,qBAAqB,aAAa,KAAM,IAAY,UAAU,IAAI;AAGxE,QAAMD,cACJ,OAAO,uBAAuB,aAC1B,SAAS,mBAAmB,GAAG,IAAI,IACnC;AAEN,MAAIA,aAAY;AACd,YAAQ,KAAK,MAAMA,WAAU;EAC/B;AAEA,MAAI,KAAK,aAAa;AACpB,UAAM,oBAAoB,KAAK,YAAYA,aAAY,KAAK,IAAI;AAEhE,YAAQ,aAAaA;AAErB,WAAO;EACT;AAEA,UAAQ,aAAaA;AAErB,SAAOA;AACT;AAEA,IAAM,UAAU,CACd,MACA,SAMe;AACf,UAAQ,KAAK,cAAc;IACzB,KAAK;AACH,aAAO,EAAE,MAAM,KAAK,KAAK,KAAK,GAAG,EAAE;IACrC,KAAK;AACH,aAAO,EAAE,MAAM,gBAAgB,KAAK,aAAa,KAAK,IAAI,EAAE;IAC9D,KAAK;IACL,KAAK,QAAQ;AACX,UACE,KAAK,KAAK,SAAS,KAAK,YAAY,UACpC,KAAK,KAAK,MAAM,CAAC,OAAO,UAAU,KAAK,YAAY,KAAK,MAAM,KAAK,GACnE;AACA,gBAAQ;UACN,mCAAmC,KAAK,YAAY;YAClD;UACF,CAAC;QACH;AAEA,eAAO,YAAY;MACrB;AAEA,aAAO,KAAK,iBAAiB,SAAS,YAAY,IAAI;IACxD;EACF;AACF;AAEA,IAAM,UAAU,CACd,KACA,MACAA,gBACoB;AACpB,MAAI,IAAI,aAAa;AACnBA,gBAAW,cAAc,IAAI;EAC/B;AACA,SAAOA;AACT;AC5FO,IAAM,UAAU,CAAC,YAA8C;AACpE,QAAM,WAAW,kBAAkB,OAAO;AAC1C,QAAM,cACJ,SAAS,SAAS,SACd,CAAC,GAAG,SAAS,UAAU,SAAS,gBAAgB,SAAS,IAAI,IAC7D,SAAS;AACf,SAAO,iCACF,WADE;IAEL;IACA,cAAc;IACd,MAAM,IAAI;MACR,OAAO,QAAQ,SAAS,WAAW,EAAE,IAAI,CAAC,CAACM,QAAM,GAAG,MAAM;QACxD,IAAI;QACJ;UACE,KAAK,IAAI;UACT,MAAM,CAAC,GAAG,SAAS,UAAU,SAAS,gBAAgBA,MAAI;;UAE1D,YAAY;QACd;MACF,CAAC;IACH;EACF;AACF;AC/BA,IAAM,mBAAmB,CACvB,QACA,YAMG;AAfL,MAAAL;AAgBE,QAAM,OAAO,QAAQ,OAAO;AAE5B,MAAI,cACF,OAAO,YAAY,YAAY,QAAQ,cACnC,OAAO,QAAQ,QAAQ,WAAW,EAAE;IAClC,CAAC,KAAyC,CAACK,QAAMC,OAAM,MAAG;AArBpE,UAAAN;AAqBwE,aAAA,iCACzD,MADyD;QAE5D,CAACK,MAAI,IACHL,OAAA;UACEM,QAAO;UACP,iCACK,OADL;YAEE,aAAa,CAAC,GAAG,KAAK,UAAU,KAAK,gBAAgBD,MAAI;UAC3D;UACA;QACF,MAPA,OAAAL,OAOK,YAAY;MACrB;IAAA;IACA,CAAC;EACH,IACA;AAEN,QAAMK,SACJ,OAAO,YAAY,WACf,WACA,WAAA,OAAA,SAAA,QAAS,kBAAiB,UACxB,SACA,WAAA,OAAA,SAAA,QAAS;AAEjB,QAAM,QACJL,OAAA;IACE,OAAO;IACPK,WAAS,SACL,OACA,iCACK,OADL;MAEE,aAAa,CAAC,GAAG,KAAK,UAAU,KAAK,gBAAgBA,MAAI;IAC3D;IACJ;EACF,MATA,OAAAL,OASM,YAAY;AAEpB,QAAM,QACJ,OAAO,YAAY,YACnB,QAAQ,SAAS,UACjB,QAAQ,iBAAiB,UACrB,QAAQ,OACR;AAEN,MAAI,UAAU,QAAW;AACvB,SAAK,QAAQ;EACf;AAEA,QAAM,WACJK,WAAS,SACL,cACE,iCACK,OADL;IAEE,CAAC,KAAK,cAAc,GAAG;EACzB,KACA,OACF;IACE,MAAM;MACJ,GAAI,KAAK,iBAAiB,aAAa,CAAC,IAAI,KAAK;MACjD,KAAK;MACLA;IACF,EAAE,KAAK,GAAG;IACV,CAAC,KAAK,cAAc,GAAG,iCAClB,cADkB;MAErB,CAACA,MAAI,GAAG;IACV;EACF;AAEN,WAAS,UAAU;AAEnB,SAAO;AACT;ArChFA,IAAM,eAAe,OAAO,IAAI,kBAAkB;AAoF3C,SAAS,WACdE,aAIA;EACE;AACF,IAII,CAAC,GACW;AAChB,SAAO;IACL,CAAC,YAAY,GAAG;IAChB,OAAO;;IACP,IAAI,aAAa;AACf,UAAI,OAAOA,gBAAe,YAAY;AACpCA,sBAAaA,YAAW;MAC1B;AACA,aAAOA;IACT;IACA;EACF;AACF;AAEA,SAAS,SAAS,OAAiC;AACjD,SACE,OAAO,UAAU,YACjB,UAAU,QACV,gBAAgB,SAChB,MAAM,YAAY,MAAM,QACxB,gBAAgB,SAChB,cAAc;AAElB;AAEO,SAAS,SACd,QACgB;AAChB,SAAO,UAAU,OACb,WAAW,EAAE,YAAY,CAAC,GAAG,sBAAsB,MAAM,CAAC,IAC1D,SAAS,MAAM,IACb,SACA,eAAe,SACb,OAAO,WAAW,EAAE,WAAW,QAC7B,UAAU,MAA2B,IACrC,eAAe,MAAgC,IACjD,OAAO;AACjB;AAEA,SAAS,eACPC,iBACgB;AAChB,SAAO;IACL,MACEA,gBAAe,WAAW,EAAE,WAAW,MAAM;MAC3C,QAAQ;IACV,CAAC;IACH;MACE,UAAU,OAAM,UAAS;AACvB,cAAM,SAAS,MAAMA,gBAAe,WAAW,EAAE,SAAS,KAAK;AAC/D,eAAO,WAAW,SACd,EAAE,SAAS,MAAM,OAAO,OAAO,MAAM,IACrC;UACE,SAAS;UACT,OAAO,IAAI,oBAAoB;YAC7B;YACA,OAAO,OAAO;UAChB,CAAC;QACH;MACN;IACF;EACF;AACF;AAEO,SAAS,WACdC,YACA,SASgB;AArLlB,MAAAC;AAuLE,QAAM,iBAAgBA,OAAA,WAAA,OAAA,SAAA,QAAS,kBAAT,OAAAA,OAA0B;AAEhD,SAAO;;IAEL,MACE,iBAAiBD,YAAW;MAC1B,cAAc,gBAAgB,SAAS;IACzC,CAAC;IACH;MACE,UAAU,OAAM,UAAS;AACvB,cAAM,SAAS,MAAMA,WAAU,eAAe,KAAK;AACnD,eAAO,OAAO,UACV,EAAE,SAAS,MAAM,OAAO,OAAO,KAAK,IACpC,EAAE,SAAS,OAAO,OAAO,OAAO,MAAM;MAC5C;IACF;EACF;AACF;AAEO,SAAS,WACdA,YACA,SASgB;AArNlB,MAAAC;AAuNE,QAAM,iBAAgBA,OAAA,WAAA,OAAA,SAAA,QAAS,kBAAT,OAAAA,OAA0B;AAEhD,SAAO;;IAEL,MACE;MACK,gBAAaD,YAAW;QACzB,QAAQ;QACR,IAAI;QACJ,QAAQ,gBAAgB,QAAQ;MAClC,CAAC;IACH;IACF;MACE,UAAU,OAAM,UAAS;AACvB,cAAM,SAAS,MAAS,kBAAeA,YAAW,KAAK;AACvD,eAAO,OAAO,UACV,EAAE,SAAS,MAAM,OAAO,OAAO,KAAK,IACpC,EAAE,SAAS,OAAO,OAAO,OAAO,MAAM;MAC5C;IACF;EACF;AACF;AAEO,SAAS,aACdA,YACyC;AAEzC,SAAO,UAAUA;AACnB;AAEO,SAAS,UACdA,YAGA,SASgB;AAChB,MAAI,aAAaA,UAAS,GAAG;AAC3B,WAAO,WAAWA,YAAW,OAAO;EACtC,OAAO;AACL,WAAO,WAAWA,YAAW,OAAO;EACtC;AACF;AD5PA,eAAsB,cAAsB;EAC1C;EACA;AACF,GAGoB;AAClB,QAAM,SAAS,MAAM,kBAAkB,EAAE,OAAO,OAAO,CAAC;AAExD,MAAI,CAAC,OAAO,SAAS;AACnB,UAAME,oBAAoB,KAAK,EAAE,OAAO,OAAO,OAAO,MAAM,CAAC;EAC/D;AAEA,SAAO,OAAO;AAChB;AAWA,eAAsB,kBAA0B;EAC9C;EACA;AACF,GAcE;AACA,QAAM,eAAe,SAAS,MAAM;AAEpC,MAAI;AACF,QAAI,aAAa,YAAY,MAAM;AACjC,aAAO,EAAE,SAAS,MAAM,OAAwB,UAAU,MAAM;IAClE;AAEA,UAAM,SAAS,MAAM,aAAa,SAAS,KAAK;AAEhD,QAAI,OAAO,SAAS;AAClB,aAAO,EAAE,SAAS,MAAM,OAAO,OAAO,OAAO,UAAU,MAAM;IAC/D;AAEA,WAAO;MACL,SAAS;MACT,OAAOA,oBAAoB,KAAK,EAAE,OAAO,OAAO,OAAO,MAAM,CAAC;MAC9D,UAAU;IACZ;EACF,SAAS,OAAO;AACd,WAAO;MACL,SAAS;MACT,OAAOA,oBAAoB,KAAK,EAAE,OAAO,OAAO,MAAM,CAAC;MACvD,UAAU;IACZ;EACF;AACF;AFjDA,eAAsB,UAAa;EACjC;EACA;AACF,GAGe;AACb,MAAI;AACF,UAAM,QAAQ,gBAAgB,IAAI;AAElC,QAAI,UAAU,MAAM;AAClB,aAAO;IACT;AAEA,WAAO,cAAiB,EAAE,OAAO,OAAO,CAAC;EAC3C,SAAS,OAAO;AACd,QACE,eAAe,WAAW,KAAK,KAC/BA,oBAAoB,WAAW,KAAK,GACpC;AACA,YAAM;IACR;AAEA,UAAM,IAAI,eAAe,EAAE,MAAM,OAAO,MAAM,CAAC;EACjD;AACF;AAgCA,eAAsB,cAAiB;EACrC;EACA;AACF,GAG4B;AAC1B,MAAI;AACF,UAAM,QAAQ,gBAAgB,IAAI;AAElC,QAAI,UAAU,MAAM;AAClB,aAAO,EAAE,SAAS,MAAM,OAAmB,UAAU,MAAM;IAC7D;AAEA,WAAO,MAAM,kBAAqB,EAAE,OAAO,OAAO,CAAC;EACrD,SAAS,OAAO;AACd,WAAO;MACL,SAAS;MACT,OAAO,eAAe,WAAW,KAAK,IAClC,QACA,IAAI,eAAe,EAAE,MAAM,OAAO,MAAM,CAAC;MAC7C,UAAU;IACZ;EACF;AACF;AAEO,SAAS,eAAe,OAAwB;AACrD,MAAI;AACF,oBAAgB,KAAK;AACrB,WAAO;EACT,SAAQ,GAAA;AACN,WAAO;EACT;AACF;AyC/GO,SAAS,qBAAwB;EACtC;EACA;AACF,GAGmC;AACjC,SAAO,OACJ,YAAY,IAAI,kBAAkB,CAAC,EACnC,YAAY,IAAI,wBAAwB,CAAC,EACzC;IACC,IAAI,gBAAoD;MACtD,MAAM,UAAU,EAAE,KAAK,GAAG,YAAY;AAEpC,YAAI,SAAS,UAAU;AACrB;QACF;AAEA,mBAAW,QAAQ,MAAM,cAAc,EAAE,MAAM,MAAM,OAAO,CAAC,CAAC;MAChE;IACF,CAAC;EACH;AACJ;AErBA,IAAMC,oBAAmB,MAAM,WAAW;AAEnC,IAAM,gBAAgB,OAAU;EACrC;EACA;EACA;EACA;EACA;EACA;EACA,OAAAC;AACF,MASE,UAAU;EACR;EACA,SAAS;IACP,gBAAgB;KACb;EAEL,MAAM;IACJ,SAAS,KAAK,UAAU,IAAI;IAC5B,QAAQ;EACV;EACA;EACA;EACA;EACA,OAAAA;AACF,CAAC;AAgCI,IAAM,YAAY,OAAU;EACjC;EACA,UAAU,CAAC;EACX;EACA;EACA;EACA;EACA,OAAAC,SAAQC,kBAAiB;AAC3B,MAWM;AACJ,MAAI;AACF,UAAM,WAAW,MAAMD,OAAM,KAAK;MAChC,QAAQ;MACR,SAAS;QACP;QACA,yBAAyB,OAAO;QAChC,+BAA+B;MACjC;MACA,MAAM,KAAK;MACX,QAAQ;IACV,CAAC;AAED,UAAM,kBAAkB,uBAAuB,QAAQ;AAEvD,QAAI,CAAC,SAAS,IAAI;AAChB,UAAI;AAKJ,UAAI;AACF,2BAAmB,MAAM,sBAAsB;UAC7C;UACA;UACA,mBAAmB,KAAK;QAC1B,CAAC;MACH,SAAS,OAAO;AACd,YAAI,aAAa,KAAK,KAAKE,aAAa,WAAW,KAAK,GAAG;AACzD,gBAAM;QACR;AAEA,cAAM,IAAIA,aAAa;UACrB,SAAS;UACT,OAAO;UACP,YAAY,SAAS;UACrB;UACA;UACA,mBAAmB,KAAK;QAC1B,CAAC;MACH;AAEA,YAAM,iBAAiB;IACzB;AAEA,QAAI;AACF,aAAO,MAAM,0BAA0B;QACrC;QACA;QACA,mBAAmB,KAAK;MAC1B,CAAC;IACH,SAAS,OAAO;AACd,UAAI,iBAAiB,OAAO;AAC1B,YAAI,aAAa,KAAK,KAAKA,aAAa,WAAW,KAAK,GAAG;AACzD,gBAAM;QACR;MACF;AAEA,YAAM,IAAIA,aAAa;QACrB,SAAS;QACT,OAAO;QACP,YAAY,SAAS;QACrB;QACA;QACA,mBAAmB,KAAK;MAC1B,CAAC;IACH;EACF,SAAS,OAAO;AACd,UAAM,iBAAiB,EAAE,OAAO,KAAK,mBAAmB,KAAK,OAAO,CAAC;EACvE;AACF;AKpJO,IAAM,iCACX,CAAI;EACF;EACA;EACA;AACF,MAKA,OAAO,EAAE,UAAU,KAAK,kBAAkB,MAAM;AAC9C,QAAM,eAAe,MAAM,SAAS,KAAK;AACzC,QAAM,kBAAkB,uBAAuB,QAAQ;AAGvD,MAAI,aAAa,KAAK,MAAM,IAAI;AAC9B,WAAO;MACL;MACA,OAAO,IAAIC,aAAa;QACtB,SAAS,SAAS;QAClB;QACA;QACA,YAAY,SAAS;QACrB;QACA;QACA,aAAa,eAAA,OAAA,SAAA,YAAc,QAAA;MAC7B,CAAC;IACH;EACF;AAGA,MAAI;AACF,UAAM,cAAc,MAAM,UAAU;MAClC,MAAM;MACN,QAAQ;IACV,CAAC;AAED,WAAO;MACL;MACA,OAAO,IAAIA,aAAa;QACtB,SAAS,eAAe,WAAW;QACnC;QACA;QACA,YAAY,SAAS;QACrB;QACA;QACA,MAAM;QACN,aAAa,eAAA,OAAA,SAAA,YAAc,UAAU,WAAA;MACvC,CAAC;IACH;EACF,SAAS,YAAY;AACnB,WAAO;MACL;MACA,OAAO,IAAIA,aAAa;QACtB,SAAS,SAAS;QAClB;QACA;QACA,YAAY,SAAS;QACrB;QACA;QACA,aAAa,eAAA,OAAA,SAAA,YAAc,QAAA;MAC7B,CAAC;IACH;EACF;AACF;AAEK,IAAM,mCACX,CACE,gBAEF,OAAO,EAAE,SAAS,MAA8B;AAC9C,QAAM,kBAAkB,uBAAuB,QAAQ;AAEvD,MAAI,SAAS,QAAQ,MAAM;AACzB,UAAM,IAAI,uBAAuB,CAAC,CAAC;EACrC;AAEA,SAAO;IACL;IACA,OAAO,qBAAqB;MAC1B,QAAQ,SAAS;MACjB,QAAQ;IACV,CAAC;EACH;AACF;AAEK,IAAM,4BACX,CAAI,mBACJ,OAAO,EAAE,UAAU,KAAK,kBAAkB,MAAM;AAC9C,QAAM,eAAe,MAAM,SAAS,KAAK;AAEzC,QAAM,eAAe,MAAM,cAAc;IACvC,MAAM;IACN,QAAQ;EACV,CAAC;AAED,QAAM,kBAAkB,uBAAuB,QAAQ;AAEvD,MAAI,CAAC,aAAa,SAAS;AACzB,UAAM,IAAIA,aAAa;MACrB,SAAS;MACT,OAAO,aAAa;MACpB,YAAY,SAAS;MACrB;MACA;MACA;MACA;IACF,CAAC;EACH;AAEA,SAAO;IACL;IACA,OAAO,aAAa;IACpB,UAAU,aAAa;EACzB;AACF;;;AQpIF,gBAAkB;;;ACGX,SAAS,mBAAsB,OAAyC;AAC7E,SAAO,UAAU,QAAQ,UAAU;AACrC;;;ACLO,IAAK,kBAAL,kBAAKC,qBAAL;AACL,EAAAA,iBAAA,aAAU;AACV,EAAAA,iBAAA,uBAAoB;AACpB,EAAAA,iBAAA,oBAAiB;AACjB,EAAAA,iBAAA,uBAAoB;AACpB,EAAAA,iBAAA,oBAAiB;AALP,SAAAA;AAAA,GAAA;;;AFUL,IAAM,8BAA8B,YACxC,OAAO;AAAA,EACN,IAAI,YAAE,OAAO,EAAE,QAAQ;AAAA,EACvB,QAAQ,YAAE,KAAK,eAAe,EAAE,QAAQ;AAAA,EACxC,OAAO,YAAE,OAAO,EAAE,SAAS;AAC7B,CAAC,EACA,MAAM;AAEF,IAAM,+BAA+B,YACzC,OAAO;AAAA,EACN,MAAM,YAAE,QAAQ,iCAA2B;AAAA,EAC3C,SAAS,YAAE,OAAO;AACpB,CAAC,EACA,OAAO,4BAA4B,KAAK;AAKpC,IAAM,iCAAiC,YAC3C,OAAO;AAAA,EACN,MAAM,YAAE,QAAQ,qCAA6B;AAAA,EAC7C,MAAM,YAAE,OAAO;AACjB,CAAC,EACA,OAAO,4BAA4B,KAAK;AAMpC,IAAM,4BAA4B,YACtC,OAAO;AAAA,EACN,MAAM,YAAE,QAAQ,2BAAwB;AAAA,EACxC,MAAM,YAAE,OAAO,EAAE,QAAQ;AAAA,EACzB,WAAW,YAAE,OAAO,EAAE,QAAQ;AAChC,CAAC,EACA,OAAO,4BAA4B,KAAK;AAIpC,IAAM,6BAA6B,YAAE,MAAM;AAAA,EAChD;AAAA,EACA;AAAA,EACA;AACF,CAAC;AAID,IAAM,oCAAoC,YAAE,MAAM;AAAA,EAChD;AAAA,EACA,YAAE,QAAQ,EAAE,UAAU,MAAM,IAAI;AAClC,CAAC;AAEM,IAAM,6BAA6B,YACvC,MAAM,iCAAiC,EACvC,UAAU,CAAC,MAAM,EAAE,OAAO,CAACC,OAAiC,CAAC,CAACA,EAAC,CAAC;AAE5D,IAAM,sCAAsC,YAAE,MAAM;AAAA,EACzD,YACG,OAAO;AAAA,IACN,OAAO,YAAE,OAAO;AAAA,MACd,mBAAmB,YAAE,MAAM,iCAAiC;AAAA,IAC9D,CAAC;AAAA,EACH,CAAC,EACA;AAAA,IAAU,CAAC,SACV,KAAK,MAAM,kBAAkB,OAAO,kBAAkB;AAAA,EACxD;AAAA,EACF,YACG,OAAO;AAAA,IACN,SAAS,YAAE,OAAO;AAAA,MAChB,mBAAmB,YAAE,MAAM,iCAAiC;AAAA,IAC9D,CAAC;AAAA,EACH,CAAC,EACA;AAAA,IAAU,CAAC,SACV,KAAK,QAAQ,kBAAkB,OAAO,kBAAkB;AAAA,EAC1D;AAAA,EACF,YACG,OAAO;AAAA,IACN,MAAM,YAAE,OAAO;AAAA,IACf,mBAAmB,YAAE,MAAM,iCAAiC;AAAA,EAC9D,CAAC,EACA,UAAU,CAAC,SAAS,KAAK,kBAAkB,OAAO,kBAAkB,CAAC;AAC1E,CAAC;;;AGxFD,IAAAC,aAAkB;AAEX,IAAM,gCAAgC,aAC1C,OAAO;AAAA,EACN,OAAO,aACJ,OAAO;AAAA,IACN,MAAM,aACH,MAAM,CAAC,aAAE,OAAO,GAAG,aAAE,OAAO,CAAC,CAAC,EAC9B,SAAS,EACT,SAAS,EACT,QAAQ,IAAI;AAAA,IACf,SAAS,aAAE,OAAO;AAAA,IAClB,MAAM,aAAE,OAAO,EAAE,SAAS,EAAE,SAAS,EAAE,QAAQ,IAAI;AAAA,IACnD,OAAO,aAAE,IAAI,EAAE,SAAS,EAAE,SAAS,EAAE,QAAQ,IAAI;AAAA,EACnD,CAAC,EACA,YAAY;AAGjB,CAAC,EACA,YAAY;AAIR,IAAM,kCAAkC,+BAA+B;AAAA,EAC5E,aAAa;AAAA,EACb,gBAAgB,CAAC,SAA8B,KAAK,MAAM;AAC5D,CAAC;;;AC7BD,IAAAC,aAAkB;AAMX,IAAM,uBAAuB,aACjC,OAAO;AAAA,EACN,MAAM,aAAE,QAAQ,MAAM;AAAA,EACtB,MAAM,aACH,OAAO;AAAA,IACN,MAAM,aAAE,OAAO;AAAA,IACf,MAAM,aAAE,OAAO;AAAA,IACf,SAAS,aACN;AAAA,MACC,aACG,OAAO;AAAA,QACN,MAAM,aAAE,OAAO;AAAA,QACf,MAAM,aAAE,OAAO,EAAE,SAAS;AAAA,MAC5B,CAAC,EACA,SAAS,aAAE,IAAI,CAAC;AAAA,IACrB,EACC,SAAS;AAAA,EACd,CAAC,EACA,SAAS,aAAE,IAAI,CAAC;AACrB,CAAC,EACA,SAAS,aAAE,IAAI,CAAC;AAOZ,IAAM,mCAAmC,aAC7C,OAAO;AAAA,EACN,UAAU,aAAE,OAAO;AAAA,EACnB,mBAAmB,aAAE,MAAM,0BAA0B,EAAE,SAAS;AAAA,EAChE,aAAa,aAAE,MAAM,oBAAoB,EAAE,SAAS;AAAA,EACpD,OAAO,aACJ,OAAO;AAAA,IACN,cAAc,aAAE,OAAO;AAAA,IACvB,qBAAqB,aAClB,OAAO;AAAA,MACN,cAAc,aAAE,OAAO;AAAA,IACzB,CAAC,EACA,SAAS,aAAE,IAAI,CAAC,EAChB,SAAS;AAAA,IACZ,kBAAkB,aAAE,OAAO;AAAA,IAC3B,yBAAyB,aACtB,OAAO;AAAA,MACN,iBAAiB,aAAE,OAAO;AAAA,IAC5B,CAAC,EACA,SAAS,aAAE,IAAI,CAAC,EAChB,SAAS;AAAA,IACZ,aAAa,aAAE,OAAO;AAAA,IACtB,MAAM,aAAE,OAAO,EAAE,SAAS;AAAA,IAC1B,aAAa,aACV,OAAO;AAAA,MACN,uBAAuB,aAAE,OAAO;AAAA,IAClC,CAAC,EACA,SAAS,aAAE,IAAI,CAAC,EAChB,SAAS;AAAA,EACd,CAAC,EACA,SAAS,aAAE,IAAI,CAAC;AACrB,CAAC,EACA,SAAS,aAAE,IAAI,CAAC;AASZ,IAAM,kCAAkC,aAC5C,OAAO;AAAA,EACN,YAAY,aACT,OAAO;AAAA,IACN,mBAAmB,aAAE,MAAM,0BAA0B,EAAE,SAAS;AAAA,IAChE,aAAa,aAAE,MAAM,oBAAoB,EAAE,SAAS;AAAA,EACtD,CAAC,EACA,SAAS;AACd,CAAC,EACA,SAAS;;;ACzEZ,SAAS,aACP,cACqB;AACrB,UAAQ,cAAc;AAAA,IACpB,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AAAA,IACL,KAAK;AACH,aAAO;AAAA,IACT;AACE,aAAO;AAAA,EACX;AACF;AAEO,SAAS,0BACd,cAC6B;AAC7B,SAAO;AAAA,IACL,SAAS,aAAa,YAAY;AAAA,IAClC,KAAK,sCAAgB;AAAA,EACvB;AACF;AAEO,SAAS,mBACd,SACA,KAC6B;AAC7B,SAAO,EAAE,SAAS,IAAI;AACxB;;;AC1CA;AAkBO,IAAM,mCAAN,MAAuC;AAAA,EAAvC;AACL,uBAAS,WAAY,oBAAI,IAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOrC,OAAO,QAAuC;AAC5C,UAAM,MAAM,KAAK,gBAAgB,MAAM;AACvC,QAAI,QAAQ,MAAM;AAChB,aAAO;AAAA,IACT;AAEA,QAAI,mBAAK,WAAU,IAAI,GAAG,GAAG;AAC3B,aAAO;AAAA,IACT;AAEA,uBAAK,WAAU,IAAI,GAAG;AACtB,WAAO;AAAA,EACT;AAAA,EAEQ,gBAAgB,QAA6C;AAGnE,YAAQ,OAAO,MAAM;AAAA,MACnB;AACE,eAAO,OAAO;AAAA,MAEhB;AACE,YAAI,OAAO,IAAI;AACb,iBAAO,OAAO;AAAA,QAChB;AACA,eAAO,OAAO;AAAA,MAEhB,kCAA+B;AAC7B,YAAI,OAAO,MAAM;AACf,iBAAO,OAAO;AAAA,QAChB;AACA,YAAI,OAAO,WAAW;AACpB,iBAAO,OAAO;AAAA,QAChB;AACA,eAAO;AAAA,MACT;AAAA,MAEA,SAAS;AAEP,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AACF;AAlDW;;;ACuCJ,IAAM,2BAA2B;AAAA,EACtC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;;;ACpEO,SAAS,MAAM;AAAA,EACpB;AAAA,EACA;AACF,GAGY;AACV,MAAI;AACF,UAAM,SAAS,IAAI,IAAI,GAAG;AAE1B,WAAO,UAAU,IAAI,OAAO,QAAwB;AAAA,EACtD,SAAS,GAAG;AACV,WAAO;AAAA,EACT;AACF;;;ACPO,SAAS,WAAW;AAAA,EACzB;AAAA,EACA;AACF,GAGG;AAbH,MAAAC,MAAAC;AAcE,MAAI,KAAK,gBAAgB,YAAY;AACnC,UAAM,SAAS,0BAA0B,KAAK,IAAI;AAClD,WAAO,SAAQD,OAAA,KAAK,cAAL,OAAAA,OAAkB,gBAAgB,WAAW,MAAM;AAAA,EACpE;AAEA,QAAM,YAAY,KAAK,KAAK,SAAS;AAErC,MACE,MAAM;AAAA,IACJ,KAAK;AAAA,IACL,WAAW,oBAAI,IAAI,CAAC,SAAS,QAAQ,CAAU;AAAA,EACjD,CAAC,GACD;AACA,WAAO;AAAA,EACT;AAEA,SAAO,UAAU,WAAW,OAAO,IAC/B,YACA,SAAQC,OAAA,KAAK,cAAL,OAAAA,OAAkB,gBAAgB,WAAW,SAAS;AACpE;AAEO,SAAS,aACd,SACA,kBACQ;AAtCV,MAAAD;AAuCE,QAAM,QAAQ,QAAQ,MAAM,eAAe;AAC3C,SAAO,SAASA,OAAA,MAAM,CAAC,MAAP,OAAAA,OAAY,mBAAoB;AAClD;AAEO,SAAS,qBAAqB,SAAyB;AAC5D,QAAM,QAAQ,QAAQ,MAAM,0BAA0B;AACtD,SAAO,QAAQ,MAAM,CAAC,IAAK;AAC7B;AAGO,IAAM,iBAAwD;AAAA;AAAA,EAEnE,MAAM;AAAA,EACN,KAAK;AAAA;AAAA,EAEL,SAAS;AAAA,EACT,MAAM;AAAA,EACN,KAAK;AAAA;AAAA,EAEL,KAAK;AAAA,EACL,QAAQ;AAAA;AAAA,EAER,KAAK;AAAA,EACL,SAAS;AAAA;AAAA,EAET,KAAK;AAAA,EACL,SAAS;AAAA,EACT,KAAK;AAAA;AAAA,EAEL,MAAM;AAAA,EACN,UAAU;AAAA;AAAA,EAEV,MAAM;AAAA,EACN,UAAU;AAAA;AAAA,EAEV,OAAO;AAAA,EACP,OAAO;AACT;AA0BO,SAAS,kBAAkB,MAGhC;AACA,QAAM,WAAW,WAAW;AAAA,IAC1B;AAAA,IACA,kBAAkB;AAAA,EACpB,CAAC;AAGD,MACE,MAAM;AAAA,IACJ,KAAK;AAAA,IACL,WAAW,oBAAI,IAAI,CAAC,SAAS,QAAQ,CAAU;AAAA,EACjD,CAAC,GACD;AACA,UAAM,IAAI;AAAA,MACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAOF;AAAA,EACF;AAGA,QAAM,OAAO,qBAAqB,QAAQ;AAG1C,QAAM,YAAY,KAAK,aAAa;AACpC,QAAM,YAAY,UAAU,QAAQ,UAAU,EAAE;AAGhD,QAAM,SAAS,eAAe,SAAS;AAEvC,MAAI,WAAW,QAAW;AACxB,UAAM,gBAAgB,yBAAyB,KAAK,IAAI;AACxD,UAAM,IAAI;AAAA,MACR,8BAA8B,SAAS;AAAA;AAAA,mDACe,aAAa;AAAA;AAAA;AAAA,IAErE;AAAA,EACF;AAEA,SAAO,EAAE,MAAM,OAAO;AACxB;;;AChIA,SAAS,gBACP,kBACoC;AAvBtC,MAAAE,MAAAC,MAAA;AAwBE,QAAM,YAAY,qDAAkB;AACpC,QAAM,aAAa,qDAAkB;AAGrC,UAAQ,MAAAA,QAAAD,OAAA,yCAAY,iBAAZ,OAAAA,OACN,yCAAY,kBADN,OAAAC,OAEN,uCAAW,iBAFL,YAGN,uCAAW;AACf;AAEO,SAAS,gCACd,QACgC;AApClC,MAAAD,MAAAC,MAAA;AAqCE,QAAM,WAA2C,CAAC;AAMlD,QAAM,0BAA0B,IAAI,iCAAiC;AAErE,aAAW,EAAE,MAAM,SAAS,gBAAgB,KAAK,QAAQ;AACvD,YAAQ,MAAM;AAAA,MACZ,KAAK,UAAU;AACb,iBAAS,KAAK;AAAA,UACZ,MAAM;AAAA,UACN;AAAA,UACA,eAAe,gBAAgB,eAAe;AAAA,QAChD,CAAC;AACD;AAAA,MACF;AAAA,MAEA,KAAK,QAAQ;AACX,YAAI,QAAQ,WAAW,OAAKD,OAAA,QAAQ,CAAC,MAAT,gBAAAA,KAAY,UAAS,QAAQ;AACvD,gBAAM,gBACJC,OAAA,gBAAgB,eAAe,MAA/B,OAAAA,OACA,gBAAgB,QAAQ,CAAC,EAAE,eAAe;AAC5C,gBAAM,0BACJ,eACI;AAAA,YACE;AAAA,cACE,MAAM;AAAA,cACN,MAAM,QAAQ,CAAC,EAAE;AAAA,cACjB,eAAe;AAAA,YACjB;AAAA,UACF,IACA,QAAQ,CAAC,EAAE;AACjB,mBAAS,KAAK;AAAA,YACZ,MAAM;AAAA,YACN,SAAS;AAAA,UACX,CAAC;AACD;AAAA,QACF;AAGA,cAAM,sBAAsB,gBAAgB,eAAe;AAG3D,YAAI,oBAAoB;AACxB,iBAAS,IAAI,QAAQ,SAAS,GAAG,KAAK,GAAG,KAAK;AAC5C,gBAAI,aAAQ,CAAC,MAAT,mBAAY,UAAS,QAAQ;AAC/B,gCAAoB;AACpB;AAAA,UACF;AAAA,QACF;AAEA,cAAM,eAA4C,QAAQ;AAAA,UACxD,CAAC,MAAyD,UAAU;AA3F9E,gBAAAD,MAAAC,MAAAC,KAAAC,KAAAC,KAAAC;AA4FY,kBAAM,iBACJ,KAAK,SAAS,UAAU,UAAU;AACpC,kBAAM,mBAAmB,gBAAgB,KAAK,eAAe;AAE7D,kBAAM,eACJ,KAAK,SAAS,SACT,8CACA,iBAAiB,sBAAsB,SACxC;AAEN,oBAAQ,KAAK,MAAM;AAAA,cACjB,KAAK;AACH,uBAAO;AAAA,kBACL,MAAM;AAAA,kBACN,MAAM,KAAK;AAAA,mBACP,gBAAgB,EAAE,eAAe,aAAa;AAAA,cAEtD,KAAK,QAAQ;AACX,qBAAIL,OAAA,KAAK,cAAL,gBAAAA,KAAgB,WAAW,WAAW;AACxC,wBAAM,MAAM,WAAW;AAAA,oBACrB;AAAA,oBACA,kBAAkB;AAAA,kBACpB,CAAC;AACD,yBAAO;AAAA,oBACL,MAAM;AAAA,oBACN,WAAW;AAAA,sBACT;AAAA,oBACF;AAAA,qBACI,gBAAgB,EAAE,eAAe,aAAa;AAAA,gBAEtD;AAGA,qBAAIC,OAAA,KAAK,cAAL,gBAAAA,KAAgB,WAAW,WAAW;AACxC,yBAAO;AAAA,oBACL,MAAM;AAAA,oBACN,aAAa,kBAAkB,IAAI;AAAA,qBAC/B,gBAAgB,EAAE,eAAe,aAAa;AAAA,gBAEtD;AAEA,sBAAM,WAAW;AAAA,mBACfI,OAAAD,OAAAD,OAAAD,MAAA,KAAK,oBAAL,gBAAAA,IAAsB,eAAtB,gBAAAC,IAAkC,aAAlC,OAAAC,MACE,KAAK,aADP,OAAAC,MAEE;AAAA,gBACJ;AAEA,sBAAM,WAAW,WAAW;AAAA,kBAC1B;AAAA,kBACA,kBAAkB;AAAA,gBACpB,CAAC;AAED,oBACE,MAAM;AAAA,kBACJ,KAAK;AAAA,kBACL,WAAW,oBAAI,IAAI,CAAC,SAAS,QAAQ,CAAU;AAAA,gBACjD,CAAC,GACD;AACA,yBAAO;AAAA,oBACL,MAAM;AAAA,oBACN,MAAM;AAAA,sBACJ,UAAU;AAAA,sBACV,WAAW;AAAA,oBACb;AAAA,kBACF;AAAA,gBACF;AAEA,uBAAO;AAAA,kBACL,MAAM;AAAA,kBACN,MAAM;AAAA,oBACJ,UAAU;AAAA,oBACV,WAAW;AAAA,kBACb;AAAA,mBACI,gBAAgB,EAAE,eAAe,aAAa;AAAA,cAEtD;AAAA,cACA,SAAS;AACP,uBAAO;AAAA,kBACL,MAAM;AAAA,kBACN,MAAM;AAAA,mBACF,gBAAgB,EAAE,eAAe,aAAa;AAAA,cAEtD;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAGA,iBAAS,KAAK;AAAA,UACZ,MAAM;AAAA,UACN,SAAS;AAAA,QACX,CAAC;AAED;AAAA,MACF;AAAA,MAEA,KAAK,aAAa;AAChB,YAAI,OAAO;AACX,YAAI,YAAY;AAChB,cAAM,YAID,CAAC;AAEN,mBAAW,QAAQ,SAAS;AAC1B,kBAAQ,KAAK,MAAM;AAAA,YACjB,KAAK,QAAQ;AACX,sBAAQ,KAAK;AACb;AAAA,YACF;AAAA,YACA,KAAK,aAAa;AAChB,wBAAU,KAAK;AAAA,gBACb,IAAI,KAAK;AAAA,gBACT,MAAM;AAAA,gBACN,UAAU;AAAA,kBACR,MAAM,KAAK;AAAA,kBACX,WAAW,KAAK,UAAU,KAAK,KAAK;AAAA,gBACtC;AAAA,cACF,CAAC;AACD;AAAA,YACF;AAAA,YACA,KAAK,aAAa;AAChB,2BAAa,KAAK;AAClB;AAAA,YACF;AAAA,YACA,KAAK;AACH;AAAA,YACF,SAAS;AACP;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAGA,cAAM,wBACJ,gCAAgC,UAAU,eAAe;AAC3D,cAAM,0BAA0B,sBAAsB,WAClD,iCAAsB,SAAtB,mBAA4B,eAA5B,mBAAwC,oBACxC;AACJ,cAAM,qBAAqB,sBAAsB,WAC7C,iCAAsB,SAAtB,mBAA4B,eAA5B,mBAAwC,cACxC;AAKJ,cAAM,4BACJ,2BACA,MAAM,QAAQ,uBAAuB,KACrC,wBAAwB,SAAS,IAC7B,0BACA,0BAA0B,OAAO;AAMvC,YAAI;AACJ,YAAI,6BAA6B,0BAA0B,SAAS,GAAG;AACrE,gBAAM,gBAAwC,CAAC;AAC/C,qBAAW,UAAU,2BAA2B;AAC9C,gBAAI,wBAAwB,OAAO,MAAM,GAAG;AAC1C,4BAAc,KAAK,MAAM;AAAA,YAC3B;AAAA,UACF;AACA,kCACE,cAAc,SAAS,IAAI,gBAAgB;AAAA,QAC/C;AAEA,iBAAS,KAAK;AAAA,UACZ,MAAM;AAAA,UACN,SAAS;AAAA,UACT,YAAY,UAAU,SAAS,IAAI,YAAY;AAAA,UAC/C,WAAW,aAAa;AAAA,UACxB,mBAAmB;AAAA,UACnB,aAAa;AAAA,UACb,eAAe,gBAAgB,eAAe;AAAA,QAChD,CAAC;AAED;AAAA,MACF;AAAA,MAEA,KAAK,QAAQ;AACX,mBAAW,gBAAgB,SAAS;AAElC,cAAI,aAAa,SAAS,0BAA0B;AAClD;AAAA,UACF;AACA,gBAAMC,WAAU,qBAAqB,YAAY;AAEjD,mBAAS,KAAK;AAAA,YACZ,MAAM;AAAA,YACN,cAAc,aAAa;AAAA,YAC3B,SAAAA;AAAA,YACA,gBACE,qBAAgB,eAAe,MAA/B,YACA,gBAAgB,aAAa,eAAe;AAAA,UAChD,CAAC;AAAA,QACH;AACA;AAAA,MACF;AAAA,MAEA,SAAS;AACP;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAEA,SAAS,qBAAqB,OAA8C;AAhT5E,MAAAN;AAiTE,UAAQ,MAAM,OAAO,MAAM;AAAA,IACzB,KAAK;AAAA,IACL,KAAK;AACH,aAAO,MAAM,OAAO;AAAA,IACtB,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AACH,aAAO,KAAK,UAAU,MAAM,OAAO,KAAK;AAAA,IAC1C,KAAK;AACH,cAAOA,OAAA,MAAM,OAAO,WAAb,OAAAA,OAAuB;AAAA,EAClC;AACF;AASA,SAAS,0BACP,SAIoC;AA1UtC,MAAAA,MAAAC,MAAA;AA4UE,aAAW,QAAQ,SAAS;AAC1B,QAAI,KAAK,SAAS,aAAa;AAC7B,YAAM,cAAaD,OAAA,KAAK,oBAAL,gBAAAA,KAAsB;AAGzC,YAAM,UAAU,yCAAY;AAC5B,UAAI,MAAM,QAAQ,OAAO,KAAK,QAAQ,SAAS,GAAG;AAChD,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AAGA,aAAW,QAAQ,SAAS;AAC1B,QAAI,KAAK,SAAS,aAAa;AAC7B,YAAM,SAAS,gCAAgC;AAAA,QAC7C,KAAK;AAAA,MACP;AACA,UACE,OAAO,aACP,MAAAC,OAAA,OAAO,SAAP,gBAAAA,KAAa,eAAb,mBAAyB,sBACzB,OAAO,KAAK,WAAW,kBAAkB,SAAS,GAClD;AACA,eAAO,OAAO,KAAK,WAAW;AAAA,MAChC;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;;;ACtWA,IAAAM,aAAkB;AAElB,IAAM,iCAAiC,aAAE,MAAM;AAAA,EAC7C,aAAE,QAAQ,MAAM;AAAA,EAChB,aAAE,QAAQ,MAAM;AAAA,EAChB,aAAE,QAAQ,UAAU;AAAA,EACpB,aAAE,OAAO;AAAA,IACP,MAAM,aAAE,QAAQ,UAAU;AAAA,IAC1B,UAAU,aAAE,OAAO;AAAA,MACjB,MAAM,aAAE,OAAO;AAAA,IACjB,CAAC;AAAA,EACH,CAAC;AACH,CAAC;AAIM,SAAS,4BACd,YAC0B;AAC1B,UAAQ,WAAW,MAAM;AAAA,IACvB,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AACH,aAAO,WAAW;AAAA,IACpB,KAAK,QAAQ;AACX,aAAO;AAAA,QACL,MAAM;AAAA,QACN,UAAU,EAAE,MAAM,WAAW,SAAS;AAAA,MACxC;AAAA,IACF;AAAA,IACA,SAAS;AACP;AACA,YAAM,IAAI,qBAAqB;AAAA,QAC7B,UAAU;AAAA,QACV,SAAS,6BAA6B,KAAK,UAAU,UAAU,CAAC;AAAA,MAClE,CAAC;AAAA,IACH;AAAA,EACF;AACF;;;ACzCA,IAAAC,aAAkB;;;ACAlB,IAAAC,aAAkB;AAElB,IAAM,sBAAsB,aACzB,OAAO;AAAA,EACN,MAAM,aAAE,QAAQ,WAAW;AAAA,EAC3B,WAAW,aACR,OAAO;AAAA,IACN,KAAK,aAAE,OAAO;AAAA,EAChB,CAAC,EACA,YAAY;AACjB,CAAC,EACA,YAAY;AAIf,IAAM,iCAAiC,aAAE,MAAM;AAAA,EAC7C;AAAA,EACA,aAAE,QAAQ,EAAE,UAAU,MAAM,IAAI;AAClC,CAAC;AAEM,IAAM,2BAA2B,aACrC,MAAM,8BAA8B,EACpC,UAAU,CAAC,MAAM,EAAE,OAAO,CAACC,OAA0B,CAAC,CAACA,EAAC,CAAC;;;ADjB5D,IAAM,6CAA6C,aAChD,OAAO;AAAA,EACN,IAAI,aAAE,OAAO,EAAE,SAAS;AAAA,EACxB,OAAO,aAAE,OAAO,EAAE,SAAS;AAAA,EAC3B,UAAU,aAAE,OAAO,EAAE,SAAS;AAAA,EAC9B,OAAO,aACJ,OAAO;AAAA,IACN,eAAe,aAAE,OAAO;AAAA,IACxB,uBAAuB,aACpB,OAAO;AAAA,MACN,eAAe,aAAE,OAAO;AAAA,IAC1B,CAAC,EACA,YAAY,EACZ,QAAQ;AAAA,IACX,mBAAmB,aAAE,OAAO;AAAA,IAC5B,2BAA2B,aACxB,OAAO;AAAA,MACN,kBAAkB,aAAE,OAAO;AAAA,IAC7B,CAAC,EACA,YAAY,EACZ,QAAQ;AAAA,IACX,cAAc,aAAE,OAAO;AAAA,IACvB,MAAM,aAAE,OAAO,EAAE,SAAS;AAAA,IAC1B,cAAc,aACX,OAAO;AAAA,MACN,yBAAyB,aAAE,OAAO,EAAE,QAAQ;AAAA,IAC9C,CAAC,EACA,YAAY,EACZ,QAAQ;AAAA,EACb,CAAC,EACA,YAAY,EACZ,QAAQ;AACb,CAAC,EACA,YAAY;AAGR,IAAM,kDAAkD,aAAE,MAAM;AAAA;AAAA,EAErE,2CAA2C,OAAO;AAAA,IAChD,SAAS,aAAE;AAAA,MACT,aACG,OAAO;AAAA,QACN,SAAS,aACN,OAAO;AAAA,UACN,MAAM,aAAE,QAAQ,WAAW;AAAA,UAC3B,SAAS,aAAE,OAAO,EAAE,SAAS,EAAE,SAAS;AAAA,UACxC,WAAW,aAAE,OAAO,EAAE,SAAS,EAAE,SAAS;AAAA,UAC1C,mBAAmB,2BAA2B,QAAQ;AAAA,UACtD,QAAQ,yBAAyB,QAAQ;AAAA,UAEzC,YAAY,aACT;AAAA,YACC,aACG,OAAO;AAAA,cACN,IAAI,aAAE,OAAO,EAAE,SAAS,EAAE,SAAS;AAAA,cACnC,MAAM,aAAE,QAAQ,UAAU;AAAA,cAC1B,UAAU,aACP,OAAO;AAAA,gBACN,MAAM,aAAE,OAAO;AAAA,gBACf,WAAW,aAAE,OAAO,EAAE,SAAS;AAAA,cACjC,CAAC,EACA,YAAY;AAAA,YACjB,CAAC,EACA,YAAY;AAAA,UACjB,EACC,SAAS;AAAA,UAEZ,aAAa,aACV;AAAA,YACC,aAAE,MAAM;AAAA;AAAA;AAAA,cAGN,aACG,OAAO;AAAA,gBACN,MAAM,aAAE,QAAQ,cAAc;AAAA,gBAC9B,cAAc,aACX,OAAO;AAAA,kBACN,KAAK,aAAE,OAAO;AAAA,kBACd,OAAO,aAAE,OAAO,EAAE,SAAS;AAAA,kBAC3B,aAAa,aAAE,OAAO,EAAE,SAAS;AAAA,kBACjC,WAAW,aAAE,OAAO,EAAE,SAAS;AAAA,kBAC/B,SAAS,aAAE,OAAO,EAAE,SAAS;AAAA,gBAC/B,CAAC,EACA,YAAY;AAAA,cACjB,CAAC,EACA,YAAY;AAAA;AAAA,cAEf,aACG,OAAO;AAAA,gBACN,MAAM,aAAE,QAAQ,iBAAiB;AAAA,gBACjC,iBAAiB,aACd,OAAO;AAAA,kBACN,SAAS,aAAE,OAAO;AAAA,kBAClB,OAAO,aAAE,OAAO,EAAE,SAAS;AAAA,gBAC7B,CAAC,EACA,YAAY;AAAA,cACjB,CAAC,EACA,YAAY;AAAA;AAAA,cAEf,aACG,OAAO;AAAA,gBACN,MAAM,aAAE,QAAQ,MAAM;AAAA,gBACtB,MAAM,aACH,OAAO;AAAA,kBACN,MAAM,aAAE,OAAO;AAAA,kBACf,MAAM,aAAE,OAAO;AAAA,kBACf,SAAS,aACN;AAAA,oBACC,aACG,OAAO;AAAA,sBACN,MAAM,aAAE,OAAO;AAAA,sBACf,MAAM,aAAE,OAAO,EAAE,SAAS;AAAA,oBAC5B,CAAC,EACA,YAAY;AAAA,kBACjB,EACC,SAAS;AAAA,gBACd,CAAC,EACA,YAAY;AAAA,cACjB,CAAC,EACA,YAAY;AAAA,YACjB,CAAC;AAAA,UACH,EACC,QAAQ;AAAA,QACb,CAAC,EACA,YAAY;AAAA,QACf,OAAO,aAAE,OAAO,EAAE,QAAQ;AAAA,QAC1B,UAAU,aACP,OAAO;AAAA,UACN,SAAS,aACN;AAAA,YACC,aACG,OAAO;AAAA,cACN,OAAO,aAAE,OAAO;AAAA,cAChB,SAAS,aAAE,OAAO;AAAA,cAClB,cAAc,aAAE;AAAA,gBACd,aACG,OAAO;AAAA,kBACN,OAAO,aAAE,OAAO;AAAA,kBAChB,SAAS,aAAE,OAAO;AAAA,gBACpB,CAAC,EACA,YAAY;AAAA,cACjB;AAAA,YACF,CAAC,EACA,YAAY;AAAA,UACjB,EACC,SAAS;AAAA,QACd,CAAC,EACA,YAAY,EACZ,SAAS,EACT,SAAS;AAAA,QACZ,eAAe,aAAE,OAAO,EAAE,SAAS,EAAE,SAAS;AAAA,MAChD,CAAC,EACA,YAAY;AAAA,IACjB;AAAA,EACF,CAAC;AAAA;AAAA,EAED,8BAA8B,OAAO;AAAA,IACnC,SAAS,aAAE,OAAO,EAAE,SAAS;AAAA,EAC/B,CAAC;AACH,CAAC;AAGM,IAAM,4CAA4C,aAAE,MAAM;AAAA,EAC/D,2CAA2C,OAAO;AAAA,IAChD,SAAS,aAAE;AAAA,MACT,aACG,OAAO;AAAA,QACN,OAAO,aACJ,OAAO;AAAA,UACN,MAAM,aAAE,KAAK,CAAC,WAAW,CAAC,EAAE,SAAS;AAAA,UACrC,SAAS,aAAE,OAAO,EAAE,QAAQ;AAAA,UAC5B,WAAW,aAAE,OAAO,EAAE,QAAQ,EAAE,SAAS;AAAA,UACzC,mBAAmB,2BAA2B,QAAQ;AAAA,UACtD,QAAQ,yBAAyB,QAAQ;AAAA,UACzC,YAAY,aACT;AAAA,YACC,aACG,OAAO;AAAA,cACN,OAAO,aAAE,OAAO,EAAE,QAAQ;AAAA,cAC1B,IAAI,aAAE,OAAO,EAAE,QAAQ;AAAA,cACvB,MAAM,aAAE,QAAQ,UAAU,EAAE,SAAS;AAAA,cACrC,UAAU,aACP,OAAO;AAAA,gBACN,MAAM,aAAE,OAAO,EAAE,QAAQ;AAAA,gBACzB,WAAW,aAAE,OAAO,EAAE,QAAQ;AAAA,cAChC,CAAC,EACA,YAAY;AAAA,YACjB,CAAC,EACA,YAAY;AAAA,UACjB,EACC,QAAQ;AAAA,UAEX,aAAa,aACV;AAAA,YACC,aAAE,MAAM;AAAA;AAAA;AAAA,cAGN,aACG,OAAO;AAAA,gBACN,MAAM,aAAE,QAAQ,cAAc;AAAA,gBAC9B,cAAc,aACX,OAAO;AAAA,kBACN,KAAK,aAAE,OAAO;AAAA,kBACd,OAAO,aAAE,OAAO,EAAE,SAAS;AAAA,kBAC3B,aAAa,aAAE,OAAO,EAAE,SAAS;AAAA,kBACjC,WAAW,aAAE,OAAO,EAAE,SAAS;AAAA,kBAC/B,SAAS,aAAE,OAAO,EAAE,SAAS;AAAA,gBAC/B,CAAC,EACA,YAAY;AAAA,cACjB,CAAC,EACA,YAAY;AAAA;AAAA,cAEf,aACG,OAAO;AAAA,gBACN,MAAM,aAAE,QAAQ,iBAAiB;AAAA,gBACjC,iBAAiB,aACd,OAAO;AAAA,kBACN,SAAS,aAAE,OAAO;AAAA,kBAClB,OAAO,aAAE,OAAO,EAAE,SAAS;AAAA,gBAC7B,CAAC,EACA,YAAY;AAAA,cACjB,CAAC,EACA,YAAY;AAAA;AAAA,cAEf,aACG,OAAO;AAAA,gBACN,MAAM,aAAE,QAAQ,MAAM;AAAA,gBACtB,MAAM,aACH,OAAO;AAAA,kBACN,MAAM,aAAE,OAAO;AAAA,kBACf,MAAM,aAAE,OAAO;AAAA,kBACf,SAAS,aACN;AAAA,oBACC,aACG,OAAO;AAAA,sBACN,MAAM,aAAE,OAAO;AAAA,sBACf,MAAM,aAAE,OAAO,EAAE,SAAS;AAAA,oBAC5B,CAAC,EACA,YAAY;AAAA,kBACjB,EACC,SAAS;AAAA,gBACd,CAAC,EACA,YAAY;AAAA,cACjB,CAAC,EACA,YAAY;AAAA,YACjB,CAAC;AAAA,UACH,EACC,QAAQ;AAAA,QACb,CAAC,EACA,YAAY,EACZ,QAAQ;AAAA,QACX,UAAU,aACP,OAAO;AAAA,UACN,SAAS,aACN;AAAA,YACC,aACG,OAAO;AAAA,cACN,OAAO,aAAE,OAAO;AAAA,cAChB,SAAS,aAAE,OAAO;AAAA,cAClB,cAAc,aAAE;AAAA,gBACd,aACG,OAAO;AAAA,kBACN,OAAO,aAAE,OAAO;AAAA,kBAChB,SAAS,aAAE,OAAO;AAAA,gBACpB,CAAC,EACA,YAAY;AAAA,cACjB;AAAA,YACF,CAAC,EACA,YAAY;AAAA,UACjB,EACC,SAAS;AAAA,QACd,CAAC,EACA,YAAY,EACZ,QAAQ;AAAA,QACX,eAAe,aAAE,OAAO,EAAE,SAAS,EAAE,SAAS;AAAA,QAC9C,OAAO,aAAE,OAAO,EAAE,QAAQ;AAAA,MAC5B,CAAC,EACA,YAAY;AAAA,IACjB;AAAA,EACF,CAAC;AAAA,EACD;AACF,CAAC;;;AEjOM,IAAM,8BAAN,MAA6D;AAAA,EAmBlE,YACE,SACA,UACA,QACA;AAtBF,SAAS,uBAAuB;AAChC,SAAS,WAAW;AACpB,SAAS,8BAA8B;AAGvC,SAAS,oBAAoB;AAC7B,SAAS,gBAA0C;AAAA,MACjD,WAAW;AAAA,QACT;AAAA,QACA;AAAA,MACF;AAAA;AAAA,MAEA,iBAAiB,CAAC,uBAAuB,iBAAiB;AAAA,IAC5D;AAUE,SAAK,UAAU;AACf,SAAK,WAAW;AAChB,SAAK,SAAS;AAAA,EAChB;AAAA,EAEQ,QAAQ;AAAA,IACd;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAA+B;AAvGjC,QAAAC;AAwGI,UAAM,WAAW;AAAA;AAAA,MAEf,OAAO,KAAK;AAAA,MACZ,QAAQ,KAAK,SAAS;AAAA;AAAA,MAGtB,YAAY,KAAK,SAAS;AAAA,MAC1B,UACE,KAAK,SAAS,aAAa,QAC3B,OAAO,KAAK,SAAS,aAAa,WAC9B,OACA;AAAA,MACN,cACE,OAAO,KAAK,SAAS,aAAa,WAC9B,KAAK,SAAS,WACd,OAAO,KAAK,SAAS,aAAa,YAChC,KAAK,SAAS,WACZ,IACA,SACF;AAAA,MACR,MAAM,KAAK,SAAS;AAAA,MACpB,qBAAqB,KAAK,SAAS;AAAA;AAAA,MAGnC,YAAY;AAAA,MACZ;AAAA,MACA,OAAO;AAAA,MACP,mBAAmB;AAAA,MACnB,kBAAkB;AAAA,MAClB;AAAA,MAEA,MAAM;AAAA,MACN,kBACE,iDAAgB,UAAS,SACrB,eAAe,UAAU,OACvB;AAAA,QACE,MAAM;AAAA,QACN,aAAa;AAAA,UACX,QAAQ,eAAe;AAAA,UACvB,QAAQ;AAAA,UACR,OAAMA,OAAA,eAAe,SAAf,OAAAA,OAAuB;AAAA,WACzB,eAAe,eAAe;AAAA,UAChC,aAAa,eAAe;AAAA,QAC9B;AAAA,MAEJ,IACA,EAAE,MAAM,cAAc,IACxB;AAAA,MACN,OAAO;AAAA;AAAA,MAGP,UAAU,gCAAgC,MAAM;AAAA;AAAA,MAGhD,mBAAmB,KAAK,SAAS;AAAA,MACjC,WAAW,KAAK,SAAS;AAAA,MACzB,OAAO,KAAK,SAAS;AAAA;AAAA,MAGrB,SAAS,KAAK,SAAS;AAAA,MACvB,oBAAoB,KAAK,SAAS;AAAA;AAAA,MAElC,UAAU,KAAK,SAAS;AAAA;AAAA,MAExB,OAAO,KAAK,SAAS;AAAA,OAGlB,KAAK,OAAO,YACZ,KAAK,SAAS;AAGnB,QAAI,SAAS,MAAM,SAAS,GAAG;AAE7B,YAAM,cAAc,MACjB;AAAA,QACC,CAAC,SACC,KAAK,SAAS;AAAA,MAClB,EACC,IAAI,CAAC,UAAU;AAAA,QACd,MAAM;AAAA,QACN,UAAU;AAAA,UACR,MAAM,KAAK;AAAA,UACX,aAAa,KAAK;AAAA,UAClB,YAAY,KAAK;AAAA,QACnB;AAAA,MACF,EAAE;AAEJ,aAAO,iCACF,WADE;AAAA,QAEL,OAAO;AAAA,QACP,aAAa,aACT,4BAA4B,UAAU,IACtC;AAAA,MACN;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,WAAW,SAiBd;AA5NL,QAAAA,MAAAC,MAAA;AA6NI,UAAM,kBAAkB,QAAQ,mBAAmB,CAAC;AACpD,UAAM,oBAAoB,gBAAgB,cAAc,CAAC;AAEzD,UAAM,OAAO,kCACR,KAAK,QAAQ,OAAO,IACpB;AAGL,UAAM,EAAE,OAAO,eAAe,gBAAgB,IAAI,MAAM,cAAc;AAAA,MACpE,KAAK,KAAK,OAAO,IAAI;AAAA,QACnB,MAAM;AAAA,QACN,SAAS,KAAK;AAAA,MAChB,CAAC;AAAA,MACD,SAAS,eAAe,KAAK,OAAO,QAAQ,GAAG,QAAQ,OAAO;AAAA,MAC9D,MAAM;AAAA,MACN,uBAAuB;AAAA,MACvB,2BAA2B;AAAA,QACzB;AAAA,MACF;AAAA,MACA,aAAa,QAAQ;AAAA,MACrB,OAAO,KAAK,OAAO;AAAA,IACrB,CAAC;AAGD,QAAI,WAAW,eAAe;AAC5B,YAAM,YAAY,cAAc;AAIhC,YAAM,IAAI,aAAa;AAAA,QACrB,SAAS,UAAU;AAAA,QACnB,KAAK,KAAK,OAAO,IAAI;AAAA,UACnB,MAAM;AAAA,UACN,SAAS,KAAK;AAAA,QAChB,CAAC;AAAA,QACD,mBAAmB;AAAA,QACnB,YAAY;AAAA,QACZ;AAAA,QACA,MAAM;AAAA,MACR,CAAC;AAAA,IACH;AAGA,UAAM,WAAW;AAEjB,UAAM,SAAS,SAAS,QAAQ,CAAC;AAEjC,QAAI,CAAC,QAAQ;AACX,YAAM,IAAI,wBAAwB;AAAA,QAChC,SAAS;AAAA,MACX,CAAC;AAAA,IACH;AAGA,UAAM,YAAkC,SAAS,QAC7C;AAAA,MACE,aAAa;AAAA,QACX,QAAOD,OAAA,SAAS,MAAM,kBAAf,OAAAA,OAAgC;AAAA,QACvC,SAAS;AAAA,QACT,YACE,MAAAC,OAAA,SAAS,MAAM,0BAAf,gBAAAA,KAAsC,kBAAtC,YAAuD;AAAA,QACzD,YAAY;AAAA,MACd;AAAA,MACA,cAAc;AAAA,QACZ,QAAO,cAAS,MAAM,sBAAf,YAAoC;AAAA,QAC3C,MAAM;AAAA,QACN,YACE,oBAAS,MAAM,8BAAf,mBAA0C,qBAA1C,YACA;AAAA,MACJ;AAAA,MACA,KAAK,SAAS;AAAA,IAChB,IACA;AAAA,MACE,aAAa;AAAA,QACX,OAAO;AAAA,QACP,SAAS;AAAA,QACT,WAAW;AAAA,QACX,YAAY;AAAA,MACd;AAAA,MACA,cAAc;AAAA,QACZ,OAAO;AAAA,QACP,MAAM;AAAA,QACN,WAAW;AAAA,MACb;AAAA,MACA,KAAK;AAAA,IACP;AAEJ,UAAM,oBAAmB,YAAO,QAAQ,sBAAf,YAAoC,CAAC;AAE9D,UAAM,YACJ,iBAAiB,SAAS,IACrB,iBACE,IAAI,CAAC,WAAW;AACf,cAAQ,OAAO,MAAM;AAAA,QACnB,kCAA+B;AAC7B,cAAI,OAAO,MAAM;AACf,mBAAO;AAAA,cACL,MAAM;AAAA,cACN,MAAM,OAAO;AAAA,cACb,kBAAkB;AAAA,gBAChB,YAAY;AAAA,kBACV,mBAAmB,CAAC,MAAM;AAAA,gBAC5B;AAAA,cACF;AAAA,YACF;AAAA,UACF;AACA;AAAA,QACF;AAAA,QACA,wCAAkC;AAChC,cAAI,OAAO,SAAS;AAClB,mBAAO;AAAA,cACL,MAAM;AAAA,cACN,MAAM,OAAO;AAAA,cACb,kBAAkB;AAAA,gBAChB,YAAY;AAAA,kBACV,mBAAmB,CAAC,MAAM;AAAA,gBAC5B;AAAA,cACF;AAAA,YACF;AAAA,UACF;AACA;AAAA,QACF;AAAA,QACA,4CAAoC;AAElC,cAAI,OAAO,MAAM;AACf,mBAAO;AAAA,cACL,MAAM;AAAA,cACN,MAAM;AAAA,cACN,kBAAkB;AAAA,gBAChB,YAAY;AAAA,kBACV,mBAAmB,CAAC,MAAM;AAAA,gBAC5B;AAAA,cACF;AAAA,YACF;AAAA,UACF;AACA;AAAA,QACF;AAAA,QACA,SAAS;AACP;AAAA,QACF;AAAA,MACF;AACA,aAAO;AAAA,IACT,CAAC,EACA,OAAO,CAAC,MAAM,MAAM,IAAI,IAC3B,OAAO,QAAQ,YACb;AAAA,MACE;AAAA,QACE,MAAM;AAAA,QACN,MAAM,OAAO,QAAQ;AAAA,MACvB;AAAA,IACF,IACA,CAAC;AAET,UAAM,UAAyC,CAAC;AAGhD,YAAQ,KAAK,GAAG,SAAS;AAEzB,QAAI,OAAO,QAAQ,SAAS;AAC1B,cAAQ,KAAK;AAAA,QACX,MAAM;AAAA,QACN,MAAM,OAAO,QAAQ;AAAA,MACvB,CAAC;AAAA,IACH;AAEA,QAAI,OAAO,QAAQ,YAAY;AAG7B,UAAI,qCAAqC;AACzC,iBAAW,YAAY,OAAO,QAAQ,YAAY;AAChD,gBAAQ,KAAK;AAAA,UACX,MAAM;AAAA,UACN,aAAY,cAAS,OAAT,YAAe,WAAW;AAAA,UACtC,UAAU,SAAS,SAAS;AAAA,UAC5B,QAAO,cAAS,SAAS,cAAlB,YAA+B;AAAA,UACtC,kBAAkB,CAAC,qCACf;AAAA,YACE,YAAY;AAAA,cACV,mBAAmB;AAAA,YACrB;AAAA,UACF,IACA;AAAA,QACN,CAAC;AACD,6CAAqC;AAAA,MACvC;AAAA,IACF;AAEA,QAAI,OAAO,QAAQ,QAAQ;AACzB,iBAAW,SAAS,OAAO,QAAQ,QAAQ;AACzC,gBAAQ,KAAK;AAAA,UACX,MAAM;AAAA,UACN,WAAW,aAAa,MAAM,UAAU,KAAK,YAAY;AAAA,UACzD,MAAM,qBAAqB,MAAM,UAAU,GAAG;AAAA,QAChD,CAAC;AAAA,MACH;AAAA,IACF;AAEA,QAAI,OAAO,QAAQ,aAAa;AAC9B,iBAAW,cAAc,OAAO,QAAQ,aAAa;AACnD,YAAI,WAAW,SAAS,gBAAgB;AACtC,kBAAQ,KAAK;AAAA,YACX,MAAM;AAAA,YACN,YAAY;AAAA,YACZ,IAAI,WAAW,aAAa;AAAA,YAC5B,KAAK,WAAW,aAAa;AAAA,YAC7B,QAAO,gBAAW,aAAa,UAAxB,YAAiC;AAAA,YACxC,kBAAkB;AAAA,cAChB,YAAY;AAAA,gBACV,UAAS,gBAAW,aAAa,YAAxB,YAAmC;AAAA,gBAC5C,aAAY,gBAAW,aAAa,gBAAxB,YAAuC;AAAA,gBACnD,WAAU,gBAAW,aAAa,cAAxB,YAAqC;AAAA,cACjD;AAAA,YACF;AAAA,UACF,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF;AAGA,UAAM,mBAAkB,YAAO,QAAQ,gBAAf,mBAA4B;AAAA,MAClD,CACE,MAQG,EAAE,SAAS;AAAA;AAMlB,UAAM,eACJ,OAAO,QAAQ,cAAc,OAAO,QAAQ,WAAW,SAAS;AAClE,UAAM,wBAAwB,iBAAiB;AAAA,MAC7C,CAAC,MAAM,EAAE,kDAA0C,EAAE;AAAA,IACvD;AACA,UAAM,6BACJ,gBAAgB,yBAAyB,OAAO,kBAAkB;AAEpE,UAAM,wBAAwB,6BAC1B,mBAAmB,eAAc,YAAO,kBAAP,YAAwB,MAAS,IAClE,0BAA0B,OAAO,aAAa;AAElD,WAAO;AAAA,MACL;AAAA,MACA,cAAc;AAAA,MACd,OAAO;AAAA,MACP,UAAU,CAAC;AAAA,MACX,kBAAkB;AAAA,QAChB,YAAY,iCAAiC,MAAM;AAAA,UACjD,WAAU,cAAS,aAAT,YAAqB;AAAA,UAC/B,oBAAmB,YAAO,QAAQ,sBAAf,YAAoC,CAAC;AAAA,UACxD,aACE,mBAAmB,gBAAgB,SAAS,IACxC,kBACA;AAAA,UACN,OAAO;AAAA,YACL,eAAc,eAAU,YAAY,UAAtB,YAA+B;AAAA,YAC7C,mBAAkB,eAAU,aAAa,UAAvB,YAAgC;AAAA,YAClD,eACG,eAAU,YAAY,UAAtB,YAA+B,OAC/B,eAAU,aAAa,UAAvB,YAAgC;AAAA,eAC/B,cAAS,UAAT,mBAAgB,SAAQ,OACxB,EAAE,MAAM,SAAS,MAAM,KAAK,IAC5B,CAAC,MACD,oBAAS,UAAT,mBAAgB,0BAAhB,mBAAuC,kBAAiB,OACxD;AAAA,YACE,qBAAqB;AAAA,cACnB,cACE,SAAS,MAAM,sBAAsB;AAAA,YACzC;AAAA,UACF,IACA,CAAC,MACD,oBAAS,UAAT,mBAAgB,8BAAhB,mBAA2C,qBAC/C,OACI;AAAA,YACE,yBAAyB;AAAA,cACvB,iBACE,SAAS,MAAM,0BAA0B;AAAA,YAC7C;AAAA,UACF,IACA,CAAC,MACD,oBAAS,UAAT,mBAAgB,iBAAhB,mBAA8B,4BAA2B,OACzD;AAAA,YACE,aAAa;AAAA,cACX,uBACE,SAAS,MAAM,aAAa;AAAA,YAChC;AAAA,UACF,IACA,CAAC;AAAA,QAET,CAAC;AAAA,MACH;AAAA,MACA,SAAS,EAAE,MAAM,KAAK;AAAA,MACtB,UAAU;AAAA,QACR,IAAI,SAAS;AAAA,QACb,SAAS,SAAS;AAAA,QAClB,SAAS;AAAA,MACX;AAAA,IACF;AAAA,EACF;AAAA,EAEA,MAAM,SAAS,SAQZ;AAvhBL,QAAAD;AAwhBI,UAAM,kBAAkB,QAAQ,mBAAmB,CAAC;AACpD,UAAM,oBAAoB,gBAAgB,cAAc,CAAC;AAEzD,UAAM,OAAO,kCACR,KAAK,QAAQ,OAAO,IACpB;AAGL,UAAM,EAAE,OAAO,UAAU,gBAAgB,IAAI,MAAM,cAAc;AAAA,MAC/D,KAAK,KAAK,OAAO,IAAI;AAAA,QACnB,MAAM;AAAA,QACN,SAAS,KAAK;AAAA,MAChB,CAAC;AAAA,MACD,SAAS,eAAe,KAAK,OAAO,QAAQ,GAAG,QAAQ,OAAO;AAAA,MAC9D,MAAM,iCACD,OADC;AAAA,QAEJ,QAAQ;AAAA;AAAA,QAGR,gBACE,KAAK,OAAO,kBAAkB,WAC1B;AAAA,UACE,eAAe;AAAA,aAEXA,OAAA,KAAK,SAAS,UAAd,gBAAAA,KAAqB,WACrB,EAAE,eAAe,KAAK,IACtB,CAAC,KAEP;AAAA,MACR;AAAA,MACA,uBAAuB;AAAA,MACvB,2BAA2B;AAAA,QACzB;AAAA,MACF;AAAA,MACA,aAAa,QAAQ;AAAA,MACrB,OAAO,KAAK,OAAO;AAAA,IACrB,CAAC;AAED,UAAM,YASD,CAAC;AAEN,QAAI,eAA4C,mBAAmB,OAAO;AAC1E,UAAM,QAA8B;AAAA,MAClC,aAAa;AAAA,QACX,OAAO;AAAA,QACP,SAAS;AAAA,QACT,WAAW;AAAA,QACX,YAAY;AAAA,MACd;AAAA,MACA,cAAc;AAAA,QACZ,OAAO;AAAA,QACP,MAAM;AAAA,QACN,WAAW;AAAA,MACb;AAAA,MACA,KAAK;AAAA,IACP;AAGA,UAAM,kBAAsD,CAAC;AAG7D,QAAI;AAGJ,UAAM,8BAAsD,CAAC;AAK7D,QAAI,qCAAqC;AAGzC,UAAM,6BAA+C,CAAC;AAEtD,QAAI,cAAc;AAClB,QAAI,mBAAmB;AACvB,QAAI;AACJ,QAAI;AACJ,QAAI;AACJ,QAAI;AAEJ,WAAO;AAAA,MACL,QAAQ,SAAS;AAAA,QACf,IAAI,gBAKF;AAAA,UACA,UAAU,OAAO,YAAY;AAznBvC,gBAAAA,MAAAC,MAAA;AA2nBY,gBAAI,QAAQ,kBAAkB;AAC5B,yBAAW,QAAQ,EAAE,MAAM,OAAO,UAAU,MAAM,SAAS,CAAC;AAAA,YAC9D;AAGA,gBAAI,CAAC,MAAM,SAAS;AAClB,6BAAe,mBAAmB,OAAO;AACzC,yBAAW,QAAQ,EAAE,MAAM,SAAS,OAAO,MAAM,MAAM,CAAC;AACxD;AAAA,YACF;AAEA,kBAAM,QAAQ,MAAM;AAGpB,gBAAI,WAAW,OAAO;AACpB,6BAAe,mBAAmB,OAAO;AACzC,yBAAW,QAAQ,EAAE,MAAM,SAAS,OAAO,MAAM,MAAM,CAAC;AACxD;AAAA,YACF;AAEA,gBAAI,MAAM,UAAU;AAClB,yBAAW,MAAM;AAAA,YACnB;AAEA,gBAAI,MAAM,IAAI;AACZ,qCAAuB,MAAM;AAC7B,yBAAW,QAAQ;AAAA,gBACjB,MAAM;AAAA,gBACN,IAAI,MAAM;AAAA,cACZ,CAAC;AAAA,YACH;AAEA,gBAAI,MAAM,OAAO;AACf,yBAAW,QAAQ;AAAA,gBACjB,MAAM;AAAA,gBACN,SAAS,MAAM;AAAA,cACjB,CAAC;AAAA,YACH;AAEA,gBAAI,MAAM,SAAS,MAAM;AACvB,oBAAM,YAAY,QAAQ,MAAM,MAAM;AACtC,oBAAM,aAAa,QAAQ,MAAM,MAAM;AAGvC,yBAAW,MAAM;AAGjB,8BAAgB,eAAe,MAAM,MAAM;AAE3C,kBAAI,MAAM,MAAM,uBAAuB;AACrC,sBAAM,qBACJD,OAAA,MAAM,MAAM,sBAAsB,kBAAlC,OAAAA,OAAmD;AAErD,sBAAM,YAAY,YAAY;AAC9B,gCAAgB,sBAAsB;AAAA,kBACpC,cAAc;AAAA,gBAChB;AAAA,cACF;AAEA,8BAAgB,mBAAmB,MAAM,MAAM;AAC/C,kBAAI,MAAM,MAAM,2BAA2B;AACzC,sBAAM,mBACJC,OAAA,MAAM,MAAM,0BAA0B,qBAAtC,OAAAA,OAA0D;AAE5D,sBAAM,aAAa,YAAY;AAC/B,gCAAgB,0BAA0B;AAAA,kBACxC;AAAA,gBACF;AAAA,cACF;AAEA,kBAAI,MAAM,MAAM,QAAQ,MAAM;AAC5B,gCAAgB,OAAO,MAAM,MAAM;AAAA,cACrC;AACA,8BAAgB,cAAc,MAAM,MAAM;AAC1C,oBAAM,yBACJ,WAAM,MAAM,iBAAZ,mBAA0B;AAC5B,kBAAI,yBAAyB,MAAM;AACjC,gCAAgB,cAAc;AAAA,kBAC5B;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAEA,kBAAM,SAAS,MAAM,QAAQ,CAAC;AAE9B,iBAAI,iCAAQ,kBAAiB,MAAM;AACjC,6BAAe,0BAA0B,OAAO,aAAa;AAAA,YAC/D;AAEA,iBAAI,iCAAQ,UAAS,MAAM;AACzB;AAAA,YACF;AAEA,kBAAM,QAAQ,OAAO;AAErB,kBAAM,qBAAqB,CACzB,WACA,qBACG;AACH,kBAAI,CAAC,kBAAkB;AACrB,8BAAc,wBAAwB,WAAW;AACjD,2BAAW,QAAQ;AAAA,kBACjB;AAAA,kBACA,MAAM;AAAA,kBACN,IAAI;AAAA,gBACN,CAAC;AACD,mCAAmB;AAAA,cACrB;AACA,yBAAW,QAAQ;AAAA,gBACjB;AAAA,gBACA,MAAM;AAAA,gBACN,OAAO;AAAA,gBACP,IAAI,eAAe,WAAW;AAAA,cAChC,CAAC;AAAA,YACH;AAEA,gBAAI,MAAM,qBAAqB,MAAM,kBAAkB,SAAS,GAAG;AAGjE,yBAAW,UAAU,MAAM,mBAAmB;AAC5C,oBAAI,OAAO,sCAAmC;AAC5C,wBAAM,aACJ,4BACE,4BAA4B,SAAS,CACvC;AACF,uBAAI,yCAAY,uCAAmC;AAEjD,+BAAW,QACR,WAAW,QAAQ,OAAO,OAAO,QAAQ;AAE5C,+BAAW,YACT,WAAW,aAAa,OAAO;AAEjC,+BAAW,SAAS,WAAW,UAAU,OAAO;AAAA,kBAClD,OAAO;AAEL,gDAA4B,KAAK,mBAAK,OAAQ;AAAA,kBAChD;AAAA,gBACF,OAAO;AAEL,8CAA4B,KAAK,MAAM;AAAA,gBACzC;AAAA,cACF;AAIA,oBAAM,oBAA8C;AAAA,gBAClD,YAAY;AAAA,kBACV,mBAAmB,MAAM;AAAA,gBAC3B;AAAA,cACF;AAEA,yBAAW,UAAU,MAAM,mBAAmB;AAC5C,wBAAQ,OAAO,MAAM;AAAA,kBACnB,kCAA+B;AAC7B,wBAAI,OAAO,MAAM;AACf,yCAAmB,OAAO,MAAM,iBAAiB;AAAA,oBACnD;AACA;AAAA,kBACF;AAAA,kBACA,4CAAoC;AAClC,wBAAI,OAAO,MAAM;AACf,yCAAmB,cAAc,iBAAiB;AAAA,oBACpD;AACA;AAAA,kBACF;AAAA,kBACA,wCAAkC;AAChC,wBAAI,OAAO,SAAS;AAClB,yCAAmB,OAAO,SAAS,iBAAiB;AAAA,oBACtD;AACA;AAAA,kBACF;AAAA,kBACA,SAAS;AACP;AACA;AAAA,kBACF;AAAA,gBACF;AAAA,cACF;AAAA,YACF,WAAW,MAAM,WAAW;AAC1B,iCAAmB,MAAM,SAAS;AAAA,YACpC;AAEA,gBAAI,MAAM,SAAS;AAGjB,kBAAI,oBAAoB,CAAC,aAAa;AACpC,2BAAW,QAAQ;AAAA,kBACjB,MAAM;AAAA,kBACN,IAAI,eAAe,WAAW;AAAA,gBAChC,CAAC;AACD,mCAAmB;AAAA,cACrB;AAEA,kBAAI,CAAC,aAAa;AAChB,yBAAS,wBAAwB,WAAW;AAC5C,2BAAW,QAAQ;AAAA,kBACjB,MAAM;AAAA,kBACN,IAAI;AAAA,gBACN,CAAC;AACD,8BAAc;AAAA,cAChB;AACA,yBAAW,QAAQ;AAAA,gBACjB,MAAM;AAAA,gBACN,OAAO,MAAM;AAAA,gBACb,IAAI,UAAU,WAAW;AAAA,cAC3B,CAAC;AAAA,YACH;AAEA,gBAAI,MAAM,aAAa;AACrB,yBAAW,cAAc,MAAM,aAAa;AAC1C,oBAAI,WAAW,SAAS,gBAAgB;AACtC,6BAAW,QAAQ;AAAA,oBACjB,MAAM;AAAA,oBACN,YAAY;AAAA,oBACZ,IAAI,WAAW,aAAa;AAAA,oBAC5B,KAAK,WAAW,aAAa;AAAA,oBAC7B,QAAO,gBAAW,aAAa,UAAxB,YAAiC;AAAA,oBACxC,kBAAkB;AAAA,sBAChB,YAAY;AAAA,wBACV,UAAS,gBAAW,aAAa,YAAxB,YAAmC;AAAA,wBAC5C,aAAY,gBAAW,aAAa,gBAAxB,YAAuC;AAAA,wBACnD,WAAU,gBAAW,aAAa,cAAxB,YAAqC;AAAA,sBACjD;AAAA,oBACF;AAAA,kBACF,CAAC;AAAA,gBACH,WAAW,WAAW,SAAS,QAAQ;AAGrC,wBAAM,OAAQ,WAAkC;AAChD,sBACE,QACA,OAAO,SAAS,YAChB,UAAU,QACV,UAAU,MACV;AACA,+CAA2B;AAAA,sBACzB;AAAA,oBACF;AAAA,kBACF;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAEA,gBAAI,MAAM,cAAc,MAAM;AAC5B,yBAAW,iBAAiB,MAAM,YAAY;AAC5C,sBAAM,SAAQ,mBAAc,UAAd,YAAuB,UAAU,SAAS;AAGxD,oBAAI,UAAU,KAAK,KAAK,MAAM;AAC5B,sBAAI,cAAc,SAAS,YAAY;AACrC,0BAAM,IAAI,yBAAyB;AAAA,sBACjC,MAAM;AAAA,sBACN,SAAS;AAAA,oBACX,CAAC;AAAA,kBACH;AAEA,sBAAI,cAAc,MAAM,MAAM;AAC5B,0BAAM,IAAI,yBAAyB;AAAA,sBACjC,MAAM;AAAA,sBACN,SAAS;AAAA,oBACX,CAAC;AAAA,kBACH;AAEA,wBAAI,mBAAc,aAAd,mBAAwB,SAAQ,MAAM;AACxC,0BAAM,IAAI,yBAAyB;AAAA,sBACjC,MAAM;AAAA,sBACN,SAAS;AAAA,oBACX,CAAC;AAAA,kBACH;AAEA,4BAAU,KAAK,IAAI;AAAA,oBACjB,IAAI,cAAc;AAAA,oBAClB,MAAM;AAAA,oBACN,UAAU;AAAA,sBACR,MAAM,cAAc,SAAS;AAAA,sBAC7B,YAAW,mBAAc,SAAS,cAAvB,YAAoC;AAAA,oBACjD;AAAA,oBACA,cAAc;AAAA,oBACd,MAAM;AAAA,kBACR;AAEA,wBAAMC,YAAW,UAAU,KAAK;AAEhC,sBAAIA,aAAY,MAAM;AACpB,0BAAM,IAAI,yBAAyB;AAAA,sBACjC,MAAM,EAAE,OAAO,iBAAiB,UAAU,OAAO;AAAA,sBACjD,SAAS,sBAAsB,KAAK;AAAA,oBACtC,CAAC;AAAA,kBACH;AAGA,wBACE,KAAAA,UAAS,aAAT,mBAAmB,SAAQ,UAC3B,KAAAA,UAAS,aAAT,mBAAmB,cAAa,QAChC,eAAeA,UAAS,SAAS,SAAS,GAC1C;AACA,oBAAAA,UAAS,eAAe;AAExB,+BAAW,QAAQ;AAAA,sBACjB,MAAM;AAAA,sBACN,IAAIA,UAAS;AAAA,sBACb,UAAUA,UAAS,SAAS;AAAA,oBAC9B,CAAC;AAGD,+BAAW,QAAQ;AAAA,sBACjB,MAAM;AAAA,sBACN,IAAIA,UAAS;AAAA,sBACb,OAAOA,UAAS,SAAS;AAAA,oBAC3B,CAAC;AAED,+BAAW,QAAQ;AAAA,sBACjB,MAAM;AAAA,sBACN,IAAIA,UAAS;AAAA,oBACf,CAAC;AAKD,+BAAW,QAAQ;AAAA,sBACjB,MAAM;AAAA,sBACN,YAAYA,UAAS;AAAA,sBACrB,UAAUA,UAAS,SAAS;AAAA,sBAC5B,OAAOA,UAAS,SAAS;AAAA,sBACzB,kBAAkB,CAAC,qCACf;AAAA,wBACE,YAAY;AAAA,0BACV,mBAAmB;AAAA,wBACrB;AAAA,sBACF,IACA;AAAA,oBACN,CAAC;AAED,yDAAqC;AACrC,oBAAAA,UAAS,OAAO;AAAA,kBAClB;AAEA;AAAA,gBACF;AAGA,sBAAM,WAAW,UAAU,KAAK;AAEhC,oBAAI,YAAY,MAAM;AACpB,wBAAM,IAAI,yBAAyB;AAAA,oBACjC,MAAM;AAAA,sBACJ;AAAA,sBACA,iBAAiB,UAAU;AAAA,sBAC3B;AAAA,oBACF;AAAA,oBACA,SAAS,sBAAsB,KAAK;AAAA,kBACtC,CAAC;AAAA,gBACH;AAEA,oBAAI,CAAC,SAAS,cAAc;AAC1B,2BAAS,eAAe;AACxB,6BAAW,QAAQ;AAAA,oBACjB,MAAM;AAAA,oBACN,IAAI,SAAS;AAAA,oBACb,UAAU,SAAS,SAAS;AAAA,kBAC9B,CAAC;AAAA,gBACH;AAEA,sBAAI,mBAAc,aAAd,mBAAwB,cAAa,MAAM;AAC7C,2BAAS,SAAS,cAChB,yBAAc,aAAd,mBAAwB,cAAxB,YAAqC;AAAA,gBACzC;AAGA,2BAAW,QAAQ;AAAA,kBACjB,MAAM;AAAA,kBACN,IAAI,SAAS;AAAA,kBACb,QAAO,mBAAc,SAAS,cAAvB,YAAoC;AAAA,gBAC7C,CAAC;AAGD,sBACE,cAAS,aAAT,mBAAmB,SAAQ,UAC3B,cAAS,aAAT,mBAAmB,cAAa,QAChC,eAAe,SAAS,SAAS,SAAS,GAC1C;AAGA,6BAAW,QAAQ;AAAA,oBACjB,MAAM;AAAA,oBACN,aAAY,cAAS,OAAT,YAAe,WAAW;AAAA,oBACtC,UAAU,SAAS,SAAS;AAAA,oBAC5B,OAAO,SAAS,SAAS;AAAA,oBACzB,kBAAkB,CAAC,qCACf;AAAA,sBACE,YAAY;AAAA,wBACV,mBAAmB;AAAA,sBACrB;AAAA,oBACF,IACA;AAAA,kBACN,CAAC;AAED,uDAAqC;AACrC,2BAAS,OAAO;AAAA,gBAClB;AAAA,cACF;AAAA,YACF;AAEA,gBAAI,MAAM,UAAU,MAAM;AACxB,yBAAW,SAAS,MAAM,QAAQ;AAChC,2BAAW,QAAQ;AAAA,kBACjB,MAAM;AAAA,kBACN,WAAW,aAAa,MAAM,UAAU,KAAK,YAAY;AAAA,kBACzD,MAAM,qBAAqB,MAAM,UAAU,GAAG;AAAA,gBAChD,CAAC;AAAA,cACH;AAAA,YACF;AAAA,UACF;AAAA,UAEA,MAAM,YAAY;AAzhC5B,gBAAAF;AA6hCY,kBAAM,eAAe,UAAU,SAAS;AACxC,kBAAM,wBAAwB,4BAA4B;AAAA,cACxD,CAAC,MAAM,EAAE,kDAA0C,EAAE;AAAA,YACvD;AACA,gBACE,gBACA,yBACA,aAAa,YAAY,QACzB;AACA,6BAAe,mBAAmB,cAAc,aAAa,GAAG;AAAA,YAClE;AAGA,gBAAI,aAAa,YAAY,cAAc;AACzC,yBAAW,YAAY,WAAW;AAChC,oBAAI,YAAY,CAAC,SAAS,MAAM;AAG9B,6BAAW,QAAQ;AAAA,oBACjB,MAAM;AAAA,oBACN,aAAYA,OAAA,SAAS,OAAT,OAAAA,OAAe,WAAW;AAAA,oBACtC,UAAU,SAAS,SAAS;AAAA;AAAA,oBAE5B,OAAO,eAAe,SAAS,SAAS,SAAS,IAC7C,SAAS,SAAS,YAClB;AAAA,oBACJ,kBAAkB,CAAC,qCACf;AAAA,sBACE,YAAY;AAAA,wBACV,mBAAmB;AAAA,sBACrB;AAAA,oBACF,IACA;AAAA,kBACN,CAAC;AACD,uDAAqC;AACrC,2BAAS,OAAO;AAAA,gBAClB;AAAA,cACF;AAAA,YACF;AAGA,gBAAI,kBAAkB;AACpB,yBAAW,QAAQ;AAAA,gBACjB,MAAM;AAAA,gBACN,IAAI,eAAe,WAAW;AAAA,cAChC,CAAC;AAAA,YACH;AACA,gBAAI,aAAa;AACf,yBAAW,QAAQ;AAAA,gBACjB,MAAM;AAAA,gBACN,IAAI,UAAU,WAAW;AAAA,cAC3B,CAAC;AAAA,YACH;AAEA,kBAAM,qBAKF;AAAA,cACF,OAAO;AAAA,YACT;AAGA,gBAAI,aAAa,QAAW;AAC1B,iCAAmB,WAAW;AAAA,YAChC;AAGA,gBAAI,4BAA4B,SAAS,GAAG;AAC1C,iCAAmB,oBACjB;AAAA,YACJ;AAGA,gBAAI,2BAA2B,SAAS,GAAG;AACzC,iCAAmB,cAAc;AAAA,YACnC;AAGA,kBAAM,MAAM;AAEZ,uBAAW,QAAQ;AAAA,cACjB,MAAM;AAAA,cACN;AAAA,cACA;AAAA,cACA,kBAAkB;AAAA,gBAChB,YAAY;AAAA,cACd;AAAA,YACF,CAAC;AAAA,UACH;AAAA,QACF,CAAC;AAAA,MACH;AAAA,MACA,UAAU,CAAC;AAAA,MACX,SAAS,EAAE,MAAM,KAAK;AAAA,MACtB,UAAU,EAAE,SAAS,gBAAgB;AAAA,IACvC;AAAA,EACF;AACF;;;ACjnCO,SAAS,oCAAoC;AAAA,EAClD;AAAA,EACA;AAAA,EACA,OAAO;AAAA,EACP,YAAY;AACd,GAOE;AAEA,MACE,gBAAgB,YAChB,OAAO,WAAW,KAClB,OAAO,CAAC,KACR,OAAO,CAAC,EAAE,SAAS,UACnB,OAAO,CAAC,EAAE,QAAQ,WAAW,KAC7B,OAAO,CAAC,EAAE,QAAQ,CAAC,KACnB,OAAO,CAAC,EAAE,QAAQ,CAAC,EAAE,SAAS,QAC9B;AACA,WAAO,EAAE,QAAQ,OAAO,CAAC,EAAE,QAAQ,CAAC,EAAE,KAAK;AAAA,EAC7C;AAGA,MAAI,OAAO;AAGX,MAAI,OAAO,CAAC,KAAK,OAAO,CAAC,EAAE,SAAS,UAAU;AAC5C,YAAQ,GAAG,OAAO,CAAC,EAAE,OAAO;AAAA;AAAA;AAC5B,aAAS,OAAO,MAAM,CAAC;AAAA,EACzB;AAEA,aAAW,EAAE,MAAM,QAAQ,KAAK,QAAQ;AACtC,YAAQ,MAAM;AAAA,MACZ,KAAK,UAAU;AACb,cAAM,IAAI,mBAAmB;AAAA,UAC3B,SAAS,wCAAwC,OAAO;AAAA,UACxD;AAAA,QACF,CAAC;AAAA,MACH;AAAA,MAEA,KAAK,QAAQ;AACX,cAAM,cAAc,QACjB,IAAI,CAAC,SAA4D;AAChE,kBAAQ,KAAK,MAAM;AAAA,YACjB,KAAK,QAAQ;AACX,qBAAO,KAAK;AAAA,YACd;AAAA,YAEA,KAAK,QAAQ;AACX,oBAAM,IAAI,8BAA8B;AAAA,gBACtC,eAAe;AAAA,cACjB,CAAC;AAAA,YACH;AAAA,YACA,SAAS;AACP,qBAAO;AAAA,YACT;AAAA,UACF;AAAA,QACF,CAAC,EACA,KAAK,EAAE;AAEV,gBAAQ,GAAG,IAAI;AAAA,EAAM,WAAW;AAAA;AAAA;AAChC;AAAA,MACF;AAAA,MAEA,KAAK,aAAa;AAChB,cAAM,mBAAmB,QACtB;AAAA,UACC,CACE,SAMG;AACH,oBAAQ,KAAK,MAAM;AAAA,cACjB,KAAK,QAAQ;AACX,uBAAO,KAAK;AAAA,cACd;AAAA,cACA,KAAK,aAAa;AAChB,sBAAM,IAAI,8BAA8B;AAAA,kBACtC,eAAe;AAAA,gBACjB,CAAC;AAAA,cACH;AAAA,cACA,KAAK,eAAe;AAClB,sBAAM,IAAI,8BAA8B;AAAA,kBACtC,eAAe;AAAA,gBACjB,CAAC;AAAA,cACH;AAAA,cACA,KAAK,aAAa;AAChB,sBAAM,IAAI,8BAA8B;AAAA,kBACtC,eAAe;AAAA,gBACjB,CAAC;AAAA,cACH;AAAA,cAEA,KAAK,QAAQ;AACX,sBAAM,IAAI,8BAA8B;AAAA,kBACtC,eAAe;AAAA,gBACjB,CAAC;AAAA,cACH;AAAA,cAEA,SAAS;AACP,uBAAO;AAAA,cACT;AAAA,YACF;AAAA,UACF;AAAA,QACF,EACC,KAAK,EAAE;AAEV,gBAAQ,GAAG,SAAS;AAAA,EAAM,gBAAgB;AAAA;AAAA;AAC1C;AAAA,MACF;AAAA,MAEA,KAAK,QAAQ;AACX,cAAM,IAAI,8BAA8B;AAAA,UACtC,eAAe;AAAA,QACjB,CAAC;AAAA,MACH;AAAA,MAEA,SAAS;AACP;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAGA,UAAQ,GAAG,SAAS;AAAA;AAEpB,SAAO;AAAA,IACL,QAAQ;AAAA,EACV;AACF;;;ACrJA,IAAAG,aAAkB;AAMX,IAAM,kCAAkC,aAAE,MAAM;AAAA,EACrD,aACG,OAAO;AAAA,IACN,IAAI,aAAE,OAAO,EAAE,SAAS;AAAA,IACxB,OAAO,aAAE,OAAO,EAAE,SAAS;AAAA,IAC3B,UAAU,aAAE,OAAO,EAAE,SAAS;AAAA,IAC9B,SAAS,aAAE;AAAA,MACT,aACG,OAAO;AAAA,QACN,MAAM,aAAE,OAAO;AAAA,QACf,WAAW,aAAE,OAAO,EAAE,QAAQ,EAAE,SAAS;AAAA,QACzC,mBAAmB,2BAA2B,QAAQ;AAAA,QAEtD,eAAe,aAAE,OAAO,EAAE,QAAQ;AAAA,QAClC,OAAO,aAAE,OAAO,EAAE,QAAQ;AAAA,QAC1B,UAAU,aACP,OAAO;AAAA,UACN,QAAQ,aAAE,MAAM,aAAE,OAAO,CAAC;AAAA,UAC1B,gBAAgB,aAAE,MAAM,aAAE,OAAO,CAAC;AAAA,UAClC,cAAc,aACX,MAAM,aAAE,OAAO,aAAE,OAAO,GAAG,aAAE,OAAO,CAAC,CAAC,EACtC,SAAS;AAAA,QACd,CAAC,EACA,YAAY,EACZ,SAAS,EACT,SAAS;AAAA,MACd,CAAC,EACA,YAAY;AAAA,IACjB;AAAA,IACA,OAAO,aACJ,OAAO;AAAA,MACN,eAAe,aAAE,OAAO;AAAA,MACxB,uBAAuB,aACpB,OAAO;AAAA,QACN,eAAe,aAAE,OAAO;AAAA,MAC1B,CAAC,EACA,YAAY,EACZ,QAAQ;AAAA,MACX,mBAAmB,aAAE,OAAO;AAAA,MAC5B,2BAA2B,aACxB,OAAO;AAAA,QACN,kBAAkB,aAAE,OAAO;AAAA,MAC7B,CAAC,EACA,YAAY,EACZ,QAAQ;AAAA,MACX,cAAc,aAAE,OAAO;AAAA,MACvB,MAAM,aAAE,OAAO,EAAE,SAAS;AAAA,MAC1B,cAAc,aACX,OAAO;AAAA,QACN,yBAAyB,aAAE,OAAO,EAAE,QAAQ;AAAA,MAC9C,CAAC,EACA,YAAY,EACZ,QAAQ;AAAA,IACb,CAAC,EACA,YAAY,EACZ,QAAQ;AAAA,EACb,CAAC,EACA,YAAY;AAAA,EACf;AACF,CAAC;;;ACnBM,IAAM,oCAAN,MAAmE;AAAA,EAkBxE,YACE,SACA,UACA,QACA;AArBF,SAAS,uBAAuB;AAChC,SAAS,WAAW;AAEpB,SAAS,oBAAoB;AAC7B,SAAS,gBAA0C;AAAA,MACjD,WAAW;AAAA,QACT;AAAA,QACA;AAAA,MACF;AAAA,MACA,UAAU,CAAC,gBAAgB,iBAAiB;AAAA,MAC5C,iBAAiB,CAAC,uBAAuB,iBAAiB;AAAA,IAC5D;AACA,SAAS,8BAA8B;AAUrC,SAAK,UAAU;AACf,SAAK,WAAW;AAChB,SAAK,SAAS;AAAA,EAChB;AAAA,EAEQ,QAAQ;AAAA,IACd;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAA+B;AAC7B,UAAM,EAAE,QAAQ,iBAAiB,IAAI,oCAAoC;AAAA,MACvE;AAAA,MACA,aAAa;AAAA,IACf,CAAC;AAED,QAAI,+BAAO,QAAQ;AACjB,YAAM,IAAI,8BAA8B;AAAA,QACtC,eAAe;AAAA,MACjB,CAAC;AAAA,IACH;AAEA,QAAI,YAAY;AACd,YAAM,IAAI,8BAA8B;AAAA,QACtC,eAAe;AAAA,MACjB,CAAC;AAAA,IACH;AAEA,WAAO;AAAA;AAAA,MAEL,OAAO,KAAK;AAAA,MACZ,QAAQ,KAAK,SAAS;AAAA;AAAA,MAGtB,YAAY,KAAK,SAAS;AAAA,MAC1B,UACE,OAAO,KAAK,SAAS,aAAa,WAC9B,KAAK,SAAS,WACd,OAAO,KAAK,SAAS,aAAa,YAChC,KAAK,SAAS,WACZ,IACA,SACF;AAAA,MACR,QAAQ,KAAK,SAAS;AAAA,MACtB,MAAM,KAAK,SAAS;AAAA;AAAA,MAGpB,YAAY;AAAA,MACZ;AAAA,MACA,OAAO;AAAA,MACP,mBAAmB;AAAA,MACnB,kBAAkB;AAAA,MAClB;AAAA,MAEA,MAAM;AAAA,MACN,iBAAiB;AAAA,MACjB,OAAO;AAAA;AAAA,MAGP,QAAQ;AAAA;AAAA,MAGR,mBAAmB,KAAK,SAAS;AAAA,MACjC,WAAW,KAAK,SAAS;AAAA,OAGtB,KAAK,OAAO,YACZ,KAAK,SAAS;AAAA,EAErB;AAAA,EAEA,MAAM,WACJ,SAC6D;AAtJjE,QAAAC,MAAAC,MAAA;AAuJI,UAAM,kBAAkB,QAAQ,mBAAmB,CAAC;AACpD,UAAM,oBAAoB,gBAAgB,cAAc,CAAC;AAEzD,UAAM,OAAO,kCACR,KAAK,QAAQ,OAAO,IACpB;AAGL,UAAM,EAAE,OAAO,UAAU,gBAAgB,IAAI,MAAM,cAAc;AAAA,MAC/D,KAAK,KAAK,OAAO,IAAI;AAAA,QACnB,MAAM;AAAA,QACN,SAAS,KAAK;AAAA,MAChB,CAAC;AAAA,MACD,SAAS,eAAe,KAAK,OAAO,QAAQ,GAAG,QAAQ,OAAO;AAAA,MAC9D,MAAM;AAAA,MACN,uBAAuB;AAAA,MACvB,2BAA2B;AAAA,QACzB;AAAA,MACF;AAAA,MACA,aAAa,QAAQ;AAAA,MACrB,OAAO,KAAK,OAAO;AAAA,IACrB,CAAC;AAED,QAAI,WAAW,UAAU;AACvB,YAAM,YAAY,SAAS;AAC3B,YAAM,IAAI,aAAa;AAAA,QACrB,SAAS,UAAU;AAAA,QACnB,KAAK,KAAK,OAAO,IAAI;AAAA,UACnB,MAAM;AAAA,UACN,SAAS,KAAK;AAAA,QAChB,CAAC;AAAA,QACD,mBAAmB;AAAA,QACnB,YAAY;AAAA,QACZ;AAAA,QACA,MAAM;AAAA,MACR,CAAC;AAAA,IACH;AAEA,UAAM,SAAS,SAAS,QAAQ,CAAC;AAEjC,QAAI,CAAC,QAAQ;AACX,YAAM,IAAI,wBAAwB;AAAA,QAChC,SAAS;AAAA,MACX,CAAC;AAAA,IACH;AAEA,WAAO;AAAA,MACL,SAAS;AAAA,QACP;AAAA,UACE,MAAM;AAAA,UACN,OAAMD,OAAA,OAAO,SAAP,OAAAA,OAAe;AAAA,QACvB;AAAA,MACF;AAAA,MACA,cAAc,0BAA0B,OAAO,aAAa;AAAA,MAC5D,OAAO;AAAA,QACL,aAAa;AAAA,UACX,QAAO,MAAAC,OAAA,SAAS,UAAT,gBAAAA,KAAgB,kBAAhB,YAAiC;AAAA,UACxC,SAAS;AAAA,UACT,YACE,0BAAS,UAAT,mBAAgB,0BAAhB,mBAAuC,kBAAvC,YAAwD;AAAA,UAC1D,YAAY;AAAA,QACd;AAAA,QACA,cAAc;AAAA,UACZ,QAAO,oBAAS,UAAT,mBAAgB,sBAAhB,YAAqC;AAAA,UAC5C,MAAM;AAAA,UACN,YACE,0BAAS,UAAT,mBAAgB,8BAAhB,mBAA2C,qBAA3C,YACA;AAAA,QACJ;AAAA,QACA,MAAM,cAAS,UAAT,YAAiC;AAAA,MACzC;AAAA,MACA,UAAU,CAAC;AAAA,MACX,kBAAkB;AAAA,QAChB,YAAY,iCAAiC,MAAM;AAAA,UACjD,WAAU,cAAS,aAAT,YAAqB;AAAA,UAC/B,OAAO;AAAA,YACL,eAAc,oBAAS,UAAT,mBAAgB,kBAAhB,YAAiC;AAAA,YAC/C,mBAAkB,oBAAS,UAAT,mBAAgB,sBAAhB,YAAqC;AAAA,YACvD,eACG,oBAAS,UAAT,mBAAgB,kBAAhB,YAAiC,OACjC,oBAAS,UAAT,mBAAgB,sBAAhB,YAAqC;AAAA,eACpC,cAAS,UAAT,mBAAgB,SAAQ,OACxB,EAAE,MAAM,SAAS,MAAM,KAAK,IAC5B,CAAC,MACD,oBAAS,UAAT,mBAAgB,0BAAhB,mBAAuC,kBAAiB,OACxD;AAAA,YACE,qBAAqB;AAAA,cACnB,cACE,SAAS,MAAM,sBAAsB;AAAA,YACzC;AAAA,UACF,IACA,CAAC,MACD,oBAAS,UAAT,mBAAgB,8BAAhB,mBAA2C,qBAC/C,OACI;AAAA,YACE,yBAAyB;AAAA,cACvB,iBACE,SAAS,MAAM,0BAA0B;AAAA,YAC7C;AAAA,UACF,IACA,CAAC,MACD,oBAAS,UAAT,mBAAgB,iBAAhB,mBAA8B,4BAA2B,OACzD;AAAA,YACE,aAAa;AAAA,cACX,uBACE,SAAS,MAAM,aAAa;AAAA,YAChC;AAAA,UACF,IACA,CAAC;AAAA,QAET,CAAC;AAAA,MACH;AAAA,MACA,UAAU;AAAA,QACR,SAAS;AAAA,MACX;AAAA,IACF;AAAA,EACF;AAAA,EAEA,MAAM,SACJ,SAC2D;AAC3D,UAAM,kBAAkB,QAAQ,mBAAmB,CAAC;AACpD,UAAM,oBAAoB,gBAAgB,cAAc,CAAC;AAEzD,UAAM,OAAO,kCACR,KAAK,QAAQ,OAAO,IACpB;AAGL,UAAM,EAAE,OAAO,UAAU,gBAAgB,IAAI,MAAM,cAAc;AAAA,MAC/D,KAAK,KAAK,OAAO,IAAI;AAAA,QACnB,MAAM;AAAA,QACN,SAAS,KAAK;AAAA,MAChB,CAAC;AAAA,MACD,SAAS,eAAe,KAAK,OAAO,QAAQ,GAAG,QAAQ,OAAO;AAAA,MAC9D,MAAM,iCACD,OADC;AAAA,QAEJ,QAAQ;AAAA;AAAA,QAGR,gBACE,KAAK,OAAO,kBAAkB,WAC1B,EAAE,eAAe,KAAK,IACtB;AAAA,MACR;AAAA,MACA,uBAAuB;AAAA,MACvB,2BAA2B;AAAA,QACzB;AAAA,MACF;AAAA,MACA,aAAa,QAAQ;AAAA,MACrB,OAAO,KAAK,OAAO;AAAA,IACrB,CAAC;AAED,QAAI,eAA4C,mBAAmB,OAAO;AAC1E,UAAM,QAA8B;AAAA,MAClC,aAAa;AAAA,QACX,OAAO;AAAA,QACP,SAAS;AAAA,QACT,WAAW;AAAA,QACX,YAAY;AAAA,MACd;AAAA,MACA,cAAc;AAAA,QACZ,OAAO;AAAA,QACP,MAAM;AAAA,QACN,WAAW;AAAA,MACb;AAAA,MACA,KAAK;AAAA,IACP;AAEA,UAAM,kBAAsD,CAAC;AAC7D,QAAI;AAGJ,QAAI;AAEJ,WAAO;AAAA,MACL,QAAQ,SAAS;AAAA,QACf,IAAI,gBAGF;AAAA,UACA,UAAU,OAAO,YAAY;AA5UvC,gBAAAD,MAAAC,MAAA;AA8UY,gBAAI,QAAQ,kBAAkB;AAC5B,yBAAW,QAAQ,EAAE,MAAM,OAAO,UAAU,MAAM,SAAS,CAAC;AAAA,YAC9D;AAGA,gBAAI,CAAC,MAAM,SAAS;AAClB,6BAAe,mBAAmB,OAAO;AACzC,yBAAW,QAAQ,EAAE,MAAM,SAAS,OAAO,MAAM,MAAM,CAAC;AACxD;AAAA,YACF;AAEA,kBAAM,QAAQ,MAAM;AAGpB,gBAAI,WAAW,OAAO;AACpB,6BAAe,mBAAmB,OAAO;AACzC,yBAAW,QAAQ,EAAE,MAAM,SAAS,OAAO,MAAM,MAAM,CAAC;AACxD;AAAA,YACF;AAEA,gBAAI,MAAM,UAAU;AAClB,yBAAW,MAAM;AAAA,YACnB;AAEA,gBAAI,MAAM,SAAS,MAAM;AACvB,oBAAM,YAAY,QAAQ,MAAM,MAAM;AACtC,oBAAM,aAAa,QAAQ,MAAM,MAAM;AAGvC,yBAAW,MAAM;AAGjB,8BAAgB,eAAe,MAAM,MAAM;AAE3C,kBAAI,MAAM,MAAM,uBAAuB;AACrC,sBAAM,qBACJD,OAAA,MAAM,MAAM,sBAAsB,kBAAlC,OAAAA,OAAmD;AAErD,sBAAM,YAAY,YAAY;AAC9B,gCAAgB,sBAAsB;AAAA,kBACpC,cAAc;AAAA,gBAChB;AAAA,cACF;AAEA,8BAAgB,mBAAmB,MAAM,MAAM;AAC/C,kBAAI,MAAM,MAAM,2BAA2B;AACzC,sBAAM,mBACJC,OAAA,MAAM,MAAM,0BAA0B,qBAAtC,OAAAA,OAA0D;AAE5D,sBAAM,aAAa,YAAY;AAC/B,gCAAgB,0BAA0B;AAAA,kBACxC;AAAA,gBACF;AAAA,cACF;AAEA,kBAAI,MAAM,MAAM,QAAQ,MAAM;AAC5B,gCAAgB,OAAO,MAAM,MAAM;AAAA,cACrC;AACA,8BAAgB,cAAc,MAAM,MAAM;AAC1C,oBAAM,yBACJ,WAAM,MAAM,iBAAZ,mBAA0B;AAC5B,kBAAI,yBAAyB,MAAM;AACjC,gCAAgB,cAAc;AAAA,kBAC5B;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAEA,kBAAM,SAAS,MAAM,QAAQ,CAAC;AAE9B,iBAAI,iCAAQ,kBAAiB,MAAM;AACjC,6BAAe,0BAA0B,OAAO,aAAa;AAAA,YAC/D;AAEA,iBAAI,iCAAQ,SAAQ,MAAM;AACxB,yBAAW,QAAQ;AAAA,gBACjB,MAAM;AAAA,gBACN,OAAO,OAAO;AAAA,gBACd,IAAI,WAAW;AAAA,cACjB,CAAC;AAAA,YACH;AAAA,UACF;AAAA,UAEA,MAAM,YAAY;AAEhB,kBAAM,MAAM;AAEZ,kBAAM,qBAGF;AAAA,cACF,OAAO;AAAA,YACT;AAGA,gBAAI,aAAa,QAAW;AAC1B,iCAAmB,WAAW;AAAA,YAChC;AAEA,uBAAW,QAAQ;AAAA,cACjB,MAAM;AAAA,cACN;AAAA,cACA;AAAA,cACA,kBAAkB;AAAA,gBAChB,YAAY;AAAA,cACd;AAAA,YACF,CAAC;AAAA,UACH;AAAA,QACF,CAAC;AAAA,MACH;AAAA,MACA,UAAU;AAAA,QACR,SAAS;AAAA,MACX;AAAA,IACF;AAAA,EACF;AACF;;;ACjcA,IAAAC,aAAkB;AAElB,IAAM,iCAAiC,aAAE,OAAO;AAAA,EAC9C,eAAe,aAAE,OAAO;AAAA,EACxB,cAAc,aAAE,OAAO;AAAA,EACvB,MAAM,aAAE,OAAO,EAAE,SAAS;AAC5B,CAAC;AAED,IAAM,gCAAgC,aAAE,OAAO;AAAA,EAC7C,QAAQ,aAAE,QAAQ,WAAW;AAAA,EAC7B,WAAW,aAAE,MAAM,aAAE,OAAO,CAAC;AAAA,EAC7B,OAAO,aAAE,OAAO,EAAE,SAAS;AAC7B,CAAC;AAEM,IAAM,oCAAoC,aAAE,OAAO;AAAA,EACxD,IAAI,aAAE,OAAO,EAAE,SAAS;AAAA,EACxB,QAAQ,aAAE,QAAQ,MAAM;AAAA,EACxB,MAAM,aAAE,MAAM,6BAA6B;AAAA,EAC3C,OAAO,aAAE,OAAO;AAAA,EAChB,UAAU,aAAE,OAAO,EAAE,SAAS;AAAA,EAC9B,OAAO,+BAA+B,SAAS;AACjD,CAAC;;;ACMM,IAAM,2BAAN,MAA2D;AAAA,EAUhE,YACE,SACA,UACA,QACA;AAbF,SAAS,uBAAuB;AAChC,SAAS,WAAW;AAGpB,SAAS,uBAAuB;AAChC,SAAS,wBAAwB;AAS/B,SAAK,UAAU;AACf,SAAK,WAAW;AAChB,SAAK,SAAS;AAAA,EAChB;AAAA,EAEA,MAAM,QAAQ,SAaX;AA5DL,QAAAC,MAAAC,MAAA;AA6DI,UAAM,EAAE,QAAQ,aAAa,QAAQ,IAAI;AAEzC,UAAM,OAAO;AAAA,MACX,OAAO,KAAK;AAAA,MACZ,OAAO;AAAA,MACP,MAAM,KAAK,SAAS;AAAA,MACpB,UAAU,KAAK,SAAS;AAAA,OACrB,KAAK,OAAO,YACZ,KAAK,SAAS;AAGnB,UAAM,EAAE,OAAO,eAAe,gBAAgB,IAAI,MAAM,cAAc;AAAA,MACpE,KAAK,KAAK,OAAO,IAAI;AAAA,QACnB,MAAM;AAAA,QACN,SAAS,KAAK;AAAA,MAChB,CAAC;AAAA,MACD,SAAS,eAAe,KAAK,OAAO,QAAQ,GAAG,OAAO;AAAA,MACtD,MAAM;AAAA,MACN,uBAAuB;AAAA,MACvB,2BAA2B;AAAA,QACzB;AAAA,MACF;AAAA,MACA;AAAA,MACA,OAAO,KAAK,OAAO;AAAA,IACrB,CAAC;AAED,WAAO;AAAA,MACL,YAAY,cAAc,KAAK,IAAI,CAAC,SAAS,KAAK,SAAS;AAAA,MAC3D,OAAO,cAAc,QACjB,EAAE,QAAQ,cAAc,MAAM,cAAc,IAC5C;AAAA,MACJ,kBAAkB;AAAA,QAChB,YAAY,iCAAiC,MAAM;AAAA,UACjD,WAAUD,OAAA,cAAc,aAAd,OAAAA,OAA0B;AAAA,UACpC,OAAO;AAAA,YACL,eAAc,MAAAC,OAAA,cAAc,UAAd,gBAAAA,KAAqB,kBAArB,YAAsC;AAAA,YACpD,kBAAkB;AAAA,YAClB,cAAa,yBAAc,UAAd,mBAAqB,iBAArB,YAAqC;AAAA,eAC9C,mBAAc,UAAd,mBAAqB,SAAQ,OAC7B,EAAE,MAAM,cAAc,MAAM,KAAK,IACjC,CAAC;AAAA,QAET,CAAC;AAAA,MACH;AAAA,MACA,UAAU;AAAA,QACR,SAAS;AAAA,QACT,MAAM;AAAA,MACR;AAAA,MACA,UAAU,CAAC;AAAA,IACb;AAAA,EACF;AACF;;;AChHA,IAAAC,aAAkB;AAEX,IAAM,gCAAgC,aAC1C,OAAO;AAAA,EACN,IAAI,aAAE,OAAO,EAAE,SAAS;AAAA,EACxB,QAAQ,aAAE,OAAO,EAAE,SAAS;AAAA,EAC5B,SAAS,aAAE,OAAO,EAAE,SAAS;AAAA,EAC7B,OAAO,aAAE,OAAO;AAAA,EAChB,SAAS,aAAE;AAAA,IACT,aACG,OAAO;AAAA,MACN,OAAO,aAAE,OAAO;AAAA,MAChB,SAAS,aACN,OAAO;AAAA,QACN,MAAM,aAAE,OAAO;AAAA,QACf,SAAS,aAAE,OAAO,EAAE,SAAS,EAAE,SAAS;AAAA,QACxC,QAAQ,aACL;AAAA,UACC,aACG,OAAO;AAAA,YACN,MAAM,aAAE,QAAQ,WAAW;AAAA,YAC3B,WAAW,aAAE,OAAO;AAAA,cAClB,KAAK,aAAE,OAAO;AAAA,YAChB,CAAC;AAAA,UACH,CAAC,EACA,YAAY;AAAA,QACjB,EACC,SAAS;AAAA,MACd,CAAC,EACA,YAAY;AAAA,MACf,eAAe,aAAE,OAAO,EAAE,SAAS,EAAE,SAAS;AAAA,IAChD,CAAC,EACA,YAAY;AAAA,EACjB;AAAA,EACA,OAAO,aACJ,OAAO;AAAA,IACN,eAAe,aAAE,OAAO;AAAA,IACxB,mBAAmB,aAAE,OAAO;AAAA,IAC5B,cAAc,aAAE,OAAO;AAAA,EACzB,CAAC,EACA,YAAY,EACZ,SAAS;AACd,CAAC,EACA,YAAY;;;ACVR,IAAM,uBAAN,MAAmD;AAAA,EASxD,YACE,SACA,UACA,QACA;AAZF,SAAS,uBAAuB;AAChC,SAAS,WAAW;AAGpB,SAAS,mBAAmB;AAS1B,SAAK,UAAU;AACf,SAAK,WAAW;AAChB,SAAK,SAAS;AAAA,EAChB;AAAA,EAEA,MAAM,WAAW,SAUd;AA9DL,QAAAC;AA+DI,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,IAAI;AAEJ,UAAM,qBACH,mDAAiB,eAA0C,CAAC;AAE/D,UAAM,WAA8B,CAAC;AAErC,QAAI,UAAU,UAAa,MAAM,SAAS,GAAG;AAC3C,YAAM,IAAI,8BAA8B;AAAA,QACtC,eAAe;AAAA,MACjB,CAAC;AAAA,IACH;AAEA,QAAI,SAAS,QAAW;AACtB,YAAM,IAAI,8BAA8B;AAAA,QACtC,eAAe;AAAA,MACjB,CAAC;AAAA,IACH;AAEA,QAAI,IAAI,GAAG;AACT,eAAS,KAAK;AAAA,QACZ,MAAM;AAAA,QACN,SAAS;AAAA,QACT,SAAS,mEAAmE,CAAC;AAAA,MAC/E,CAAC;AAAA,IACH;AAEA,QAAI,SAAS,QAAW;AACtB,eAAS,KAAK;AAAA,QACZ,MAAM;AAAA,QACN,SAAS;AAAA,QACT,SACE;AAAA,MACJ,CAAC;AAAA,IACH;AAEA,UAAM,cACJ,gBAAgB,SAAY,EAAE,cAAc,YAAY,IAAI;AAE9D,UAAM,OAAgC;AAAA,MACpC,OAAO,KAAK;AAAA,MACZ,UAAU;AAAA,QACR;AAAA,UACE,MAAM;AAAA,UACN,SAAS,0BAAU;AAAA,QACrB;AAAA,MACF;AAAA,MACA,YAAY,CAAC,SAAS,MAAM;AAAA,OACxB,gBAAgB,UAAa,EAAE,cAAc,YAAY,IACzD,SAAS,UAAa,EAAE,KAAK,IAC7B,KAAK,SAAS,SAAS,UAAa,EAAE,MAAM,KAAK,SAAS,KAAK,IAC/D,KAAK,SAAS,aAAa,UAAa;AAAA,MAC1C,UAAU,KAAK,SAAS;AAAA,IAC1B,IACG,KAAK,OAAO,YACZ,KAAK,SAAS,YACd;AAGL,UAAM,EAAE,OAAO,eAAe,gBAAgB,IAAI,MAAM,cAAc;AAAA,MACpE,KAAK,KAAK,OAAO,IAAI;AAAA,QACnB,MAAM;AAAA,QACN,SAAS,KAAK;AAAA,MAChB,CAAC;AAAA,MACD,SAAS,eAAe,KAAK,OAAO,QAAQ,GAAG,OAAO;AAAA,MACtD;AAAA,MACA,uBAAuB;AAAA,MACvB,2BAA2B;AAAA,QACzB;AAAA,MACF;AAAA,MACA;AAAA,MACA,OAAO,KAAK,OAAO;AAAA,IACrB,CAAC;AAED,UAAM,SAAS,cAAc,QAAQ,CAAC;AAEtC,QAAI,CAAC,QAAQ;AACX,YAAM,IAAI,wBAAwB;AAAA,QAChC,SAAS;AAAA,MACX,CAAC;AAAA,IACH;AAEA,UAAM,SAAmB,CAAC;AAE1B,SAAIA,OAAA,OAAO,YAAP,gBAAAA,KAAgB,QAAQ;AAC1B,iBAAW,SAAS,OAAO,QAAQ,QAAQ;AACzC,cAAM,UAAU,MAAM,UAAU;AAChC,eAAO,KAAK,qBAAqB,OAAO,CAAC;AAAA,MAC3C;AAAA,IACF;AAEA,UAAM,QAAuC,cAAc,QACvD;AAAA,MACE,aAAa,cAAc,MAAM;AAAA,MACjC,cAAc,cAAc,MAAM;AAAA,MAClC,aAAa,cAAc,MAAM;AAAA,IACnC,IACA;AAEJ,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA,UAAU;AAAA,QACR,WAAW,oBAAI,KAAK;AAAA,QACpB,SAAS,cAAc;AAAA,QACvB,SAAS;AAAA,MACX;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACF;","names":["name","marker","symbol","_a","_b","import_v3","name","marker","symbol","_a","_b","_a","_b","jsonSchema","_a","_b","ZodFirstPartyTypeKind","types","x","name","schema","jsonSchema","standardSchema","zodSchema","_a","TypeValidationError","getOriginalFetch","fetch","fetch","getOriginalFetch","APICallError","APICallError","ReasoningFormat","d","import_v4","import_v4","_a","_b","_a","_b","_c","_d","_e","_f","content","import_v4","import_v4","import_v4","d","_a","_b","toolCall","import_v4","_a","_b","import_v4","_a","_b","import_v4","_a"]}