"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name15 in all)
    __defProp(target, name15, { get: all[name15], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  OpenRouter: () => OpenRouter,
  createOpenRouter: () => createOpenRouter,
  openrouter: () => openrouter
});
module.exports = __toCommonJS(index_exports);

// node_modules/.pnpm/@ai-sdk+provider@3.0.0/node_modules/@ai-sdk/provider/dist/index.mjs
var marker = "vercel.ai.error";
var symbol = Symbol.for(marker);
var _a;
var _b;
var AISDKError = class _AISDKError extends (_b = Error, _a = symbol, _b) {
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({
    name: name142,
    message,
    cause
  }) {
    super(message);
    this[_a] = true;
    this.name = name142;
    this.cause = cause;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(error) {
    return _AISDKError.hasMarker(error, marker);
  }
  static hasMarker(error, marker152) {
    const markerSymbol = Symbol.for(marker152);
    return error != null && typeof error === "object" && markerSymbol in error && typeof error[markerSymbol] === "boolean" && error[markerSymbol] === true;
  }
};
var name = "AI_APICallError";
var marker2 = `vercel.ai.error.${name}`;
var symbol2 = Symbol.for(marker2);
var _a2;
var _b2;
var APICallError = class extends (_b2 = AISDKError, _a2 = symbol2, _b2) {
  constructor({
    message,
    url,
    requestBodyValues,
    statusCode,
    responseHeaders,
    responseBody,
    cause,
    isRetryable = statusCode != null && (statusCode === 408 || // request timeout
    statusCode === 409 || // conflict
    statusCode === 429 || // too many requests
    statusCode >= 500),
    // server error
    data
  }) {
    super({ name, message, cause });
    this[_a2] = true;
    this.url = url;
    this.requestBodyValues = requestBodyValues;
    this.statusCode = statusCode;
    this.responseHeaders = responseHeaders;
    this.responseBody = responseBody;
    this.isRetryable = isRetryable;
    this.data = data;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker2);
  }
};
var name2 = "AI_EmptyResponseBodyError";
var marker3 = `vercel.ai.error.${name2}`;
var symbol3 = Symbol.for(marker3);
var _a3;
var _b3;
var EmptyResponseBodyError = class extends (_b3 = AISDKError, _a3 = symbol3, _b3) {
  // used in isInstance
  constructor({ message = "Empty response body" } = {}) {
    super({ name: name2, message });
    this[_a3] = true;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker3);
  }
};
function getErrorMessage(error) {
  if (error == null) {
    return "unknown error";
  }
  if (typeof error === "string") {
    return error;
  }
  if (error instanceof Error) {
    return error.message;
  }
  return JSON.stringify(error);
}
var name3 = "AI_InvalidArgumentError";
var marker4 = `vercel.ai.error.${name3}`;
var symbol4 = Symbol.for(marker4);
var _a4;
var _b4;
var InvalidArgumentError = class extends (_b4 = AISDKError, _a4 = symbol4, _b4) {
  constructor({
    message,
    cause,
    argument
  }) {
    super({ name: name3, message, cause });
    this[_a4] = true;
    this.argument = argument;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker4);
  }
};
var name4 = "AI_InvalidPromptError";
var marker5 = `vercel.ai.error.${name4}`;
var symbol5 = Symbol.for(marker5);
var _a5;
var _b5;
var InvalidPromptError = class extends (_b5 = AISDKError, _a5 = symbol5, _b5) {
  constructor({
    prompt,
    message,
    cause
  }) {
    super({ name: name4, message: `Invalid prompt: ${message}`, cause });
    this[_a5] = true;
    this.prompt = prompt;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker5);
  }
};
var name5 = "AI_InvalidResponseDataError";
var marker6 = `vercel.ai.error.${name5}`;
var symbol6 = Symbol.for(marker6);
var _a6;
var _b6;
var InvalidResponseDataError = class extends (_b6 = AISDKError, _a6 = symbol6, _b6) {
  constructor({
    data,
    message = `Invalid response data: ${JSON.stringify(data)}.`
  }) {
    super({ name: name5, message });
    this[_a6] = true;
    this.data = data;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker6);
  }
};
var name6 = "AI_JSONParseError";
var marker7 = `vercel.ai.error.${name6}`;
var symbol7 = Symbol.for(marker7);
var _a7;
var _b7;
var JSONParseError = class extends (_b7 = AISDKError, _a7 = symbol7, _b7) {
  constructor({ text, cause }) {
    super({
      name: name6,
      message: `JSON parsing failed: Text: ${text}.
Error message: ${getErrorMessage(cause)}`,
      cause
    });
    this[_a7] = true;
    this.text = text;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker7);
  }
};
var name7 = "AI_LoadAPIKeyError";
var marker8 = `vercel.ai.error.${name7}`;
var symbol8 = Symbol.for(marker8);
var _a8;
var _b8;
var LoadAPIKeyError = class extends (_b8 = AISDKError, _a8 = symbol8, _b8) {
  // used in isInstance
  constructor({ message }) {
    super({ name: name7, message });
    this[_a8] = true;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker8);
  }
};
var name8 = "AI_LoadSettingError";
var marker9 = `vercel.ai.error.${name8}`;
var symbol9 = Symbol.for(marker9);
var _a9;
var _b9;
var LoadSettingError = class extends (_b9 = AISDKError, _a9 = symbol9, _b9) {
  // used in isInstance
  constructor({ message }) {
    super({ name: name8, message });
    this[_a9] = true;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker9);
  }
};
var name9 = "AI_NoContentGeneratedError";
var marker10 = `vercel.ai.error.${name9}`;
var symbol10 = Symbol.for(marker10);
var _a10;
var _b10;
var NoContentGeneratedError = class extends (_b10 = AISDKError, _a10 = symbol10, _b10) {
  // used in isInstance
  constructor({
    message = "No content generated."
  } = {}) {
    super({ name: name9, message });
    this[_a10] = true;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker10);
  }
};
var name10 = "AI_NoSuchModelError";
var marker11 = `vercel.ai.error.${name10}`;
var symbol11 = Symbol.for(marker11);
var _a11;
var _b11;
var NoSuchModelError = class extends (_b11 = AISDKError, _a11 = symbol11, _b11) {
  constructor({
    errorName = name10,
    modelId,
    modelType,
    message = `No such ${modelType}: ${modelId}`
  }) {
    super({ name: errorName, message });
    this[_a11] = true;
    this.modelId = modelId;
    this.modelType = modelType;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker11);
  }
};
var name11 = "AI_TooManyEmbeddingValuesForCallError";
var marker12 = `vercel.ai.error.${name11}`;
var symbol12 = Symbol.for(marker12);
var _a12;
var _b12;
var TooManyEmbeddingValuesForCallError = class extends (_b12 = AISDKError, _a12 = symbol12, _b12) {
  constructor(options) {
    super({
      name: name11,
      message: `Too many values for a single embedding call. The ${options.provider} model "${options.modelId}" can only embed up to ${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`
    });
    this[_a12] = true;
    this.provider = options.provider;
    this.modelId = options.modelId;
    this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;
    this.values = options.values;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker12);
  }
};
var name12 = "AI_TypeValidationError";
var marker13 = `vercel.ai.error.${name12}`;
var symbol13 = Symbol.for(marker13);
var _a13;
var _b13;
var TypeValidationError = class _TypeValidationError extends (_b13 = AISDKError, _a13 = symbol13, _b13) {
  constructor({ value, cause }) {
    super({
      name: name12,
      message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage(cause)}`,
      cause
    });
    this[_a13] = true;
    this.value = value;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker13);
  }
  /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */
  static wrap({
    value,
    cause
  }) {
    return _TypeValidationError.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError({ value, cause });
  }
};
var name13 = "AI_UnsupportedFunctionalityError";
var marker14 = `vercel.ai.error.${name13}`;
var symbol14 = Symbol.for(marker14);
var _a14;
var _b14;
var UnsupportedFunctionalityError = class extends (_b14 = AISDKError, _a14 = symbol14, _b14) {
  constructor({
    functionality,
    message = `'${functionality}' functionality not supported.`
  }) {
    super({ name: name13, message });
    this[_a14] = true;
    this.functionality = functionality;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker14);
  }
};

// node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/dist/index.mjs
var z4 = __toESM(require("zod/v4"), 1);
var import_v3 = require("zod/v3");
var import_v32 = require("zod/v3");
var import_v33 = require("zod/v3");

// node_modules/.pnpm/eventsource-parser@3.0.6/node_modules/eventsource-parser/dist/index.js
var ParseError = class extends Error {
  constructor(message, options) {
    super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
  }
};
function noop(_arg) {
}
function createParser(callbacks) {
  if (typeof callbacks == "function")
    throw new TypeError(
      "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
    );
  const { onEvent = noop, onError = noop, onRetry = noop, onComment } = callbacks;
  let incompleteLine = "", isFirstChunk = true, id, data = "", eventType = "";
  function feed(newChunk) {
    const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);
    for (const line of complete)
      parseLine(line);
    incompleteLine = incomplete, isFirstChunk = false;
  }
  function parseLine(line) {
    if (line === "") {
      dispatchEvent();
      return;
    }
    if (line.startsWith(":")) {
      onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
      return;
    }
    const fieldSeparatorIndex = line.indexOf(":");
    if (fieldSeparatorIndex !== -1) {
      const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);
      processField(field, value, line);
      return;
    }
    processField(line, "", line);
  }
  function processField(field, value, line) {
    switch (field) {
      case "event":
        eventType = value;
        break;
      case "data":
        data = `${data}${value}
`;
        break;
      case "id":
        id = value.includes("\0") ? void 0 : value;
        break;
      case "retry":
        /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(
          new ParseError(`Invalid \`retry\` value: "${value}"`, {
            type: "invalid-retry",
            value,
            line
          })
        );
        break;
      default:
        onError(
          new ParseError(
            `Unknown field "${field.length > 20 ? `${field.slice(0, 20)}\u2026` : field}"`,
            { type: "unknown-field", field, value, line }
          )
        );
        break;
    }
  }
  function dispatchEvent() {
    data.length > 0 && onEvent({
      id,
      event: eventType || void 0,
      // If the data buffer's last character is a U+000A LINE FEED (LF) character,
      // then remove the last character from the data buffer.
      data: data.endsWith(`
`) ? data.slice(0, -1) : data
    }), id = void 0, data = "", eventType = "";
  }
  function reset(options = {}) {
    incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id = void 0, data = "", eventType = "", incompleteLine = "";
  }
  return { feed, reset };
}
function splitLines(chunk) {
  const lines = [];
  let incompleteLine = "", searchIndex = 0;
  for (; searchIndex < chunk.length; ) {
    const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
    let lineEnd = -1;
    if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? crIndex === chunk.length - 1 ? lineEnd = -1 : lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
      incompleteLine = chunk.slice(searchIndex);
      break;
    } else {
      const line = chunk.slice(searchIndex, lineEnd);
      lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
    }
  }
  return [lines, incompleteLine];
}

// node_modules/.pnpm/eventsource-parser@3.0.6/node_modules/eventsource-parser/dist/stream.js
var EventSourceParserStream = class extends TransformStream {
  constructor({ onError, onRetry, onComment } = {}) {
    let parser;
    super({
      start(controller) {
        parser = createParser({
          onEvent: (event) => {
            controller.enqueue(event);
          },
          onError(error) {
            onError === "terminate" ? controller.error(error) : typeof onError == "function" && onError(error);
          },
          onRetry,
          onComment
        });
      },
      transform(chunk) {
        parser.feed(chunk);
      }
    });
  }
};

// node_modules/.pnpm/@ai-sdk+provider-utils@4.0.1_zod@4.3.5/node_modules/@ai-sdk/provider-utils/dist/index.mjs
function combineHeaders(...headers) {
  return headers.reduce(
    (combinedHeaders, currentHeaders) => __spreadValues(__spreadValues({}, combinedHeaders), currentHeaders != null ? currentHeaders : {}),
    {}
  );
}
function extractResponseHeaders(response) {
  return Object.fromEntries([...response.headers]);
}
var { btoa, atob } = globalThis;
function convertUint8ArrayToBase64(array) {
  let latin1string = "";
  for (let i = 0; i < array.length; i++) {
    latin1string += String.fromCodePoint(array[i]);
  }
  return btoa(latin1string);
}
var name14 = "AI_DownloadError";
var marker15 = `vercel.ai.error.${name14}`;
var symbol15 = Symbol.for(marker15);
var _a15;
var _b15;
var DownloadError = class extends (_b15 = AISDKError, _a15 = symbol15, _b15) {
  constructor({
    url,
    statusCode,
    statusText,
    cause,
    message = cause == null ? `Failed to download ${url}: ${statusCode} ${statusText}` : `Failed to download ${url}: ${cause}`
  }) {
    super({ name: name14, message, cause });
    this[_a15] = true;
    this.url = url;
    this.statusCode = statusCode;
    this.statusText = statusText;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker15);
  }
};
var createIdGenerator = ({
  prefix,
  size = 16,
  alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator = "-"
} = {}) => {
  const generator = () => {
    const alphabetLength = alphabet.length;
    const chars = new Array(size);
    for (let i = 0; i < size; i++) {
      chars[i] = alphabet[Math.random() * alphabetLength | 0];
    }
    return chars.join("");
  };
  if (prefix == null) {
    return generator;
  }
  if (alphabet.includes(separator)) {
    throw new InvalidArgumentError({
      argument: "separator",
      message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
    });
  }
  return () => `${prefix}${separator}${generator()}`;
};
var generateId = createIdGenerator();
function isAbortError(error) {
  return (error instanceof Error || error instanceof DOMException) && (error.name === "AbortError" || error.name === "ResponseAborted" || // Next.js
  error.name === "TimeoutError");
}
var FETCH_FAILED_ERROR_MESSAGES = ["fetch failed", "failed to fetch"];
function handleFetchError({
  error,
  url,
  requestBodyValues
}) {
  if (isAbortError(error)) {
    return error;
  }
  if (error instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES.includes(error.message.toLowerCase())) {
    const cause = error.cause;
    if (cause != null) {
      return new APICallError({
        message: `Cannot connect to API: ${cause.message}`,
        cause,
        url,
        requestBodyValues,
        isRetryable: true
        // retry when network error
      });
    }
  }
  return error;
}
function getRuntimeEnvironmentUserAgent(globalThisAny = globalThis) {
  var _a22, _b22, _c;
  if (globalThisAny.window) {
    return `runtime/browser`;
  }
  if ((_a22 = globalThisAny.navigator) == null ? void 0 : _a22.userAgent) {
    return `runtime/${globalThisAny.navigator.userAgent.toLowerCase()}`;
  }
  if ((_c = (_b22 = globalThisAny.process) == null ? void 0 : _b22.versions) == null ? void 0 : _c.node) {
    return `runtime/node.js/${globalThisAny.process.version.substring(0)}`;
  }
  if (globalThisAny.EdgeRuntime) {
    return `runtime/vercel-edge`;
  }
  return "runtime/unknown";
}
function normalizeHeaders(headers) {
  if (headers == null) {
    return {};
  }
  const normalized = {};
  if (headers instanceof Headers) {
    headers.forEach((value, key) => {
      normalized[key.toLowerCase()] = value;
    });
  } else {
    if (!Array.isArray(headers)) {
      headers = Object.entries(headers);
    }
    for (const [key, value] of headers) {
      if (value != null) {
        normalized[key.toLowerCase()] = value;
      }
    }
  }
  return normalized;
}
function withUserAgentSuffix(headers, ...userAgentSuffixParts) {
  const normalizedHeaders = new Headers(normalizeHeaders(headers));
  const currentUserAgentHeader = normalizedHeaders.get("user-agent") || "";
  normalizedHeaders.set(
    "user-agent",
    [currentUserAgentHeader, ...userAgentSuffixParts].filter(Boolean).join(" ")
  );
  return Object.fromEntries(normalizedHeaders.entries());
}
var VERSION = true ? "4.0.1" : "0.0.0-test";
function loadApiKey({
  apiKey,
  environmentVariableName,
  apiKeyParameterName = "apiKey",
  description
}) {
  if (typeof apiKey === "string") {
    return apiKey;
  }
  if (apiKey != null) {
    throw new LoadAPIKeyError({
      message: `${description} API key must be a string.`
    });
  }
  if (typeof process === "undefined") {
    throw new LoadAPIKeyError({
      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`
    });
  }
  apiKey = process.env[environmentVariableName];
  if (apiKey == null) {
    throw new LoadAPIKeyError({
      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`
    });
  }
  if (typeof apiKey !== "string") {
    throw new LoadAPIKeyError({
      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`
    });
  }
  return apiKey;
}
var suspectProtoRx = /"__proto__"\s*:/;
var suspectConstructorRx = /"constructor"\s*:/;
function _parse(text) {
  const obj = JSON.parse(text);
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {
    return obj;
  }
  return filter(obj);
}
function filter(obj) {
  let next = [obj];
  while (next.length) {
    const nodes = next;
    next = [];
    for (const node of nodes) {
      if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      if (Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      for (const key in node) {
        const value = node[key];
        if (value && typeof value === "object") {
          next.push(value);
        }
      }
    }
  }
  return obj;
}
function secureJsonParse(text) {
  const { stackTraceLimit } = Error;
  try {
    Error.stackTraceLimit = 0;
  } catch (e) {
    return _parse(text);
  }
  try {
    return _parse(text);
  } finally {
    Error.stackTraceLimit = stackTraceLimit;
  }
}
function addAdditionalPropertiesToJsonSchema(jsonSchema2) {
  if (jsonSchema2.type === "object") {
    jsonSchema2.additionalProperties = false;
    const properties = jsonSchema2.properties;
    if (properties != null) {
      for (const property in properties) {
        properties[property] = addAdditionalPropertiesToJsonSchema(
          properties[property]
        );
      }
    }
  }
  if (jsonSchema2.type === "array" && jsonSchema2.items != null) {
    if (Array.isArray(jsonSchema2.items)) {
      jsonSchema2.items = jsonSchema2.items.map(
        (item) => addAdditionalPropertiesToJsonSchema(item)
      );
    } else {
      jsonSchema2.items = addAdditionalPropertiesToJsonSchema(
        jsonSchema2.items
      );
    }
  }
  return jsonSchema2;
}
var ignoreOverride = Symbol(
  "Let zodToJsonSchema decide on which parser to use"
);
var defaultOptions = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: true,
  rejectedAdditionalProperties: false,
  definitionPath: "definitions",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  patternStrategy: "escape",
  applyRegexFlags: false,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref"
};
var getDefaultOptions = (options) => typeof options === "string" ? __spreadProps(__spreadValues({}, defaultOptions), {
  name: options
}) : __spreadValues(__spreadValues({}, defaultOptions), options);
function parseAnyDef() {
  return {};
}
function parseArrayDef(def, refs) {
  var _a22, _b22, _c;
  const res = {
    type: "array"
  };
  if (((_a22 = def.type) == null ? void 0 : _a22._def) && ((_c = (_b22 = def.type) == null ? void 0 : _b22._def) == null ? void 0 : _c.typeName) !== import_v32.ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef(def.type._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "items"]
    }));
  }
  if (def.minLength) {
    res.minItems = def.minLength.value;
  }
  if (def.maxLength) {
    res.maxItems = def.maxLength.value;
  }
  if (def.exactLength) {
    res.minItems = def.exactLength.value;
    res.maxItems = def.exactLength.value;
  }
  return res;
}
function parseBigintDef(def) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks) return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (check.inclusive) {
          res.minimum = check.value;
        } else {
          res.exclusiveMinimum = check.value;
        }
        break;
      case "max":
        if (check.inclusive) {
          res.maximum = check.value;
        } else {
          res.exclusiveMaximum = check.value;
        }
        break;
      case "multipleOf":
        res.multipleOf = check.value;
        break;
    }
  }
  return res;
}
function parseBooleanDef() {
  return { type: "boolean" };
}
function parseBrandedDef(_def, refs) {
  return parseDef(_def.type._def, refs);
}
var parseCatchDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};
function parseDateDef(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy != null ? overrideDateStrategy : refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i) => parseDateDef(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser(def);
  }
}
var integerDateParser = (def) => {
  const res = {
    type: "integer",
    format: "unix-time"
  };
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        res.minimum = check.value;
        break;
      case "max":
        res.maximum = check.value;
        break;
    }
  }
  return res;
};
function parseDefaultDef(_def, refs) {
  return __spreadProps(__spreadValues({}, parseDef(_def.innerType._def, refs)), {
    default: _def.defaultValue()
  });
}
function parseEffectsDef(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : parseAnyDef();
}
function parseEnumDef(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}
var isJsonSchema7AllOfType = (type) => {
  if ("type" in type && type.type === "string") return false;
  return "allOf" in type;
};
function parseIntersectionDef(def, refs) {
  const allOf = [
    parseDef(def.left._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "allOf", "0"]
    })),
    parseDef(def.right._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "allOf", "1"]
    }))
  ].filter((x) => !!x);
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType(schema)) {
      mergedAllOf.push(...schema.allOf);
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const _a16 = schema, { additionalProperties } = _a16, rest = __objRest(_a16, ["additionalProperties"]);
        nestedSchema = rest;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? { allOf: mergedAllOf } : void 0;
}
function parseLiteralDef(def) {
  const parsedType = typeof def.value;
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    const: def.value
  };
}
var emojiRegex = void 0;
var zodPatterns = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => {
    if (emojiRegex === void 0) {
      emojiRegex = RegExp(
        "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
        "u"
      );
    }
    return emojiRegex;
  },
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef(def, refs) {
  const res = {
    type: "string"
  };
  if (def.checks) {
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value;
          break;
        case "max":
          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value;
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat(res, "email", check.message, refs);
              break;
            case "format:idn-email":
              addFormat(res, "idn-email", check.message, refs);
              break;
            case "pattern:zod":
              addPattern(res, zodPatterns.email, check.message, refs);
              break;
          }
          break;
        case "url":
          addFormat(res, "uri", check.message, refs);
          break;
        case "uuid":
          addFormat(res, "uuid", check.message, refs);
          break;
        case "regex":
          addPattern(res, check.regex, check.message, refs);
          break;
        case "cuid":
          addPattern(res, zodPatterns.cuid, check.message, refs);
          break;
        case "cuid2":
          addPattern(res, zodPatterns.cuid2, check.message, refs);
          break;
        case "startsWith":
          addPattern(
            res,
            RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`),
            check.message,
            refs
          );
          break;
        case "endsWith":
          addPattern(
            res,
            RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`),
            check.message,
            refs
          );
          break;
        case "datetime":
          addFormat(res, "date-time", check.message, refs);
          break;
        case "date":
          addFormat(res, "date", check.message, refs);
          break;
        case "time":
          addFormat(res, "time", check.message, refs);
          break;
        case "duration":
          addFormat(res, "duration", check.message, refs);
          break;
        case "length":
          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value;
          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value;
          break;
        case "includes": {
          addPattern(
            res,
            RegExp(escapeLiteralCheckValue(check.value, refs)),
            check.message,
            refs
          );
          break;
        }
        case "ip": {
          if (check.version !== "v6") {
            addFormat(res, "ipv4", check.message, refs);
          }
          if (check.version !== "v4") {
            addFormat(res, "ipv6", check.message, refs);
          }
          break;
        }
        case "base64url":
          addPattern(res, zodPatterns.base64url, check.message, refs);
          break;
        case "jwt":
          addPattern(res, zodPatterns.jwt, check.message, refs);
          break;
        case "cidr": {
          if (check.version !== "v6") {
            addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);
          }
          if (check.version !== "v4") {
            addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern(res, zodPatterns.emoji(), check.message, refs);
          break;
        case "ulid": {
          addPattern(res, zodPatterns.ulid, check.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat(res, "binary", check.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              res.contentEncoding = "base64";
              break;
            }
            case "pattern:zod": {
              addPattern(res, zodPatterns.base64, check.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern(res, zodPatterns.nanoid, check.message, refs);
        }
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
          break;
        default:
          /* @__PURE__ */ ((_) => {
          })(check);
      }
    }
  }
  return res;
}
function escapeLiteralCheckValue(literal, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(literal) : literal;
}
var ALPHA_NUMERIC = new Set(
  "ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789"
);
function escapeNonAlphaNumeric(source) {
  let result = "";
  for (let i = 0; i < source.length; i++) {
    if (!ALPHA_NUMERIC.has(source[i])) {
      result += "\\";
    }
    result += source[i];
  }
  return result;
}
function addFormat(schema, value, message, refs) {
  var _a22;
  if (schema.format || ((_a22 = schema.anyOf) == null ? void 0 : _a22.some((x) => x.format))) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format
      });
      delete schema.format;
    }
    schema.anyOf.push(__spreadValues({
      format: value
    }, message && refs.errorMessages && { errorMessage: { format: message } }));
  } else {
    schema.format = value;
  }
}
function addPattern(schema, regex, message, refs) {
  var _a22;
  if (schema.pattern || ((_a22 = schema.allOf) == null ? void 0 : _a22.some((x) => x.pattern))) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern
      });
      delete schema.pattern;
    }
    schema.allOf.push(__spreadValues({
      pattern: stringifyRegExpWithFlags(regex, refs)
    }, message && refs.errorMessages && { errorMessage: { pattern: message } }));
  } else {
    schema.pattern = stringifyRegExpWithFlags(regex, refs);
  }
}
function stringifyRegExpWithFlags(regex, refs) {
  var _a22;
  if (!refs.applyRegexFlags || !regex.flags) {
    return regex.source;
  }
  const flags = {
    i: regex.flags.includes("i"),
    // Case-insensitive
    m: regex.flags.includes("m"),
    // `^` and `$` matches adjacent to newline characters
    s: regex.flags.includes("s")
    // `.` matches newlines
  };
  const source = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i = 0; i < source.length; i++) {
    if (isEscaped) {
      pattern += source[i];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i];
            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i + 1] === "-" && ((_a22 = source[i + 2]) == null ? void 0 : _a22.match(/[a-z]/))) {
            pattern += source[i];
            inCharRange = true;
          } else {
            pattern += `${source[i]}${source[i].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i].match(/[a-z]/)) {
        pattern += `[${source[i]}${source[i].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i] === ".") {
      pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
      continue;
    }
    pattern += source[i];
    if (source[i] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i] === "[") {
      inCharGroup = true;
    }
  }
  try {
    new RegExp(pattern);
  } catch (e) {
    console.warn(
      `Could not convert regex pattern at ${refs.currentPath.join(
        "/"
      )} to a flag-independent form! Falling back to the flag-ignorant source`
    );
    return regex.source;
  }
  return pattern;
}
function parseRecordDef(def, refs) {
  var _a22, _b22, _c, _d, _e, _f;
  const schema = {
    type: "object",
    additionalProperties: (_a22 = parseDef(def.valueType._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "additionalProperties"]
    }))) != null ? _a22 : refs.allowedAdditionalProperties
  };
  if (((_b22 = def.keyType) == null ? void 0 : _b22._def.typeName) === import_v33.ZodFirstPartyTypeKind.ZodString && ((_c = def.keyType._def.checks) == null ? void 0 : _c.length)) {
    const _a16 = parseStringDef(def.keyType._def, refs), { type } = _a16, keyType = __objRest(_a16, ["type"]);
    return __spreadProps(__spreadValues({}, schema), {
      propertyNames: keyType
    });
  } else if (((_d = def.keyType) == null ? void 0 : _d._def.typeName) === import_v33.ZodFirstPartyTypeKind.ZodEnum) {
    return __spreadProps(__spreadValues({}, schema), {
      propertyNames: {
        enum: def.keyType._def.values
      }
    });
  } else if (((_e = def.keyType) == null ? void 0 : _e._def.typeName) === import_v33.ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === import_v33.ZodFirstPartyTypeKind.ZodString && ((_f = def.keyType._def.type._def.checks) == null ? void 0 : _f.length)) {
    const _b16 = parseBrandedDef(
      def.keyType._def,
      refs
    ), { type } = _b16, keyType = __objRest(_b16, ["type"]);
    return __spreadProps(__spreadValues({}, schema), {
      propertyNames: keyType
    });
  }
  return schema;
}
function parseMapDef(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef(def, refs);
  }
  const keys = parseDef(def.keyType._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "items", "items", "0"]
  })) || parseAnyDef();
  const values = parseDef(def.valueType._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "items", "items", "1"]
  })) || parseAnyDef();
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}
function parseNativeEnumDef(def) {
  const object = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object[object[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object[key]);
  const parsedTypes = Array.from(
    new Set(actualValues.map((values) => typeof values))
  );
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}
function parseNeverDef() {
  return { not: parseAnyDef() };
}
function parseNullDef() {
  return {
    type: "null"
  };
}
var primitiveMappings = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef(def, refs) {
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every(
    (x) => x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length)
  )) {
    const types = options.reduce((types2, x) => {
      const type = primitiveMappings[x._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options.reduce(
      (acc, x) => {
        const type = typeof x._def.value;
        switch (type) {
          case "string":
          case "number":
          case "boolean":
            return [...acc, type];
          case "bigint":
            return [...acc, "integer"];
          case "object":
            if (x._def.value === null) return [...acc, "null"];
          case "symbol":
          case "undefined":
          case "function":
          default:
            return acc;
        }
      },
      []
    );
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce(
          (acc, x) => {
            return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
          },
          []
        )
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce(
        (acc, x) => [
          ...acc,
          ...x._def.values.filter((x2) => !acc.includes(x2))
        ],
        []
      )
    };
  }
  return asAnyOf(def, refs);
}
var asAnyOf = (def, refs) => {
  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map(
    (x, i) => parseDef(x._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "anyOf", `${i}`]
    }))
  ).filter(
    (x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0)
  );
  return anyOf.length ? { anyOf } : void 0;
};
function parseNullableDef(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(
    def.innerType._def.typeName
  ) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    return {
      type: [
        primitiveMappings[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  const base = parseDef(def.innerType._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "anyOf", "0"]
  }));
  return base && { anyOf: [base, { type: "null" }] };
}
function parseNumberDef(def) {
  const res = {
    type: "number"
  };
  if (!def.checks) return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "int":
        res.type = "integer";
        break;
      case "min":
        if (check.inclusive) {
          res.minimum = check.value;
        } else {
          res.exclusiveMinimum = check.value;
        }
        break;
      case "max":
        if (check.inclusive) {
          res.maximum = check.value;
        } else {
          res.exclusiveMaximum = check.value;
        }
        break;
      case "multipleOf":
        res.multipleOf = check.value;
        break;
    }
  }
  return res;
}
function parseObjectDef(def, refs) {
  const result = {
    type: "object",
    properties: {}
  };
  const required = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === void 0 || propDef._def === void 0) {
      continue;
    }
    const propOptional = safeIsOptional(propDef);
    const parsedDef = parseDef(propDef._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "properties", propName],
      propertyPath: [...refs.currentPath, "properties", propName]
    }));
    if (parsedDef === void 0) {
      continue;
    }
    result.properties[propName] = parsedDef;
    if (!propOptional) {
      required.push(propName);
    }
  }
  if (required.length) {
    result.required = required;
  }
  const additionalProperties = decideAdditionalProperties(def, refs);
  if (additionalProperties !== void 0) {
    result.additionalProperties = additionalProperties;
  }
  return result;
}
function decideAdditionalProperties(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever") {
    return parseDef(def.catchall._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "additionalProperties"]
    }));
  }
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
function safeIsOptional(schema) {
  try {
    return schema.isOptional();
  } catch (e) {
    return true;
  }
}
var parseOptionalDef = (def, refs) => {
  var _a22;
  if (refs.currentPath.toString() === ((_a22 = refs.propertyPath) == null ? void 0 : _a22.toString())) {
    return parseDef(def.innerType._def, refs);
  }
  const innerSchema = parseDef(def.innerType._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "anyOf", "1"]
  }));
  return innerSchema ? { anyOf: [{ not: parseAnyDef() }, innerSchema] } : parseAnyDef();
};
var parsePipelineDef = (def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef(def.out._def, refs);
  }
  const a = parseDef(def.in._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "allOf", "0"]
  }));
  const b = parseDef(def.out._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
  }));
  return {
    allOf: [a, b].filter((x) => x !== void 0)
  };
};
function parsePromiseDef(def, refs) {
  return parseDef(def.type._def, refs);
}
function parseSetDef(def, refs) {
  const items = parseDef(def.valueType._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "items"]
  }));
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    schema.minItems = def.minSize.value;
  }
  if (def.maxSize) {
    schema.maxItems = def.maxSize.value;
  }
  return schema;
}
function parseTupleDef(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map(
        (x, i) => parseDef(x._def, __spreadProps(__spreadValues({}, refs), {
          currentPath: [...refs.currentPath, "items", `${i}`]
        }))
      ).reduce(
        (acc, x) => x === void 0 ? acc : [...acc, x],
        []
      ),
      additionalItems: parseDef(def.rest._def, __spreadProps(__spreadValues({}, refs), {
        currentPath: [...refs.currentPath, "additionalItems"]
      }))
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map(
        (x, i) => parseDef(x._def, __spreadProps(__spreadValues({}, refs), {
          currentPath: [...refs.currentPath, "items", `${i}`]
        }))
      ).reduce(
        (acc, x) => x === void 0 ? acc : [...acc, x],
        []
      )
    };
  }
}
function parseUndefinedDef() {
  return {
    not: parseAnyDef()
  };
}
function parseUnknownDef() {
  return parseAnyDef();
}
var parseReadonlyDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};
var selectParser = (def, typeName, refs) => {
  switch (typeName) {
    case import_v3.ZodFirstPartyTypeKind.ZodString:
      return parseStringDef(def, refs);
    case import_v3.ZodFirstPartyTypeKind.ZodNumber:
      return parseNumberDef(def);
    case import_v3.ZodFirstPartyTypeKind.ZodObject:
      return parseObjectDef(def, refs);
    case import_v3.ZodFirstPartyTypeKind.ZodBigInt:
      return parseBigintDef(def);
    case import_v3.ZodFirstPartyTypeKind.ZodBoolean:
      return parseBooleanDef();
    case import_v3.ZodFirstPartyTypeKind.ZodDate:
      return parseDateDef(def, refs);
    case import_v3.ZodFirstPartyTypeKind.ZodUndefined:
      return parseUndefinedDef();
    case import_v3.ZodFirstPartyTypeKind.ZodNull:
      return parseNullDef();
    case import_v3.ZodFirstPartyTypeKind.ZodArray:
      return parseArrayDef(def, refs);
    case import_v3.ZodFirstPartyTypeKind.ZodUnion:
    case import_v3.ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      return parseUnionDef(def, refs);
    case import_v3.ZodFirstPartyTypeKind.ZodIntersection:
      return parseIntersectionDef(def, refs);
    case import_v3.ZodFirstPartyTypeKind.ZodTuple:
      return parseTupleDef(def, refs);
    case import_v3.ZodFirstPartyTypeKind.ZodRecord:
      return parseRecordDef(def, refs);
    case import_v3.ZodFirstPartyTypeKind.ZodLiteral:
      return parseLiteralDef(def);
    case import_v3.ZodFirstPartyTypeKind.ZodEnum:
      return parseEnumDef(def);
    case import_v3.ZodFirstPartyTypeKind.ZodNativeEnum:
      return parseNativeEnumDef(def);
    case import_v3.ZodFirstPartyTypeKind.ZodNullable:
      return parseNullableDef(def, refs);
    case import_v3.ZodFirstPartyTypeKind.ZodOptional:
      return parseOptionalDef(def, refs);
    case import_v3.ZodFirstPartyTypeKind.ZodMap:
      return parseMapDef(def, refs);
    case import_v3.ZodFirstPartyTypeKind.ZodSet:
      return parseSetDef(def, refs);
    case import_v3.ZodFirstPartyTypeKind.ZodLazy:
      return () => def.getter()._def;
    case import_v3.ZodFirstPartyTypeKind.ZodPromise:
      return parsePromiseDef(def, refs);
    case import_v3.ZodFirstPartyTypeKind.ZodNaN:
    case import_v3.ZodFirstPartyTypeKind.ZodNever:
      return parseNeverDef();
    case import_v3.ZodFirstPartyTypeKind.ZodEffects:
      return parseEffectsDef(def, refs);
    case import_v3.ZodFirstPartyTypeKind.ZodAny:
      return parseAnyDef();
    case import_v3.ZodFirstPartyTypeKind.ZodUnknown:
      return parseUnknownDef();
    case import_v3.ZodFirstPartyTypeKind.ZodDefault:
      return parseDefaultDef(def, refs);
    case import_v3.ZodFirstPartyTypeKind.ZodBranded:
      return parseBrandedDef(def, refs);
    case import_v3.ZodFirstPartyTypeKind.ZodReadonly:
      return parseReadonlyDef(def, refs);
    case import_v3.ZodFirstPartyTypeKind.ZodCatch:
      return parseCatchDef(def, refs);
    case import_v3.ZodFirstPartyTypeKind.ZodPipeline:
      return parsePipelineDef(def, refs);
    case import_v3.ZodFirstPartyTypeKind.ZodFunction:
    case import_v3.ZodFirstPartyTypeKind.ZodVoid:
    case import_v3.ZodFirstPartyTypeKind.ZodSymbol:
      return void 0;
    default:
      return /* @__PURE__ */ ((_) => void 0)(typeName);
  }
};
var getRelativePath = (pathA, pathB) => {
  let i = 0;
  for (; i < pathA.length && i < pathB.length; i++) {
    if (pathA[i] !== pathB[i]) break;
  }
  return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
};
function parseDef(def, refs, forceResolution = false) {
  var _a22;
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = (_a22 = refs.override) == null ? void 0 : _a22.call(
      refs,
      def,
      refs,
      seenItem,
      forceResolution
    );
    if (overrideResult !== ignoreOverride) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);
  const jsonSchema2 = typeof jsonSchemaOrGetter === "function" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema2) {
    addMeta(def, refs, jsonSchema2);
  }
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema2, def, refs);
    newItem.jsonSchema = jsonSchema2;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema2;
  return jsonSchema2;
}
var get$ref = (item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
        console.warn(
          `Recursive reference detected at ${refs.currentPath.join(
            "/"
          )}! Defaulting to any`
        );
        return parseAnyDef();
      }
      return refs.$refStrategy === "seen" ? parseAnyDef() : void 0;
    }
  }
};
var addMeta = (def, refs, jsonSchema2) => {
  if (def.description) {
    jsonSchema2.description = def.description;
  }
  return jsonSchema2;
};
var getRefs = (options) => {
  const _options = getDefaultOptions(options);
  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return __spreadProps(__spreadValues({}, _options), {
    currentPath,
    propertyPath: void 0,
    seen: new Map(
      Object.entries(_options.definitions).map(([name22, def]) => [
        def._def,
        {
          def: def._def,
          path: [..._options.basePath, _options.definitionPath, name22],
          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
          jsonSchema: void 0
        }
      ])
    )
  });
};
var zod3ToJsonSchema = (schema, options) => {
  var _a22;
  const refs = getRefs(options);
  let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce(
    (acc, [name32, schema2]) => {
      var _a32;
      return __spreadProps(__spreadValues({}, acc), {
        [name32]: (_a32 = parseDef(
          schema2._def,
          __spreadProps(__spreadValues({}, refs), {
            currentPath: [...refs.basePath, refs.definitionPath, name32]
          }),
          true
        )) != null ? _a32 : parseAnyDef()
      });
    },
    {}
  ) : void 0;
  const name22 = typeof options === "string" ? options : (options == null ? void 0 : options.nameStrategy) === "title" ? void 0 : options == null ? void 0 : options.name;
  const main = (_a22 = parseDef(
    schema._def,
    name22 === void 0 ? refs : __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.basePath, refs.definitionPath, name22]
    }),
    false
  )) != null ? _a22 : parseAnyDef();
  const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
  if (title !== void 0) {
    main.title = title;
  }
  const combined = name22 === void 0 ? definitions ? __spreadProps(__spreadValues({}, main), {
    [refs.definitionPath]: definitions
  }) : main : {
    $ref: [
      ...refs.$refStrategy === "relative" ? [] : refs.basePath,
      refs.definitionPath,
      name22
    ].join("/"),
    [refs.definitionPath]: __spreadProps(__spreadValues({}, definitions), {
      [name22]: main
    })
  };
  combined.$schema = "http://json-schema.org/draft-07/schema#";
  return combined;
};
var schemaSymbol = Symbol.for("vercel.ai.schema");
function jsonSchema(jsonSchema2, {
  validate
} = {}) {
  return {
    [schemaSymbol]: true,
    _type: void 0,
    // should never be used directly
    get jsonSchema() {
      if (typeof jsonSchema2 === "function") {
        jsonSchema2 = jsonSchema2();
      }
      return jsonSchema2;
    },
    validate
  };
}
function isSchema(value) {
  return typeof value === "object" && value !== null && schemaSymbol in value && value[schemaSymbol] === true && "jsonSchema" in value && "validate" in value;
}
function asSchema(schema) {
  return schema == null ? jsonSchema({ properties: {}, additionalProperties: false }) : isSchema(schema) ? schema : "~standard" in schema ? schema["~standard"].vendor === "zod" ? zodSchema(schema) : standardSchema(schema) : schema();
}
function standardSchema(standardSchema2) {
  return jsonSchema(
    () => standardSchema2["~standard"].jsonSchema.input({
      target: "draft-07"
    }),
    {
      validate: async (value) => {
        const result = await standardSchema2["~standard"].validate(value);
        return "value" in result ? { success: true, value: result.value } : {
          success: false,
          error: new TypeValidationError({
            value,
            cause: result.issues
          })
        };
      }
    }
  );
}
function zod3Schema(zodSchema2, options) {
  var _a22;
  const useReferences = (_a22 = options == null ? void 0 : options.useReferences) != null ? _a22 : false;
  return jsonSchema(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => zod3ToJsonSchema(zodSchema2, {
      $refStrategy: useReferences ? "root" : "none"
    }),
    {
      validate: async (value) => {
        const result = await zodSchema2.safeParseAsync(value);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      }
    }
  );
}
function zod4Schema(zodSchema2, options) {
  var _a22;
  const useReferences = (_a22 = options == null ? void 0 : options.useReferences) != null ? _a22 : false;
  return jsonSchema(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => addAdditionalPropertiesToJsonSchema(
      z4.toJSONSchema(zodSchema2, {
        target: "draft-7",
        io: "input",
        reused: useReferences ? "ref" : "inline"
      })
    ),
    {
      validate: async (value) => {
        const result = await z4.safeParseAsync(zodSchema2, value);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      }
    }
  );
}
function isZod4Schema(zodSchema2) {
  return "_zod" in zodSchema2;
}
function zodSchema(zodSchema2, options) {
  if (isZod4Schema(zodSchema2)) {
    return zod4Schema(zodSchema2, options);
  } else {
    return zod3Schema(zodSchema2, options);
  }
}
async function validateTypes({
  value,
  schema
}) {
  const result = await safeValidateTypes({ value, schema });
  if (!result.success) {
    throw TypeValidationError.wrap({ value, cause: result.error });
  }
  return result.value;
}
async function safeValidateTypes({
  value,
  schema
}) {
  const actualSchema = asSchema(schema);
  try {
    if (actualSchema.validate == null) {
      return { success: true, value, rawValue: value };
    }
    const result = await actualSchema.validate(value);
    if (result.success) {
      return { success: true, value: result.value, rawValue: value };
    }
    return {
      success: false,
      error: TypeValidationError.wrap({ value, cause: result.error }),
      rawValue: value
    };
  } catch (error) {
    return {
      success: false,
      error: TypeValidationError.wrap({ value, cause: error }),
      rawValue: value
    };
  }
}
async function parseJSON({
  text,
  schema
}) {
  try {
    const value = secureJsonParse(text);
    if (schema == null) {
      return value;
    }
    return validateTypes({ value, schema });
  } catch (error) {
    if (JSONParseError.isInstance(error) || TypeValidationError.isInstance(error)) {
      throw error;
    }
    throw new JSONParseError({ text, cause: error });
  }
}
async function safeParseJSON({
  text,
  schema
}) {
  try {
    const value = secureJsonParse(text);
    if (schema == null) {
      return { success: true, value, rawValue: value };
    }
    return await safeValidateTypes({ value, schema });
  } catch (error) {
    return {
      success: false,
      error: JSONParseError.isInstance(error) ? error : new JSONParseError({ text, cause: error }),
      rawValue: void 0
    };
  }
}
function isParsableJson(input) {
  try {
    secureJsonParse(input);
    return true;
  } catch (e) {
    return false;
  }
}
function parseJsonEventStream({
  stream,
  schema
}) {
  return stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream()).pipeThrough(
    new TransformStream({
      async transform({ data }, controller) {
        if (data === "[DONE]") {
          return;
        }
        controller.enqueue(await safeParseJSON({ text: data, schema }));
      }
    })
  );
}
var getOriginalFetch2 = () => globalThis.fetch;
var postJsonToApi = async ({
  url,
  headers,
  body,
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch: fetch2
}) => postToApi({
  url,
  headers: __spreadValues({
    "Content-Type": "application/json"
  }, headers),
  body: {
    content: JSON.stringify(body),
    values: body
  },
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch: fetch2
});
var postToApi = async ({
  url,
  headers = {},
  body,
  successfulResponseHandler,
  failedResponseHandler,
  abortSignal,
  fetch: fetch2 = getOriginalFetch2()
}) => {
  try {
    const response = await fetch2(url, {
      method: "POST",
      headers: withUserAgentSuffix(
        headers,
        `ai-sdk/provider-utils/${VERSION}`,
        getRuntimeEnvironmentUserAgent()
      ),
      body: body.content,
      signal: abortSignal
    });
    const responseHeaders = extractResponseHeaders(response);
    if (!response.ok) {
      let errorInformation;
      try {
        errorInformation = await failedResponseHandler({
          response,
          url,
          requestBodyValues: body.values
        });
      } catch (error) {
        if (isAbortError(error) || APICallError.isInstance(error)) {
          throw error;
        }
        throw new APICallError({
          message: "Failed to process error response",
          cause: error,
          statusCode: response.status,
          url,
          responseHeaders,
          requestBodyValues: body.values
        });
      }
      throw errorInformation.value;
    }
    try {
      return await successfulResponseHandler({
        response,
        url,
        requestBodyValues: body.values
      });
    } catch (error) {
      if (error instanceof Error) {
        if (isAbortError(error) || APICallError.isInstance(error)) {
          throw error;
        }
      }
      throw new APICallError({
        message: "Failed to process successful response",
        cause: error,
        statusCode: response.status,
        url,
        responseHeaders,
        requestBodyValues: body.values
      });
    }
  } catch (error) {
    throw handleFetchError({ error, url, requestBodyValues: body.values });
  }
};
var createJsonErrorResponseHandler = ({
  errorSchema,
  errorToMessage,
  isRetryable
}) => async ({ response, url, requestBodyValues }) => {
  const responseBody = await response.text();
  const responseHeaders = extractResponseHeaders(response);
  if (responseBody.trim() === "") {
    return {
      responseHeaders,
      value: new APICallError({
        message: response.statusText,
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response)
      })
    };
  }
  try {
    const parsedError = await parseJSON({
      text: responseBody,
      schema: errorSchema
    });
    return {
      responseHeaders,
      value: new APICallError({
        message: errorToMessage(parsedError),
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        data: parsedError,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)
      })
    };
  } catch (parseError) {
    return {
      responseHeaders,
      value: new APICallError({
        message: response.statusText,
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response)
      })
    };
  }
};
var createEventSourceResponseHandler = (chunkSchema) => async ({ response }) => {
  const responseHeaders = extractResponseHeaders(response);
  if (response.body == null) {
    throw new EmptyResponseBodyError({});
  }
  return {
    responseHeaders,
    value: parseJsonEventStream({
      stream: response.body,
      schema: chunkSchema
    })
  };
};
var createJsonResponseHandler = (responseSchema) => async ({ response, url, requestBodyValues }) => {
  const responseBody = await response.text();
  const parsedResult = await safeParseJSON({
    text: responseBody,
    schema: responseSchema
  });
  const responseHeaders = extractResponseHeaders(response);
  if (!parsedResult.success) {
    throw new APICallError({
      message: "Invalid JSON response",
      cause: parsedResult.error,
      statusCode: response.status,
      responseHeaders,
      responseBody,
      url,
      requestBodyValues
    });
  }
  return {
    responseHeaders,
    value: parsedResult.value,
    rawValue: parsedResult.rawValue
  };
};
function withoutTrailingSlash(url) {
  return url == null ? void 0 : url.replace(/\/$/, "");
}

// src/schemas/reasoning-details.ts
var import_v4 = require("zod/v4");

// src/utils/type-guards.ts
function isDefinedOrNotNull(value) {
  return value !== null && value !== void 0;
}

// src/schemas/format.ts
var ReasoningFormat = /* @__PURE__ */ ((ReasoningFormat2) => {
  ReasoningFormat2["Unknown"] = "unknown";
  ReasoningFormat2["OpenAIResponsesV1"] = "openai-responses-v1";
  ReasoningFormat2["XAIResponsesV1"] = "xai-responses-v1";
  ReasoningFormat2["AnthropicClaudeV1"] = "anthropic-claude-v1";
  ReasoningFormat2["GoogleGeminiV1"] = "google-gemini-v1";
  return ReasoningFormat2;
})(ReasoningFormat || {});

// src/schemas/reasoning-details.ts
var CommonReasoningDetailSchema = import_v4.z.object({
  id: import_v4.z.string().nullish(),
  format: import_v4.z.enum(ReasoningFormat).nullish(),
  index: import_v4.z.number().optional()
}).loose();
var ReasoningDetailSummarySchema = import_v4.z.object({
  type: import_v4.z.literal("reasoning.summary" /* Summary */),
  summary: import_v4.z.string()
}).extend(CommonReasoningDetailSchema.shape);
var ReasoningDetailEncryptedSchema = import_v4.z.object({
  type: import_v4.z.literal("reasoning.encrypted" /* Encrypted */),
  data: import_v4.z.string()
}).extend(CommonReasoningDetailSchema.shape);
var ReasoningDetailTextSchema = import_v4.z.object({
  type: import_v4.z.literal("reasoning.text" /* Text */),
  text: import_v4.z.string().nullish(),
  signature: import_v4.z.string().nullish()
}).extend(CommonReasoningDetailSchema.shape);
var ReasoningDetailUnionSchema = import_v4.z.union([
  ReasoningDetailSummarySchema,
  ReasoningDetailEncryptedSchema,
  ReasoningDetailTextSchema
]);
var ReasoningDetailsWithUnknownSchema = import_v4.z.union([
  ReasoningDetailUnionSchema,
  import_v4.z.unknown().transform(() => null)
]);
var ReasoningDetailArraySchema = import_v4.z.array(ReasoningDetailsWithUnknownSchema).transform((d) => d.filter((d2) => !!d2));
var OutputUnionToReasoningDetailsSchema = import_v4.z.union([
  import_v4.z.object({
    delta: import_v4.z.object({
      reasoning_details: import_v4.z.array(ReasoningDetailsWithUnknownSchema)
    })
  }).transform(
    (data) => data.delta.reasoning_details.filter(isDefinedOrNotNull)
  ),
  import_v4.z.object({
    message: import_v4.z.object({
      reasoning_details: import_v4.z.array(ReasoningDetailsWithUnknownSchema)
    })
  }).transform(
    (data) => data.message.reasoning_details.filter(isDefinedOrNotNull)
  ),
  import_v4.z.object({
    text: import_v4.z.string(),
    reasoning_details: import_v4.z.array(ReasoningDetailsWithUnknownSchema)
  }).transform((data) => data.reasoning_details.filter(isDefinedOrNotNull))
]);

// src/schemas/error-response.ts
var import_v42 = require("zod/v4");
var OpenRouterErrorResponseSchema = import_v42.z.object({
  error: import_v42.z.object({
    code: import_v42.z.union([import_v42.z.string(), import_v42.z.number()]).nullable().optional().default(null),
    message: import_v42.z.string(),
    type: import_v42.z.string().nullable().optional().default(null),
    param: import_v42.z.any().nullable().optional().default(null)
  }).passthrough()
}).passthrough();
var openrouterFailedResponseHandler = createJsonErrorResponseHandler({
  errorSchema: OpenRouterErrorResponseSchema,
  errorToMessage: (data) => data.error.message
});

// src/schemas/provider-metadata.ts
var import_v43 = require("zod/v4");
var FileAnnotationSchema = import_v43.z.object({
  type: import_v43.z.literal("file"),
  file: import_v43.z.object({
    hash: import_v43.z.string(),
    name: import_v43.z.string(),
    content: import_v43.z.array(
      import_v43.z.object({
        type: import_v43.z.string(),
        text: import_v43.z.string().optional()
      }).catchall(import_v43.z.any())
    ).optional()
  }).catchall(import_v43.z.any())
}).catchall(import_v43.z.any());
var OpenRouterProviderMetadataSchema = import_v43.z.object({
  provider: import_v43.z.string(),
  reasoning_details: import_v43.z.array(ReasoningDetailUnionSchema).optional(),
  annotations: import_v43.z.array(FileAnnotationSchema).optional(),
  usage: import_v43.z.object({
    promptTokens: import_v43.z.number(),
    promptTokensDetails: import_v43.z.object({
      cachedTokens: import_v43.z.number()
    }).catchall(import_v43.z.any()).optional(),
    completionTokens: import_v43.z.number(),
    completionTokensDetails: import_v43.z.object({
      reasoningTokens: import_v43.z.number()
    }).catchall(import_v43.z.any()).optional(),
    totalTokens: import_v43.z.number(),
    cost: import_v43.z.number().optional(),
    costDetails: import_v43.z.object({
      upstreamInferenceCost: import_v43.z.number()
    }).catchall(import_v43.z.any()).optional()
  }).catchall(import_v43.z.any())
}).catchall(import_v43.z.any());
var OpenRouterProviderOptionsSchema = import_v43.z.object({
  openrouter: import_v43.z.object({
    reasoning_details: import_v43.z.array(ReasoningDetailUnionSchema).optional(),
    annotations: import_v43.z.array(FileAnnotationSchema).optional()
  }).optional()
}).optional();

// src/utils/map-finish-reason.ts
function mapToUnified(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "content_filter":
      return "content-filter";
    case "function_call":
    case "tool_calls":
      return "tool-calls";
    default:
      return "other";
  }
}
function mapOpenRouterFinishReason(finishReason) {
  return {
    unified: mapToUnified(finishReason),
    raw: finishReason != null ? finishReason : void 0
  };
}
function createFinishReason(unified, raw) {
  return { unified, raw };
}

// src/utils/reasoning-details-duplicate-tracker.ts
var _seenKeys;
var ReasoningDetailsDuplicateTracker = class {
  constructor() {
    __privateAdd(this, _seenKeys, /* @__PURE__ */ new Set());
  }
  /**
   * Attempts to track a detail.
   * Returns true if this is a NEW detail (not seen before and has valid key),
   * false if it was skipped (no valid key) or already seen (duplicate).
   */
  upsert(detail) {
    const key = this.getCanonicalKey(detail);
    if (key === null) {
      return false;
    }
    if (__privateGet(this, _seenKeys).has(key)) {
      return false;
    }
    __privateGet(this, _seenKeys).add(key);
    return true;
  }
  getCanonicalKey(detail) {
    switch (detail.type) {
      case "reasoning.summary" /* Summary */:
        return detail.summary;
      case "reasoning.encrypted" /* Encrypted */:
        if (detail.id) {
          return detail.id;
        }
        return detail.data;
      case "reasoning.text" /* Text */: {
        if (detail.text) {
          return detail.text;
        }
        if (detail.signature) {
          return detail.signature;
        }
        return null;
      }
      default: {
        return null;
      }
    }
  }
};
_seenKeys = new WeakMap();

// src/types/openrouter-chat-completions-input.ts
var OPENROUTER_AUDIO_FORMATS = [
  "wav",
  "mp3",
  "aiff",
  "aac",
  "ogg",
  "flac",
  "m4a",
  "pcm16",
  "pcm24"
];

// src/chat/is-url.ts
function isUrl({
  url,
  protocols
}) {
  try {
    const urlObj = new URL(url);
    return protocols.has(urlObj.protocol);
  } catch (_) {
    return false;
  }
}

// src/chat/file-url-utils.ts
function getFileUrl({
  part,
  defaultMediaType
}) {
  var _a16, _b16;
  if (part.data instanceof Uint8Array) {
    const base64 = convertUint8ArrayToBase64(part.data);
    return `data:${(_a16 = part.mediaType) != null ? _a16 : defaultMediaType};base64,${base64}`;
  }
  const stringUrl = part.data.toString();
  if (isUrl({
    url: stringUrl,
    protocols: /* @__PURE__ */ new Set(["http:", "https:"])
  })) {
    return stringUrl;
  }
  return stringUrl.startsWith("data:") ? stringUrl : `data:${(_b16 = part.mediaType) != null ? _b16 : defaultMediaType};base64,${stringUrl}`;
}
function getMediaType(dataUrl, defaultMediaType) {
  var _a16;
  const match = dataUrl.match(/^data:([^;]+)/);
  return match ? (_a16 = match[1]) != null ? _a16 : defaultMediaType : defaultMediaType;
}
function getBase64FromDataUrl(dataUrl) {
  const match = dataUrl.match(/^data:[^;]*;base64,(.+)$/);
  return match ? match[1] : dataUrl;
}
var MIME_TO_FORMAT = {
  // MP3 variants
  mpeg: "mp3",
  mp3: "mp3",
  // WAV variants
  "x-wav": "wav",
  wave: "wav",
  wav: "wav",
  // OGG variants
  ogg: "ogg",
  vorbis: "ogg",
  // AAC variants
  aac: "aac",
  "x-aac": "aac",
  // M4A variants
  m4a: "m4a",
  "x-m4a": "m4a",
  mp4: "m4a",
  // AIFF variants
  aiff: "aiff",
  "x-aiff": "aiff",
  // FLAC
  flac: "flac",
  "x-flac": "flac",
  // PCM variants
  pcm16: "pcm16",
  pcm24: "pcm24"
};
function getInputAudioData(part) {
  const fileData = getFileUrl({
    part,
    defaultMediaType: "audio/mpeg"
  });
  if (isUrl({
    url: fileData,
    protocols: /* @__PURE__ */ new Set(["http:", "https:"])
  })) {
    throw new Error(
      `Audio files cannot be provided as URLs.

OpenRouter requires audio to be base64-encoded. Please:
1. Download the audio file locally
2. Read it as a Buffer or Uint8Array
3. Pass it as the data parameter

The AI SDK will automatically handle base64 encoding.

Learn more: https://openrouter.ai/docs/features/multimodal/audio`
    );
  }
  const data = getBase64FromDataUrl(fileData);
  const mediaType = part.mediaType || "audio/mpeg";
  const rawFormat = mediaType.replace("audio/", "");
  const format = MIME_TO_FORMAT[rawFormat];
  if (format === void 0) {
    const supportedList = OPENROUTER_AUDIO_FORMATS.join(", ");
    throw new Error(
      `Unsupported audio format: "${mediaType}"

OpenRouter supports the following audio formats: ${supportedList}

Learn more: https://openrouter.ai/docs/features/multimodal/audio`
    );
  }
  return { data, format };
}

// src/chat/convert-to-openrouter-chat-messages.ts
function getCacheControl(providerMetadata) {
  var _a16, _b16, _c;
  const anthropic = providerMetadata == null ? void 0 : providerMetadata.anthropic;
  const openrouter2 = providerMetadata == null ? void 0 : providerMetadata.openrouter;
  return (_c = (_b16 = (_a16 = openrouter2 == null ? void 0 : openrouter2.cacheControl) != null ? _a16 : openrouter2 == null ? void 0 : openrouter2.cache_control) != null ? _b16 : anthropic == null ? void 0 : anthropic.cacheControl) != null ? _c : anthropic == null ? void 0 : anthropic.cache_control;
}
function convertToOpenRouterChatMessages(prompt) {
  var _a16, _b16, _c, _d, _e, _f, _g, _h;
  const messages = [];
  const reasoningDetailsTracker = new ReasoningDetailsDuplicateTracker();
  for (const { role, content, providerOptions } of prompt) {
    switch (role) {
      case "system": {
        messages.push({
          role: "system",
          content,
          cache_control: getCacheControl(providerOptions)
        });
        break;
      }
      case "user": {
        if (content.length === 1 && ((_a16 = content[0]) == null ? void 0 : _a16.type) === "text") {
          const cacheControl = (_b16 = getCacheControl(providerOptions)) != null ? _b16 : getCacheControl(content[0].providerOptions);
          const contentWithCacheControl = cacheControl ? [
            {
              type: "text",
              text: content[0].text,
              cache_control: cacheControl
            }
          ] : content[0].text;
          messages.push({
            role: "user",
            content: contentWithCacheControl
          });
          break;
        }
        const messageCacheControl = getCacheControl(providerOptions);
        let lastTextPartIndex = -1;
        for (let i = content.length - 1; i >= 0; i--) {
          if (((_c = content[i]) == null ? void 0 : _c.type) === "text") {
            lastTextPartIndex = i;
            break;
          }
        }
        const contentParts = content.map(
          (part, index) => {
            var _a17, _b17, _c2, _d2, _e2, _f2;
            const isLastTextPart = part.type === "text" && index === lastTextPartIndex;
            const partCacheControl = getCacheControl(part.providerOptions);
            const cacheControl = part.type === "text" ? partCacheControl != null ? partCacheControl : isLastTextPart ? messageCacheControl : void 0 : partCacheControl;
            switch (part.type) {
              case "text":
                return __spreadValues({
                  type: "text",
                  text: part.text
                }, cacheControl && { cache_control: cacheControl });
              case "file": {
                if ((_a17 = part.mediaType) == null ? void 0 : _a17.startsWith("image/")) {
                  const url = getFileUrl({
                    part,
                    defaultMediaType: "image/jpeg"
                  });
                  return __spreadValues({
                    type: "image_url",
                    image_url: {
                      url
                    }
                  }, cacheControl && { cache_control: cacheControl });
                }
                if ((_b17 = part.mediaType) == null ? void 0 : _b17.startsWith("audio/")) {
                  return __spreadValues({
                    type: "input_audio",
                    input_audio: getInputAudioData(part)
                  }, cacheControl && { cache_control: cacheControl });
                }
                const fileName = String(
                  (_f2 = (_e2 = (_d2 = (_c2 = part.providerOptions) == null ? void 0 : _c2.openrouter) == null ? void 0 : _d2.filename) != null ? _e2 : part.filename) != null ? _f2 : ""
                );
                const fileData = getFileUrl({
                  part,
                  defaultMediaType: "application/pdf"
                });
                if (isUrl({
                  url: fileData,
                  protocols: /* @__PURE__ */ new Set(["http:", "https:"])
                })) {
                  return {
                    type: "file",
                    file: {
                      filename: fileName,
                      file_data: fileData
                    }
                  };
                }
                return __spreadValues({
                  type: "file",
                  file: {
                    filename: fileName,
                    file_data: fileData
                  }
                }, cacheControl && { cache_control: cacheControl });
              }
              default: {
                return __spreadValues({
                  type: "text",
                  text: ""
                }, cacheControl && { cache_control: cacheControl });
              }
            }
          }
        );
        messages.push({
          role: "user",
          content: contentParts
        });
        break;
      }
      case "assistant": {
        let text = "";
        let reasoning = "";
        const toolCalls = [];
        for (const part of content) {
          switch (part.type) {
            case "text": {
              text += part.text;
              break;
            }
            case "tool-call": {
              toolCalls.push({
                id: part.toolCallId,
                type: "function",
                function: {
                  name: part.toolName,
                  arguments: JSON.stringify(part.input)
                }
              });
              break;
            }
            case "reasoning": {
              reasoning += part.text;
              break;
            }
            case "file":
              break;
            default: {
              break;
            }
          }
        }
        const parsedProviderOptions = OpenRouterProviderOptionsSchema.safeParse(providerOptions);
        const messageReasoningDetails = parsedProviderOptions.success ? (_e = (_d = parsedProviderOptions.data) == null ? void 0 : _d.openrouter) == null ? void 0 : _e.reasoning_details : void 0;
        const messageAnnotations = parsedProviderOptions.success ? (_g = (_f = parsedProviderOptions.data) == null ? void 0 : _f.openrouter) == null ? void 0 : _g.annotations : void 0;
        const candidateReasoningDetails = messageReasoningDetails && Array.isArray(messageReasoningDetails) && messageReasoningDetails.length > 0 ? messageReasoningDetails : findFirstReasoningDetails(content);
        let finalReasoningDetails;
        if (candidateReasoningDetails && candidateReasoningDetails.length > 0) {
          const uniqueDetails = [];
          for (const detail of candidateReasoningDetails) {
            if (reasoningDetailsTracker.upsert(detail)) {
              uniqueDetails.push(detail);
            }
          }
          finalReasoningDetails = uniqueDetails.length > 0 ? uniqueDetails : void 0;
        }
        messages.push({
          role: "assistant",
          content: text,
          tool_calls: toolCalls.length > 0 ? toolCalls : void 0,
          reasoning: reasoning || void 0,
          reasoning_details: finalReasoningDetails,
          annotations: messageAnnotations,
          cache_control: getCacheControl(providerOptions)
        });
        break;
      }
      case "tool": {
        for (const toolResponse of content) {
          if (toolResponse.type === "tool-approval-response") {
            continue;
          }
          const content2 = getToolResultContent(toolResponse);
          messages.push({
            role: "tool",
            tool_call_id: toolResponse.toolCallId,
            content: content2,
            cache_control: (_h = getCacheControl(providerOptions)) != null ? _h : getCacheControl(toolResponse.providerOptions)
          });
        }
        break;
      }
      default: {
        break;
      }
    }
  }
  return messages;
}
function getToolResultContent(input) {
  var _a16;
  switch (input.output.type) {
    case "text":
    case "error-text":
      return input.output.value;
    case "json":
    case "error-json":
    case "content":
      return JSON.stringify(input.output.value);
    case "execution-denied":
      return (_a16 = input.output.reason) != null ? _a16 : "Tool execution denied";
  }
}
function findFirstReasoningDetails(content) {
  var _a16, _b16, _c;
  for (const part of content) {
    if (part.type === "tool-call") {
      const openrouter2 = (_a16 = part.providerOptions) == null ? void 0 : _a16.openrouter;
      const details = openrouter2 == null ? void 0 : openrouter2.reasoning_details;
      if (Array.isArray(details) && details.length > 0) {
        return details;
      }
    }
  }
  for (const part of content) {
    if (part.type === "reasoning") {
      const parsed = OpenRouterProviderOptionsSchema.safeParse(
        part.providerOptions
      );
      if (parsed.success && ((_c = (_b16 = parsed.data) == null ? void 0 : _b16.openrouter) == null ? void 0 : _c.reasoning_details) && parsed.data.openrouter.reasoning_details.length > 0) {
        return parsed.data.openrouter.reasoning_details;
      }
    }
  }
  return void 0;
}

// src/chat/get-tool-choice.ts
var import_v44 = require("zod/v4");
var ChatCompletionToolChoiceSchema = import_v44.z.union([
  import_v44.z.literal("auto"),
  import_v44.z.literal("none"),
  import_v44.z.literal("required"),
  import_v44.z.object({
    type: import_v44.z.literal("function"),
    function: import_v44.z.object({
      name: import_v44.z.string()
    })
  })
]);
function getChatCompletionToolChoice(toolChoice) {
  switch (toolChoice.type) {
    case "auto":
    case "none":
    case "required":
      return toolChoice.type;
    case "tool": {
      return {
        type: "function",
        function: { name: toolChoice.toolName }
      };
    }
    default: {
      toolChoice;
      throw new InvalidArgumentError({
        argument: "toolChoice",
        message: `Invalid tool choice type: ${JSON.stringify(toolChoice)}`
      });
    }
  }
}

// src/chat/schemas.ts
var import_v46 = require("zod/v4");

// src/schemas/image.ts
var import_v45 = require("zod/v4");
var ImageResponseSchema = import_v45.z.object({
  type: import_v45.z.literal("image_url"),
  image_url: import_v45.z.object({
    url: import_v45.z.string()
  }).passthrough()
}).passthrough();
var ImageResponseWithUnknownSchema = import_v45.z.union([
  ImageResponseSchema,
  import_v45.z.unknown().transform(() => null)
]);
var ImageResponseArraySchema = import_v45.z.array(ImageResponseWithUnknownSchema).transform((d) => d.filter((d2) => !!d2));

// src/chat/schemas.ts
var OpenRouterChatCompletionBaseResponseSchema = import_v46.z.object({
  id: import_v46.z.string().optional(),
  model: import_v46.z.string().optional(),
  provider: import_v46.z.string().optional(),
  usage: import_v46.z.object({
    prompt_tokens: import_v46.z.number(),
    prompt_tokens_details: import_v46.z.object({
      cached_tokens: import_v46.z.number()
    }).passthrough().nullish(),
    completion_tokens: import_v46.z.number(),
    completion_tokens_details: import_v46.z.object({
      reasoning_tokens: import_v46.z.number()
    }).passthrough().nullish(),
    total_tokens: import_v46.z.number(),
    cost: import_v46.z.number().optional(),
    cost_details: import_v46.z.object({
      upstream_inference_cost: import_v46.z.number().nullish()
    }).passthrough().nullish()
  }).passthrough().nullish()
}).passthrough();
var OpenRouterNonStreamChatCompletionResponseSchema = import_v46.z.union([
  // Success response with choices
  OpenRouterChatCompletionBaseResponseSchema.extend({
    choices: import_v46.z.array(
      import_v46.z.object({
        message: import_v46.z.object({
          role: import_v46.z.literal("assistant"),
          content: import_v46.z.string().nullable().optional(),
          reasoning: import_v46.z.string().nullable().optional(),
          reasoning_details: ReasoningDetailArraySchema.nullish(),
          images: ImageResponseArraySchema.nullish(),
          tool_calls: import_v46.z.array(
            import_v46.z.object({
              id: import_v46.z.string().optional().nullable(),
              type: import_v46.z.literal("function"),
              function: import_v46.z.object({
                name: import_v46.z.string(),
                arguments: import_v46.z.string().optional()
              }).passthrough()
            }).passthrough()
          ).optional(),
          annotations: import_v46.z.array(
            import_v46.z.union([
              // URL citation from web search
              // title, start_index, end_index are optional as some upstream providers may omit them
              import_v46.z.object({
                type: import_v46.z.literal("url_citation"),
                url_citation: import_v46.z.object({
                  url: import_v46.z.string(),
                  title: import_v46.z.string().optional(),
                  start_index: import_v46.z.number().optional(),
                  end_index: import_v46.z.number().optional(),
                  content: import_v46.z.string().optional()
                }).passthrough()
              }).passthrough(),
              // File annotation from FileParserPlugin (old format)
              import_v46.z.object({
                type: import_v46.z.literal("file_annotation"),
                file_annotation: import_v46.z.object({
                  file_id: import_v46.z.string(),
                  quote: import_v46.z.string().optional()
                }).passthrough()
              }).passthrough(),
              // File annotation from FileParserPlugin (new format)
              import_v46.z.object({
                type: import_v46.z.literal("file"),
                file: import_v46.z.object({
                  hash: import_v46.z.string(),
                  name: import_v46.z.string(),
                  content: import_v46.z.array(
                    import_v46.z.object({
                      type: import_v46.z.string(),
                      text: import_v46.z.string().optional()
                    }).passthrough()
                  ).optional()
                }).passthrough()
              }).passthrough()
            ])
          ).nullish()
        }).passthrough(),
        index: import_v46.z.number().nullish(),
        logprobs: import_v46.z.object({
          content: import_v46.z.array(
            import_v46.z.object({
              token: import_v46.z.string(),
              logprob: import_v46.z.number(),
              top_logprobs: import_v46.z.array(
                import_v46.z.object({
                  token: import_v46.z.string(),
                  logprob: import_v46.z.number()
                }).passthrough()
              )
            }).passthrough()
          ).nullable()
        }).passthrough().nullable().optional(),
        finish_reason: import_v46.z.string().optional().nullable()
      }).passthrough()
    )
  }),
  // Error response (HTTP 200 with error payload)
  OpenRouterErrorResponseSchema.extend({
    user_id: import_v46.z.string().optional()
  })
]);
var OpenRouterStreamChatCompletionChunkSchema = import_v46.z.union([
  OpenRouterChatCompletionBaseResponseSchema.extend({
    choices: import_v46.z.array(
      import_v46.z.object({
        delta: import_v46.z.object({
          role: import_v46.z.enum(["assistant"]).optional(),
          content: import_v46.z.string().nullish(),
          reasoning: import_v46.z.string().nullish().optional(),
          reasoning_details: ReasoningDetailArraySchema.nullish(),
          images: ImageResponseArraySchema.nullish(),
          tool_calls: import_v46.z.array(
            import_v46.z.object({
              index: import_v46.z.number().nullish(),
              id: import_v46.z.string().nullish(),
              type: import_v46.z.literal("function").optional(),
              function: import_v46.z.object({
                name: import_v46.z.string().nullish(),
                arguments: import_v46.z.string().nullish()
              }).passthrough()
            }).passthrough()
          ).nullish(),
          annotations: import_v46.z.array(
            import_v46.z.union([
              // URL citation from web search
              // title, start_index, end_index are optional as some upstream providers may omit them
              import_v46.z.object({
                type: import_v46.z.literal("url_citation"),
                url_citation: import_v46.z.object({
                  url: import_v46.z.string(),
                  title: import_v46.z.string().optional(),
                  start_index: import_v46.z.number().optional(),
                  end_index: import_v46.z.number().optional(),
                  content: import_v46.z.string().optional()
                }).passthrough()
              }).passthrough(),
              // File annotation from FileParserPlugin (old format)
              import_v46.z.object({
                type: import_v46.z.literal("file_annotation"),
                file_annotation: import_v46.z.object({
                  file_id: import_v46.z.string(),
                  quote: import_v46.z.string().optional()
                }).passthrough()
              }).passthrough(),
              // File annotation from FileParserPlugin (new format)
              import_v46.z.object({
                type: import_v46.z.literal("file"),
                file: import_v46.z.object({
                  hash: import_v46.z.string(),
                  name: import_v46.z.string(),
                  content: import_v46.z.array(
                    import_v46.z.object({
                      type: import_v46.z.string(),
                      text: import_v46.z.string().optional()
                    }).passthrough()
                  ).optional()
                }).passthrough()
              }).passthrough()
            ])
          ).nullish()
        }).passthrough().nullish(),
        logprobs: import_v46.z.object({
          content: import_v46.z.array(
            import_v46.z.object({
              token: import_v46.z.string(),
              logprob: import_v46.z.number(),
              top_logprobs: import_v46.z.array(
                import_v46.z.object({
                  token: import_v46.z.string(),
                  logprob: import_v46.z.number()
                }).passthrough()
              )
            }).passthrough()
          ).nullable()
        }).passthrough().nullish(),
        finish_reason: import_v46.z.string().nullable().optional(),
        index: import_v46.z.number().nullish()
      }).passthrough()
    )
  }),
  OpenRouterErrorResponseSchema
]);

// src/chat/index.ts
var OpenRouterChatLanguageModel = class {
  constructor(modelId, settings, config) {
    this.specificationVersion = "v3";
    this.provider = "openrouter";
    this.defaultObjectGenerationMode = "tool";
    this.supportsImageUrls = true;
    this.supportedUrls = {
      "image/*": [
        /^data:image\/[a-zA-Z]+;base64,/,
        /^https?:\/\/.+\.(jpg|jpeg|png|gif|webp)$/i
      ],
      // 'text/*': [/^data:text\//, /^https?:\/\/.+$/],
      "application/*": [/^data:application\//, /^https?:\/\/.+$/]
    };
    this.modelId = modelId;
    this.settings = settings;
    this.config = config;
  }
  getArgs({
    prompt,
    maxOutputTokens,
    temperature,
    topP,
    frequencyPenalty,
    presencePenalty,
    seed,
    stopSequences,
    responseFormat,
    topK,
    tools,
    toolChoice
  }) {
    var _a16;
    const baseArgs = __spreadValues(__spreadValues({
      // model id:
      model: this.modelId,
      models: this.settings.models,
      // model specific settings:
      logit_bias: this.settings.logitBias,
      logprobs: this.settings.logprobs === true || typeof this.settings.logprobs === "number" ? true : void 0,
      top_logprobs: typeof this.settings.logprobs === "number" ? this.settings.logprobs : typeof this.settings.logprobs === "boolean" ? this.settings.logprobs ? 0 : void 0 : void 0,
      user: this.settings.user,
      parallel_tool_calls: this.settings.parallelToolCalls,
      // standardized settings:
      max_tokens: maxOutputTokens,
      temperature,
      top_p: topP,
      frequency_penalty: frequencyPenalty,
      presence_penalty: presencePenalty,
      seed,
      stop: stopSequences,
      response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? responseFormat.schema != null ? {
        type: "json_schema",
        json_schema: __spreadValues({
          schema: responseFormat.schema,
          strict: true,
          name: (_a16 = responseFormat.name) != null ? _a16 : "response"
        }, responseFormat.description && {
          description: responseFormat.description
        })
      } : { type: "json_object" } : void 0,
      top_k: topK,
      // messages:
      messages: convertToOpenRouterChatMessages(prompt),
      // OpenRouter specific settings:
      include_reasoning: this.settings.includeReasoning,
      reasoning: this.settings.reasoning,
      usage: this.settings.usage,
      // Web search settings:
      plugins: this.settings.plugins,
      web_search_options: this.settings.web_search_options,
      // Provider routing settings:
      provider: this.settings.provider,
      // Debug settings:
      debug: this.settings.debug
    }, this.config.extraBody), this.settings.extraBody);
    if (tools && tools.length > 0) {
      const mappedTools = tools.filter(
        (tool) => tool.type === "function"
      ).map((tool) => ({
        type: "function",
        function: {
          name: tool.name,
          description: tool.description,
          parameters: tool.inputSchema
        }
      }));
      return __spreadProps(__spreadValues({}, baseArgs), {
        tools: mappedTools,
        tool_choice: toolChoice ? getChatCompletionToolChoice(toolChoice) : void 0
      });
    }
    return baseArgs;
  }
  async doGenerate(options) {
    var _a16, _b16, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B;
    const providerOptions = options.providerOptions || {};
    const openrouterOptions = providerOptions.openrouter || {};
    const args = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);
    const { value: responseValue, responseHeaders } = await postJsonToApi({
      url: this.config.url({
        path: "/chat/completions",
        modelId: this.modelId
      }),
      headers: combineHeaders(this.config.headers(), options.headers),
      body: args,
      failedResponseHandler: openrouterFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler(
        OpenRouterNonStreamChatCompletionResponseSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    if ("error" in responseValue) {
      const errorData = responseValue.error;
      throw new APICallError({
        message: errorData.message,
        url: this.config.url({
          path: "/chat/completions",
          modelId: this.modelId
        }),
        requestBodyValues: args,
        statusCode: 200,
        responseHeaders,
        data: errorData
      });
    }
    const response = responseValue;
    const choice = response.choices[0];
    if (!choice) {
      throw new NoContentGeneratedError({
        message: "No choice in response"
      });
    }
    const usageInfo = response.usage ? {
      inputTokens: {
        total: (_a16 = response.usage.prompt_tokens) != null ? _a16 : 0,
        noCache: void 0,
        cacheRead: (_c = (_b16 = response.usage.prompt_tokens_details) == null ? void 0 : _b16.cached_tokens) != null ? _c : void 0,
        cacheWrite: void 0
      },
      outputTokens: {
        total: (_d = response.usage.completion_tokens) != null ? _d : 0,
        text: void 0,
        reasoning: (_f = (_e = response.usage.completion_tokens_details) == null ? void 0 : _e.reasoning_tokens) != null ? _f : void 0
      },
      raw: response.usage
    } : {
      inputTokens: {
        total: 0,
        noCache: void 0,
        cacheRead: void 0,
        cacheWrite: void 0
      },
      outputTokens: {
        total: 0,
        text: void 0,
        reasoning: void 0
      },
      raw: void 0
    };
    const reasoningDetails = (_g = choice.message.reasoning_details) != null ? _g : [];
    const reasoning = reasoningDetails.length > 0 ? reasoningDetails.map((detail) => {
      switch (detail.type) {
        case "reasoning.text" /* Text */: {
          if (detail.text) {
            return {
              type: "reasoning",
              text: detail.text,
              providerMetadata: {
                openrouter: {
                  reasoning_details: [detail]
                }
              }
            };
          }
          break;
        }
        case "reasoning.summary" /* Summary */: {
          if (detail.summary) {
            return {
              type: "reasoning",
              text: detail.summary,
              providerMetadata: {
                openrouter: {
                  reasoning_details: [detail]
                }
              }
            };
          }
          break;
        }
        case "reasoning.encrypted" /* Encrypted */: {
          if (detail.data) {
            return {
              type: "reasoning",
              text: "[REDACTED]",
              providerMetadata: {
                openrouter: {
                  reasoning_details: [detail]
                }
              }
            };
          }
          break;
        }
        default: {
          detail;
        }
      }
      return null;
    }).filter((p) => p !== null) : choice.message.reasoning ? [
      {
        type: "reasoning",
        text: choice.message.reasoning
      }
    ] : [];
    const content = [];
    content.push(...reasoning);
    if (choice.message.content) {
      content.push({
        type: "text",
        text: choice.message.content
      });
    }
    if (choice.message.tool_calls) {
      let reasoningDetailsAttachedToToolCall = false;
      for (const toolCall of choice.message.tool_calls) {
        content.push({
          type: "tool-call",
          toolCallId: (_h = toolCall.id) != null ? _h : generateId(),
          toolName: toolCall.function.name,
          input: (_i = toolCall.function.arguments) != null ? _i : "{}",
          providerMetadata: !reasoningDetailsAttachedToToolCall ? {
            openrouter: {
              reasoning_details: reasoningDetails
            }
          } : void 0
        });
        reasoningDetailsAttachedToToolCall = true;
      }
    }
    if (choice.message.images) {
      for (const image of choice.message.images) {
        content.push({
          type: "file",
          mediaType: getMediaType(image.image_url.url, "image/jpeg"),
          data: getBase64FromDataUrl(image.image_url.url)
        });
      }
    }
    if (choice.message.annotations) {
      for (const annotation of choice.message.annotations) {
        if (annotation.type === "url_citation") {
          content.push({
            type: "source",
            sourceType: "url",
            id: annotation.url_citation.url,
            url: annotation.url_citation.url,
            title: (_j = annotation.url_citation.title) != null ? _j : "",
            providerMetadata: {
              openrouter: {
                content: (_k = annotation.url_citation.content) != null ? _k : "",
                startIndex: (_l = annotation.url_citation.start_index) != null ? _l : 0,
                endIndex: (_m = annotation.url_citation.end_index) != null ? _m : 0
              }
            }
          });
        }
      }
    }
    const fileAnnotations = (_n = choice.message.annotations) == null ? void 0 : _n.filter(
      (a) => a.type === "file"
    );
    const hasToolCalls = choice.message.tool_calls && choice.message.tool_calls.length > 0;
    const hasEncryptedReasoning = reasoningDetails.some(
      (d) => d.type === "reasoning.encrypted" /* Encrypted */ && d.data
    );
    const shouldOverrideFinishReason = hasToolCalls && hasEncryptedReasoning && choice.finish_reason === "stop";
    const effectiveFinishReason = shouldOverrideFinishReason ? createFinishReason("tool-calls", (_o = choice.finish_reason) != null ? _o : void 0) : mapOpenRouterFinishReason(choice.finish_reason);
    return {
      content,
      finishReason: effectiveFinishReason,
      usage: usageInfo,
      warnings: [],
      providerMetadata: {
        openrouter: OpenRouterProviderMetadataSchema.parse({
          provider: (_p = response.provider) != null ? _p : "",
          reasoning_details: (_q = choice.message.reasoning_details) != null ? _q : [],
          annotations: fileAnnotations && fileAnnotations.length > 0 ? fileAnnotations : void 0,
          usage: __spreadValues(__spreadValues(__spreadValues(__spreadValues({
            promptTokens: (_r = usageInfo.inputTokens.total) != null ? _r : 0,
            completionTokens: (_s = usageInfo.outputTokens.total) != null ? _s : 0,
            totalTokens: ((_t = usageInfo.inputTokens.total) != null ? _t : 0) + ((_u = usageInfo.outputTokens.total) != null ? _u : 0)
          }, ((_v = response.usage) == null ? void 0 : _v.cost) != null ? { cost: response.usage.cost } : {}), ((_x = (_w = response.usage) == null ? void 0 : _w.prompt_tokens_details) == null ? void 0 : _x.cached_tokens) != null ? {
            promptTokensDetails: {
              cachedTokens: response.usage.prompt_tokens_details.cached_tokens
            }
          } : {}), ((_z = (_y = response.usage) == null ? void 0 : _y.completion_tokens_details) == null ? void 0 : _z.reasoning_tokens) != null ? {
            completionTokensDetails: {
              reasoningTokens: response.usage.completion_tokens_details.reasoning_tokens
            }
          } : {}), ((_B = (_A = response.usage) == null ? void 0 : _A.cost_details) == null ? void 0 : _B.upstream_inference_cost) != null ? {
            costDetails: {
              upstreamInferenceCost: response.usage.cost_details.upstream_inference_cost
            }
          } : {})
        })
      },
      request: { body: args },
      response: {
        id: response.id,
        modelId: response.model,
        headers: responseHeaders
      }
    };
  }
  async doStream(options) {
    var _a16;
    const providerOptions = options.providerOptions || {};
    const openrouterOptions = providerOptions.openrouter || {};
    const args = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);
    const { value: response, responseHeaders } = await postJsonToApi({
      url: this.config.url({
        path: "/chat/completions",
        modelId: this.modelId
      }),
      headers: combineHeaders(this.config.headers(), options.headers),
      body: __spreadProps(__spreadValues({}, args), {
        stream: true,
        // only include stream_options when in strict compatibility mode:
        stream_options: this.config.compatibility === "strict" ? __spreadValues({
          include_usage: true
        }, ((_a16 = this.settings.usage) == null ? void 0 : _a16.include) ? { include_usage: true } : {}) : void 0
      }),
      failedResponseHandler: openrouterFailedResponseHandler,
      successfulResponseHandler: createEventSourceResponseHandler(
        OpenRouterStreamChatCompletionChunkSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    const toolCalls = [];
    let finishReason = createFinishReason("other");
    const usage = {
      inputTokens: {
        total: void 0,
        noCache: void 0,
        cacheRead: void 0,
        cacheWrite: void 0
      },
      outputTokens: {
        total: void 0,
        text: void 0,
        reasoning: void 0
      },
      raw: void 0
    };
    const openrouterUsage = {};
    let rawUsage;
    const accumulatedReasoningDetails = [];
    let reasoningDetailsAttachedToToolCall = false;
    const accumulatedFileAnnotations = [];
    let textStarted = false;
    let reasoningStarted = false;
    let textId;
    let reasoningId;
    let openrouterResponseId;
    let provider;
    return {
      stream: response.pipeThrough(
        new TransformStream({
          transform(chunk, controller) {
            var _a17, _b16, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s;
            if (options.includeRawChunks) {
              controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
            }
            if (!chunk.success) {
              finishReason = createFinishReason("error");
              controller.enqueue({ type: "error", error: chunk.error });
              return;
            }
            const value = chunk.value;
            if ("error" in value) {
              finishReason = createFinishReason("error");
              controller.enqueue({ type: "error", error: value.error });
              return;
            }
            if (value.provider) {
              provider = value.provider;
            }
            if (value.id) {
              openrouterResponseId = value.id;
              controller.enqueue({
                type: "response-metadata",
                id: value.id
              });
            }
            if (value.model) {
              controller.enqueue({
                type: "response-metadata",
                modelId: value.model
              });
            }
            if (value.usage != null) {
              usage.inputTokens.total = value.usage.prompt_tokens;
              usage.outputTokens.total = value.usage.completion_tokens;
              rawUsage = value.usage;
              openrouterUsage.promptTokens = value.usage.prompt_tokens;
              if (value.usage.prompt_tokens_details) {
                const cachedInputTokens = (_a17 = value.usage.prompt_tokens_details.cached_tokens) != null ? _a17 : 0;
                usage.inputTokens.cacheRead = cachedInputTokens;
                openrouterUsage.promptTokensDetails = {
                  cachedTokens: cachedInputTokens
                };
              }
              openrouterUsage.completionTokens = value.usage.completion_tokens;
              if (value.usage.completion_tokens_details) {
                const reasoningTokens = (_b16 = value.usage.completion_tokens_details.reasoning_tokens) != null ? _b16 : 0;
                usage.outputTokens.reasoning = reasoningTokens;
                openrouterUsage.completionTokensDetails = {
                  reasoningTokens
                };
              }
              if (value.usage.cost != null) {
                openrouterUsage.cost = value.usage.cost;
              }
              openrouterUsage.totalTokens = value.usage.total_tokens;
              const upstreamInferenceCost = (_c = value.usage.cost_details) == null ? void 0 : _c.upstream_inference_cost;
              if (upstreamInferenceCost != null) {
                openrouterUsage.costDetails = {
                  upstreamInferenceCost
                };
              }
            }
            const choice = value.choices[0];
            if ((choice == null ? void 0 : choice.finish_reason) != null) {
              finishReason = mapOpenRouterFinishReason(choice.finish_reason);
            }
            if ((choice == null ? void 0 : choice.delta) == null) {
              return;
            }
            const delta = choice.delta;
            const emitReasoningChunk = (chunkText, providerMetadata) => {
              if (!reasoningStarted) {
                reasoningId = openrouterResponseId || generateId();
                controller.enqueue({
                  providerMetadata,
                  type: "reasoning-start",
                  id: reasoningId
                });
                reasoningStarted = true;
              }
              controller.enqueue({
                providerMetadata,
                type: "reasoning-delta",
                delta: chunkText,
                id: reasoningId || generateId()
              });
            };
            if (delta.reasoning_details && delta.reasoning_details.length > 0) {
              for (const detail of delta.reasoning_details) {
                if (detail.type === "reasoning.text" /* Text */) {
                  const lastDetail = accumulatedReasoningDetails[accumulatedReasoningDetails.length - 1];
                  if ((lastDetail == null ? void 0 : lastDetail.type) === "reasoning.text" /* Text */) {
                    lastDetail.text = (lastDetail.text || "") + (detail.text || "");
                    lastDetail.signature = lastDetail.signature || detail.signature;
                    lastDetail.format = lastDetail.format || detail.format;
                  } else {
                    accumulatedReasoningDetails.push(__spreadValues({}, detail));
                  }
                } else {
                  accumulatedReasoningDetails.push(detail);
                }
              }
              const reasoningMetadata = {
                openrouter: {
                  reasoning_details: delta.reasoning_details
                }
              };
              for (const detail of delta.reasoning_details) {
                switch (detail.type) {
                  case "reasoning.text" /* Text */: {
                    if (detail.text) {
                      emitReasoningChunk(detail.text, reasoningMetadata);
                    }
                    break;
                  }
                  case "reasoning.encrypted" /* Encrypted */: {
                    if (detail.data) {
                      emitReasoningChunk("[REDACTED]", reasoningMetadata);
                    }
                    break;
                  }
                  case "reasoning.summary" /* Summary */: {
                    if (detail.summary) {
                      emitReasoningChunk(detail.summary, reasoningMetadata);
                    }
                    break;
                  }
                  default: {
                    detail;
                    break;
                  }
                }
              }
            } else if (delta.reasoning) {
              emitReasoningChunk(delta.reasoning);
            }
            if (delta.content) {
              if (reasoningStarted && !textStarted) {
                controller.enqueue({
                  type: "reasoning-end",
                  id: reasoningId || generateId()
                });
                reasoningStarted = false;
              }
              if (!textStarted) {
                textId = openrouterResponseId || generateId();
                controller.enqueue({
                  type: "text-start",
                  id: textId
                });
                textStarted = true;
              }
              controller.enqueue({
                type: "text-delta",
                delta: delta.content,
                id: textId || generateId()
              });
            }
            if (delta.annotations) {
              for (const annotation of delta.annotations) {
                if (annotation.type === "url_citation") {
                  controller.enqueue({
                    type: "source",
                    sourceType: "url",
                    id: annotation.url_citation.url,
                    url: annotation.url_citation.url,
                    title: (_d = annotation.url_citation.title) != null ? _d : "",
                    providerMetadata: {
                      openrouter: {
                        content: (_e = annotation.url_citation.content) != null ? _e : "",
                        startIndex: (_f = annotation.url_citation.start_index) != null ? _f : 0,
                        endIndex: (_g = annotation.url_citation.end_index) != null ? _g : 0
                      }
                    }
                  });
                } else if (annotation.type === "file") {
                  const file = annotation.file;
                  if (file && typeof file === "object" && "hash" in file && "name" in file) {
                    accumulatedFileAnnotations.push(
                      annotation
                    );
                  }
                }
              }
            }
            if (delta.tool_calls != null) {
              for (const toolCallDelta of delta.tool_calls) {
                const index = (_h = toolCallDelta.index) != null ? _h : toolCalls.length - 1;
                if (toolCalls[index] == null) {
                  if (toolCallDelta.type !== "function") {
                    throw new InvalidResponseDataError({
                      data: toolCallDelta,
                      message: `Expected 'function' type.`
                    });
                  }
                  if (toolCallDelta.id == null) {
                    throw new InvalidResponseDataError({
                      data: toolCallDelta,
                      message: `Expected 'id' to be a string.`
                    });
                  }
                  if (((_i = toolCallDelta.function) == null ? void 0 : _i.name) == null) {
                    throw new InvalidResponseDataError({
                      data: toolCallDelta,
                      message: `Expected 'function.name' to be a string.`
                    });
                  }
                  toolCalls[index] = {
                    id: toolCallDelta.id,
                    type: "function",
                    function: {
                      name: toolCallDelta.function.name,
                      arguments: (_j = toolCallDelta.function.arguments) != null ? _j : ""
                    },
                    inputStarted: false,
                    sent: false
                  };
                  const toolCall2 = toolCalls[index];
                  if (toolCall2 == null) {
                    throw new InvalidResponseDataError({
                      data: { index, toolCallsLength: toolCalls.length },
                      message: `Tool call at index ${index} is missing after creation.`
                    });
                  }
                  if (((_k = toolCall2.function) == null ? void 0 : _k.name) != null && ((_l = toolCall2.function) == null ? void 0 : _l.arguments) != null && isParsableJson(toolCall2.function.arguments)) {
                    toolCall2.inputStarted = true;
                    controller.enqueue({
                      type: "tool-input-start",
                      id: toolCall2.id,
                      toolName: toolCall2.function.name
                    });
                    controller.enqueue({
                      type: "tool-input-delta",
                      id: toolCall2.id,
                      delta: toolCall2.function.arguments
                    });
                    controller.enqueue({
                      type: "tool-input-end",
                      id: toolCall2.id
                    });
                    controller.enqueue({
                      type: "tool-call",
                      toolCallId: toolCall2.id,
                      toolName: toolCall2.function.name,
                      input: toolCall2.function.arguments,
                      providerMetadata: !reasoningDetailsAttachedToToolCall ? {
                        openrouter: {
                          reasoning_details: accumulatedReasoningDetails
                        }
                      } : void 0
                    });
                    reasoningDetailsAttachedToToolCall = true;
                    toolCall2.sent = true;
                  }
                  continue;
                }
                const toolCall = toolCalls[index];
                if (toolCall == null) {
                  throw new InvalidResponseDataError({
                    data: {
                      index,
                      toolCallsLength: toolCalls.length,
                      toolCallDelta
                    },
                    message: `Tool call at index ${index} is missing during merge.`
                  });
                }
                if (!toolCall.inputStarted) {
                  toolCall.inputStarted = true;
                  controller.enqueue({
                    type: "tool-input-start",
                    id: toolCall.id,
                    toolName: toolCall.function.name
                  });
                }
                if (((_m = toolCallDelta.function) == null ? void 0 : _m.arguments) != null) {
                  toolCall.function.arguments += (_o = (_n = toolCallDelta.function) == null ? void 0 : _n.arguments) != null ? _o : "";
                }
                controller.enqueue({
                  type: "tool-input-delta",
                  id: toolCall.id,
                  delta: (_p = toolCallDelta.function.arguments) != null ? _p : ""
                });
                if (((_q = toolCall.function) == null ? void 0 : _q.name) != null && ((_r = toolCall.function) == null ? void 0 : _r.arguments) != null && isParsableJson(toolCall.function.arguments)) {
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId: (_s = toolCall.id) != null ? _s : generateId(),
                    toolName: toolCall.function.name,
                    input: toolCall.function.arguments,
                    providerMetadata: !reasoningDetailsAttachedToToolCall ? {
                      openrouter: {
                        reasoning_details: accumulatedReasoningDetails
                      }
                    } : void 0
                  });
                  reasoningDetailsAttachedToToolCall = true;
                  toolCall.sent = true;
                }
              }
            }
            if (delta.images != null) {
              for (const image of delta.images) {
                controller.enqueue({
                  type: "file",
                  mediaType: getMediaType(image.image_url.url, "image/jpeg"),
                  data: getBase64FromDataUrl(image.image_url.url)
                });
              }
            }
          },
          flush(controller) {
            var _a17;
            const hasToolCalls = toolCalls.length > 0;
            const hasEncryptedReasoning = accumulatedReasoningDetails.some(
              (d) => d.type === "reasoning.encrypted" /* Encrypted */ && d.data
            );
            if (hasToolCalls && hasEncryptedReasoning && finishReason.unified === "stop") {
              finishReason = createFinishReason("tool-calls", finishReason.raw);
            }
            if (finishReason.unified === "tool-calls") {
              for (const toolCall of toolCalls) {
                if (toolCall && !toolCall.sent) {
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId: (_a17 = toolCall.id) != null ? _a17 : generateId(),
                    toolName: toolCall.function.name,
                    // Coerce invalid arguments to an empty JSON object
                    input: isParsableJson(toolCall.function.arguments) ? toolCall.function.arguments : "{}",
                    providerMetadata: !reasoningDetailsAttachedToToolCall ? {
                      openrouter: {
                        reasoning_details: accumulatedReasoningDetails
                      }
                    } : void 0
                  });
                  reasoningDetailsAttachedToToolCall = true;
                  toolCall.sent = true;
                }
              }
            }
            if (reasoningStarted) {
              controller.enqueue({
                type: "reasoning-end",
                id: reasoningId || generateId()
              });
            }
            if (textStarted) {
              controller.enqueue({
                type: "text-end",
                id: textId || generateId()
              });
            }
            const openrouterMetadata = {
              usage: openrouterUsage
            };
            if (provider !== void 0) {
              openrouterMetadata.provider = provider;
            }
            if (accumulatedReasoningDetails.length > 0) {
              openrouterMetadata.reasoning_details = accumulatedReasoningDetails;
            }
            if (accumulatedFileAnnotations.length > 0) {
              openrouterMetadata.annotations = accumulatedFileAnnotations;
            }
            usage.raw = rawUsage;
            controller.enqueue({
              type: "finish",
              finishReason,
              usage,
              providerMetadata: {
                openrouter: openrouterMetadata
              }
            });
          }
        })
      ),
      warnings: [],
      request: { body: args },
      response: { headers: responseHeaders }
    };
  }
};

// src/completion/convert-to-openrouter-completion-prompt.ts
function convertToOpenRouterCompletionPrompt({
  prompt,
  inputFormat,
  user = "user",
  assistant = "assistant"
}) {
  if (inputFormat === "prompt" && prompt.length === 1 && prompt[0] && prompt[0].role === "user" && prompt[0].content.length === 1 && prompt[0].content[0] && prompt[0].content[0].type === "text") {
    return { prompt: prompt[0].content[0].text };
  }
  let text = "";
  if (prompt[0] && prompt[0].role === "system") {
    text += `${prompt[0].content}

`;
    prompt = prompt.slice(1);
  }
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        throw new InvalidPromptError({
          message: `Unexpected system message in prompt: ${content}`,
          prompt
        });
      }
      case "user": {
        const userMessage = content.map((part) => {
          switch (part.type) {
            case "text": {
              return part.text;
            }
            case "file": {
              throw new UnsupportedFunctionalityError({
                functionality: "file attachments"
              });
            }
            default: {
              return "";
            }
          }
        }).join("");
        text += `${user}:
${userMessage}

`;
        break;
      }
      case "assistant": {
        const assistantMessage = content.map(
          (part) => {
            switch (part.type) {
              case "text": {
                return part.text;
              }
              case "tool-call": {
                throw new UnsupportedFunctionalityError({
                  functionality: "tool-call messages"
                });
              }
              case "tool-result": {
                throw new UnsupportedFunctionalityError({
                  functionality: "tool-result messages"
                });
              }
              case "reasoning": {
                throw new UnsupportedFunctionalityError({
                  functionality: "reasoning messages"
                });
              }
              case "file": {
                throw new UnsupportedFunctionalityError({
                  functionality: "file attachments"
                });
              }
              default: {
                return "";
              }
            }
          }
        ).join("");
        text += `${assistant}:
${assistantMessage}

`;
        break;
      }
      case "tool": {
        throw new UnsupportedFunctionalityError({
          functionality: "tool messages"
        });
      }
      default: {
        break;
      }
    }
  }
  text += `${assistant}:
`;
  return {
    prompt: text
  };
}

// src/completion/schemas.ts
var import_v47 = require("zod/v4");
var OpenRouterCompletionChunkSchema = import_v47.z.union([
  import_v47.z.object({
    id: import_v47.z.string().optional(),
    model: import_v47.z.string().optional(),
    provider: import_v47.z.string().optional(),
    choices: import_v47.z.array(
      import_v47.z.object({
        text: import_v47.z.string(),
        reasoning: import_v47.z.string().nullish().optional(),
        reasoning_details: ReasoningDetailArraySchema.nullish(),
        finish_reason: import_v47.z.string().nullish(),
        index: import_v47.z.number().nullish(),
        logprobs: import_v47.z.object({
          tokens: import_v47.z.array(import_v47.z.string()),
          token_logprobs: import_v47.z.array(import_v47.z.number()),
          top_logprobs: import_v47.z.array(import_v47.z.record(import_v47.z.string(), import_v47.z.number())).nullable()
        }).passthrough().nullable().optional()
      }).passthrough()
    ),
    usage: import_v47.z.object({
      prompt_tokens: import_v47.z.number(),
      prompt_tokens_details: import_v47.z.object({
        cached_tokens: import_v47.z.number()
      }).passthrough().nullish(),
      completion_tokens: import_v47.z.number(),
      completion_tokens_details: import_v47.z.object({
        reasoning_tokens: import_v47.z.number()
      }).passthrough().nullish(),
      total_tokens: import_v47.z.number(),
      cost: import_v47.z.number().optional(),
      cost_details: import_v47.z.object({
        upstream_inference_cost: import_v47.z.number().nullish()
      }).passthrough().nullish()
    }).passthrough().nullish()
  }).passthrough(),
  OpenRouterErrorResponseSchema
]);

// src/completion/index.ts
var OpenRouterCompletionLanguageModel = class {
  constructor(modelId, settings, config) {
    this.specificationVersion = "v3";
    this.provider = "openrouter";
    this.supportsImageUrls = true;
    this.supportedUrls = {
      "image/*": [
        /^data:image\/[a-zA-Z]+;base64,/,
        /^https?:\/\/.+\.(jpg|jpeg|png|gif|webp)$/i
      ],
      "text/*": [/^data:text\//, /^https?:\/\/.+$/],
      "application/*": [/^data:application\//, /^https?:\/\/.+$/]
    };
    this.defaultObjectGenerationMode = void 0;
    this.modelId = modelId;
    this.settings = settings;
    this.config = config;
  }
  getArgs({
    prompt,
    maxOutputTokens,
    temperature,
    topP,
    frequencyPenalty,
    presencePenalty,
    seed,
    responseFormat,
    topK,
    stopSequences,
    tools,
    toolChoice
  }) {
    const { prompt: completionPrompt } = convertToOpenRouterCompletionPrompt({
      prompt,
      inputFormat: "prompt"
    });
    if (tools == null ? void 0 : tools.length) {
      throw new UnsupportedFunctionalityError({
        functionality: "tools"
      });
    }
    if (toolChoice) {
      throw new UnsupportedFunctionalityError({
        functionality: "toolChoice"
      });
    }
    return __spreadValues(__spreadValues({
      // model id:
      model: this.modelId,
      models: this.settings.models,
      // model specific settings:
      logit_bias: this.settings.logitBias,
      logprobs: typeof this.settings.logprobs === "number" ? this.settings.logprobs : typeof this.settings.logprobs === "boolean" ? this.settings.logprobs ? 0 : void 0 : void 0,
      suffix: this.settings.suffix,
      user: this.settings.user,
      // standardized settings:
      max_tokens: maxOutputTokens,
      temperature,
      top_p: topP,
      frequency_penalty: frequencyPenalty,
      presence_penalty: presencePenalty,
      seed,
      stop: stopSequences,
      response_format: responseFormat,
      top_k: topK,
      // prompt:
      prompt: completionPrompt,
      // OpenRouter specific settings:
      include_reasoning: this.settings.includeReasoning,
      reasoning: this.settings.reasoning
    }, this.config.extraBody), this.settings.extraBody);
  }
  async doGenerate(options) {
    var _a16, _b16, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B;
    const providerOptions = options.providerOptions || {};
    const openrouterOptions = providerOptions.openrouter || {};
    const args = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);
    const { value: response, responseHeaders } = await postJsonToApi({
      url: this.config.url({
        path: "/completions",
        modelId: this.modelId
      }),
      headers: combineHeaders(this.config.headers(), options.headers),
      body: args,
      failedResponseHandler: openrouterFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler(
        OpenRouterCompletionChunkSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    if ("error" in response) {
      const errorData = response.error;
      throw new APICallError({
        message: errorData.message,
        url: this.config.url({
          path: "/completions",
          modelId: this.modelId
        }),
        requestBodyValues: args,
        statusCode: 200,
        responseHeaders,
        data: errorData
      });
    }
    const choice = response.choices[0];
    if (!choice) {
      throw new NoContentGeneratedError({
        message: "No choice in OpenRouter completion response"
      });
    }
    return {
      content: [
        {
          type: "text",
          text: (_a16 = choice.text) != null ? _a16 : ""
        }
      ],
      finishReason: mapOpenRouterFinishReason(choice.finish_reason),
      usage: {
        inputTokens: {
          total: (_c = (_b16 = response.usage) == null ? void 0 : _b16.prompt_tokens) != null ? _c : 0,
          noCache: void 0,
          cacheRead: (_f = (_e = (_d = response.usage) == null ? void 0 : _d.prompt_tokens_details) == null ? void 0 : _e.cached_tokens) != null ? _f : void 0,
          cacheWrite: void 0
        },
        outputTokens: {
          total: (_h = (_g = response.usage) == null ? void 0 : _g.completion_tokens) != null ? _h : 0,
          text: void 0,
          reasoning: (_k = (_j = (_i = response.usage) == null ? void 0 : _i.completion_tokens_details) == null ? void 0 : _j.reasoning_tokens) != null ? _k : void 0
        },
        raw: (_l = response.usage) != null ? _l : void 0
      },
      warnings: [],
      providerMetadata: {
        openrouter: OpenRouterProviderMetadataSchema.parse({
          provider: (_m = response.provider) != null ? _m : "",
          usage: __spreadValues(__spreadValues(__spreadValues(__spreadValues({
            promptTokens: (_o = (_n = response.usage) == null ? void 0 : _n.prompt_tokens) != null ? _o : 0,
            completionTokens: (_q = (_p = response.usage) == null ? void 0 : _p.completion_tokens) != null ? _q : 0,
            totalTokens: ((_s = (_r = response.usage) == null ? void 0 : _r.prompt_tokens) != null ? _s : 0) + ((_u = (_t = response.usage) == null ? void 0 : _t.completion_tokens) != null ? _u : 0)
          }, ((_v = response.usage) == null ? void 0 : _v.cost) != null ? { cost: response.usage.cost } : {}), ((_x = (_w = response.usage) == null ? void 0 : _w.prompt_tokens_details) == null ? void 0 : _x.cached_tokens) != null ? {
            promptTokensDetails: {
              cachedTokens: response.usage.prompt_tokens_details.cached_tokens
            }
          } : {}), ((_z = (_y = response.usage) == null ? void 0 : _y.completion_tokens_details) == null ? void 0 : _z.reasoning_tokens) != null ? {
            completionTokensDetails: {
              reasoningTokens: response.usage.completion_tokens_details.reasoning_tokens
            }
          } : {}), ((_B = (_A = response.usage) == null ? void 0 : _A.cost_details) == null ? void 0 : _B.upstream_inference_cost) != null ? {
            costDetails: {
              upstreamInferenceCost: response.usage.cost_details.upstream_inference_cost
            }
          } : {})
        })
      },
      response: {
        headers: responseHeaders
      }
    };
  }
  async doStream(options) {
    const providerOptions = options.providerOptions || {};
    const openrouterOptions = providerOptions.openrouter || {};
    const args = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);
    const { value: response, responseHeaders } = await postJsonToApi({
      url: this.config.url({
        path: "/completions",
        modelId: this.modelId
      }),
      headers: combineHeaders(this.config.headers(), options.headers),
      body: __spreadProps(__spreadValues({}, args), {
        stream: true,
        // only include stream_options when in strict compatibility mode:
        stream_options: this.config.compatibility === "strict" ? { include_usage: true } : void 0
      }),
      failedResponseHandler: openrouterFailedResponseHandler,
      successfulResponseHandler: createEventSourceResponseHandler(
        OpenRouterCompletionChunkSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    let finishReason = createFinishReason("other");
    const usage = {
      inputTokens: {
        total: void 0,
        noCache: void 0,
        cacheRead: void 0,
        cacheWrite: void 0
      },
      outputTokens: {
        total: void 0,
        text: void 0,
        reasoning: void 0
      },
      raw: void 0
    };
    const openrouterUsage = {};
    let provider;
    let rawUsage;
    return {
      stream: response.pipeThrough(
        new TransformStream({
          transform(chunk, controller) {
            var _a16, _b16, _c;
            if (options.includeRawChunks) {
              controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
            }
            if (!chunk.success) {
              finishReason = createFinishReason("error");
              controller.enqueue({ type: "error", error: chunk.error });
              return;
            }
            const value = chunk.value;
            if ("error" in value) {
              finishReason = createFinishReason("error");
              controller.enqueue({ type: "error", error: value.error });
              return;
            }
            if (value.provider) {
              provider = value.provider;
            }
            if (value.usage != null) {
              usage.inputTokens.total = value.usage.prompt_tokens;
              usage.outputTokens.total = value.usage.completion_tokens;
              rawUsage = value.usage;
              openrouterUsage.promptTokens = value.usage.prompt_tokens;
              if (value.usage.prompt_tokens_details) {
                const cachedInputTokens = (_a16 = value.usage.prompt_tokens_details.cached_tokens) != null ? _a16 : 0;
                usage.inputTokens.cacheRead = cachedInputTokens;
                openrouterUsage.promptTokensDetails = {
                  cachedTokens: cachedInputTokens
                };
              }
              openrouterUsage.completionTokens = value.usage.completion_tokens;
              if (value.usage.completion_tokens_details) {
                const reasoningTokens = (_b16 = value.usage.completion_tokens_details.reasoning_tokens) != null ? _b16 : 0;
                usage.outputTokens.reasoning = reasoningTokens;
                openrouterUsage.completionTokensDetails = {
                  reasoningTokens
                };
              }
              if (value.usage.cost != null) {
                openrouterUsage.cost = value.usage.cost;
              }
              openrouterUsage.totalTokens = value.usage.total_tokens;
              const upstreamInferenceCost = (_c = value.usage.cost_details) == null ? void 0 : _c.upstream_inference_cost;
              if (upstreamInferenceCost != null) {
                openrouterUsage.costDetails = {
                  upstreamInferenceCost
                };
              }
            }
            const choice = value.choices[0];
            if ((choice == null ? void 0 : choice.finish_reason) != null) {
              finishReason = mapOpenRouterFinishReason(choice.finish_reason);
            }
            if ((choice == null ? void 0 : choice.text) != null) {
              controller.enqueue({
                type: "text-delta",
                delta: choice.text,
                id: generateId()
              });
            }
          },
          flush(controller) {
            usage.raw = rawUsage;
            const openrouterMetadata = {
              usage: openrouterUsage
            };
            if (provider !== void 0) {
              openrouterMetadata.provider = provider;
            }
            controller.enqueue({
              type: "finish",
              finishReason,
              usage,
              providerMetadata: {
                openrouter: openrouterMetadata
              }
            });
          }
        })
      ),
      response: {
        headers: responseHeaders
      }
    };
  }
};

// src/embedding/schemas.ts
var import_v48 = require("zod/v4");
var openrouterEmbeddingUsageSchema = import_v48.z.object({
  prompt_tokens: import_v48.z.number(),
  total_tokens: import_v48.z.number(),
  cost: import_v48.z.number().optional()
});
var openrouterEmbeddingDataSchema = import_v48.z.object({
  object: import_v48.z.literal("embedding"),
  embedding: import_v48.z.array(import_v48.z.number()),
  index: import_v48.z.number().optional()
});
var OpenRouterEmbeddingResponseSchema = import_v48.z.object({
  id: import_v48.z.string().optional(),
  object: import_v48.z.literal("list"),
  data: import_v48.z.array(openrouterEmbeddingDataSchema),
  model: import_v48.z.string(),
  provider: import_v48.z.string().optional(),
  usage: openrouterEmbeddingUsageSchema.optional()
});

// src/embedding/index.ts
var OpenRouterEmbeddingModel = class {
  constructor(modelId, settings, config) {
    this.specificationVersion = "v3";
    this.provider = "openrouter";
    this.maxEmbeddingsPerCall = void 0;
    this.supportsParallelCalls = true;
    this.modelId = modelId;
    this.settings = settings;
    this.config = config;
  }
  async doEmbed(options) {
    var _a16, _b16, _c, _d, _e, _f;
    const { values, abortSignal, headers } = options;
    const args = __spreadValues(__spreadValues({
      model: this.modelId,
      input: values,
      user: this.settings.user,
      provider: this.settings.provider
    }, this.config.extraBody), this.settings.extraBody);
    const { value: responseValue, responseHeaders } = await postJsonToApi({
      url: this.config.url({
        path: "/embeddings",
        modelId: this.modelId
      }),
      headers: combineHeaders(this.config.headers(), headers),
      body: args,
      failedResponseHandler: openrouterFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler(
        OpenRouterEmbeddingResponseSchema
      ),
      abortSignal,
      fetch: this.config.fetch
    });
    return {
      embeddings: responseValue.data.map((item) => item.embedding),
      usage: responseValue.usage ? { tokens: responseValue.usage.prompt_tokens } : void 0,
      providerMetadata: {
        openrouter: OpenRouterProviderMetadataSchema.parse({
          provider: (_a16 = responseValue.provider) != null ? _a16 : "",
          usage: __spreadValues({
            promptTokens: (_c = (_b16 = responseValue.usage) == null ? void 0 : _b16.prompt_tokens) != null ? _c : 0,
            completionTokens: 0,
            totalTokens: (_e = (_d = responseValue.usage) == null ? void 0 : _d.total_tokens) != null ? _e : 0
          }, ((_f = responseValue.usage) == null ? void 0 : _f.cost) != null ? { cost: responseValue.usage.cost } : {})
        })
      },
      response: {
        headers: responseHeaders,
        body: responseValue
      },
      warnings: []
    };
  }
};

// src/facade.ts
var OpenRouter = class {
  /**
   * Creates a new OpenRouter provider instance.
   */
  constructor(options = {}) {
    var _a16, _b16;
    this.baseURL = (_b16 = withoutTrailingSlash((_a16 = options.baseURL) != null ? _a16 : options.baseUrl)) != null ? _b16 : "https://openrouter.ai/api/v1";
    this.apiKey = options.apiKey;
    this.headers = options.headers;
    this.api_keys = options.api_keys;
  }
  get baseConfig() {
    return {
      baseURL: this.baseURL,
      headers: () => __spreadValues(__spreadValues({
        Authorization: `Bearer ${loadApiKey({
          apiKey: this.apiKey,
          environmentVariableName: "OPENROUTER_API_KEY",
          description: "OpenRouter"
        })}`
      }, this.headers), this.api_keys && Object.keys(this.api_keys).length > 0 && {
        "X-Provider-API-Keys": JSON.stringify(this.api_keys)
      })
    };
  }
  chat(modelId, settings = {}) {
    return new OpenRouterChatLanguageModel(modelId, settings, __spreadProps(__spreadValues({
      provider: "openrouter.chat"
    }, this.baseConfig), {
      compatibility: "strict",
      url: ({ path }) => `${this.baseURL}${path}`
    }));
  }
  completion(modelId, settings = {}) {
    return new OpenRouterCompletionLanguageModel(modelId, settings, __spreadProps(__spreadValues({
      provider: "openrouter.completion"
    }, this.baseConfig), {
      compatibility: "strict",
      url: ({ path }) => `${this.baseURL}${path}`
    }));
  }
  textEmbeddingModel(modelId, settings = {}) {
    return new OpenRouterEmbeddingModel(modelId, settings, __spreadProps(__spreadValues({
      provider: "openrouter.embedding"
    }, this.baseConfig), {
      url: ({ path }) => `${this.baseURL}${path}`
    }));
  }
  /**
   * @deprecated Use textEmbeddingModel instead
   */
  embedding(modelId, settings = {}) {
    return this.textEmbeddingModel(modelId, settings);
  }
};

// src/image/schemas.ts
var import_v49 = require("zod/v4");
var OpenRouterImageResponseSchema = import_v49.z.object({
  id: import_v49.z.string().optional(),
  object: import_v49.z.string().optional(),
  created: import_v49.z.number().optional(),
  model: import_v49.z.string(),
  choices: import_v49.z.array(
    import_v49.z.object({
      index: import_v49.z.number(),
      message: import_v49.z.object({
        role: import_v49.z.string(),
        content: import_v49.z.string().nullable().optional(),
        images: import_v49.z.array(
          import_v49.z.object({
            type: import_v49.z.literal("image_url"),
            image_url: import_v49.z.object({
              url: import_v49.z.string()
            })
          }).passthrough()
        ).optional()
      }).passthrough(),
      finish_reason: import_v49.z.string().nullable().optional()
    }).passthrough()
  ),
  usage: import_v49.z.object({
    prompt_tokens: import_v49.z.number(),
    completion_tokens: import_v49.z.number(),
    total_tokens: import_v49.z.number()
  }).passthrough().optional()
}).passthrough();

// src/image/index.ts
var OpenRouterImageModel = class {
  constructor(modelId, settings, config) {
    this.specificationVersion = "v3";
    this.provider = "openrouter";
    this.maxImagesPerCall = 1;
    this.modelId = modelId;
    this.settings = settings;
    this.config = config;
  }
  async doGenerate(options) {
    var _a16;
    const {
      prompt,
      n,
      size,
      aspectRatio,
      seed,
      files,
      mask,
      abortSignal,
      headers,
      providerOptions
    } = options;
    const openrouterOptions = (providerOptions == null ? void 0 : providerOptions.openrouter) || {};
    const warnings = [];
    if (files !== void 0 && files.length > 0) {
      throw new UnsupportedFunctionalityError({
        functionality: "image editing (files parameter)"
      });
    }
    if (mask !== void 0) {
      throw new UnsupportedFunctionalityError({
        functionality: "image inpainting (mask parameter)"
      });
    }
    if (n > 1) {
      warnings.push({
        type: "unsupported",
        feature: "n > 1",
        details: `OpenRouter image generation returns 1 image per call. Requested ${n} images.`
      });
    }
    if (size !== void 0) {
      warnings.push({
        type: "unsupported",
        feature: "size",
        details: "Use aspectRatio instead. Size parameter is not supported by OpenRouter image generation."
      });
    }
    const imageConfig = aspectRatio !== void 0 ? { aspect_ratio: aspectRatio } : void 0;
    const body = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
      model: this.modelId,
      messages: [
        {
          role: "user",
          content: prompt != null ? prompt : ""
        }
      ],
      modalities: ["image", "text"]
    }, imageConfig !== void 0 && { image_config: imageConfig }), seed !== void 0 && { seed }), this.settings.user !== void 0 && { user: this.settings.user }), this.settings.provider !== void 0 && {
      provider: this.settings.provider
    }), this.config.extraBody), this.settings.extraBody), openrouterOptions);
    const { value: responseValue, responseHeaders } = await postJsonToApi({
      url: this.config.url({
        path: "/chat/completions",
        modelId: this.modelId
      }),
      headers: combineHeaders(this.config.headers(), headers),
      body,
      failedResponseHandler: openrouterFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler(
        OpenRouterImageResponseSchema
      ),
      abortSignal,
      fetch: this.config.fetch
    });
    const choice = responseValue.choices[0];
    if (!choice) {
      throw new NoContentGeneratedError({
        message: "No choice in response"
      });
    }
    const images = [];
    if ((_a16 = choice.message) == null ? void 0 : _a16.images) {
      for (const image of choice.message.images) {
        const dataUrl = image.image_url.url;
        images.push(getBase64FromDataUrl(dataUrl));
      }
    }
    const usage = responseValue.usage ? {
      inputTokens: responseValue.usage.prompt_tokens,
      outputTokens: responseValue.usage.completion_tokens,
      totalTokens: responseValue.usage.total_tokens
    } : void 0;
    return {
      images,
      warnings,
      response: {
        timestamp: /* @__PURE__ */ new Date(),
        modelId: responseValue.model,
        headers: responseHeaders
      },
      usage
    };
  }
};

// src/utils/remove-undefined.ts
function removeUndefinedEntries(record) {
  return Object.fromEntries(
    Object.entries(record).filter(([, value]) => value != null)
  );
}

// src/utils/with-user-agent-suffix.ts
function normalizeHeaders2(headers) {
  if (!headers) {
    return {};
  }
  if (headers instanceof Headers) {
    return Object.fromEntries(headers.entries());
  }
  if (Array.isArray(headers)) {
    return Object.fromEntries(headers);
  }
  return headers;
}
function findHeaderKey(headers, targetKey) {
  const lowerTarget = targetKey.toLowerCase();
  return Object.keys(headers).find((key) => key.toLowerCase() === lowerTarget);
}
function withUserAgentSuffix2(headers, ...userAgentSuffixParts) {
  const normalizedHeaders = normalizeHeaders2(headers);
  const cleanedHeaders = removeUndefinedEntries(normalizedHeaders);
  const existingUserAgentKey = findHeaderKey(cleanedHeaders, "user-agent");
  const existingUserAgentValue = existingUserAgentKey ? cleanedHeaders[existingUserAgentKey] : void 0;
  const userAgent = (existingUserAgentValue == null ? void 0 : existingUserAgentValue.trim()) ? existingUserAgentValue : userAgentSuffixParts.filter(Boolean).join(" ");
  const headersWithoutUserAgent = Object.fromEntries(
    Object.entries(cleanedHeaders).filter(
      ([key]) => key.toLowerCase() !== "user-agent"
    )
  );
  return __spreadProps(__spreadValues({}, headersWithoutUserAgent), {
    "user-agent": userAgent
  });
}

// src/version.ts
var VERSION2 = false ? "0.0.0-test" : "2.1.1";

// src/provider.ts
function createOpenRouter(options = {}) {
  var _a16, _b16, _c;
  const baseURL = (_b16 = withoutTrailingSlash((_a16 = options.baseURL) != null ? _a16 : options.baseUrl)) != null ? _b16 : "https://openrouter.ai/api/v1";
  const compatibility = (_c = options.compatibility) != null ? _c : "compatible";
  const getHeaders = () => withUserAgentSuffix2(
    __spreadValues(__spreadValues({
      Authorization: `Bearer ${loadApiKey({
        apiKey: options.apiKey,
        environmentVariableName: "OPENROUTER_API_KEY",
        description: "OpenRouter"
      })}`
    }, options.headers), options.api_keys && Object.keys(options.api_keys).length > 0 && {
      "X-Provider-API-Keys": JSON.stringify(options.api_keys)
    }),
    `ai-sdk/openrouter/${VERSION2}`
  );
  const createChatModel = (modelId, settings = {}) => new OpenRouterChatLanguageModel(modelId, settings, {
    provider: "openrouter.chat",
    url: ({ path }) => `${baseURL}${path}`,
    headers: getHeaders,
    compatibility,
    fetch: options.fetch,
    extraBody: options.extraBody
  });
  const createCompletionModel = (modelId, settings = {}) => new OpenRouterCompletionLanguageModel(modelId, settings, {
    provider: "openrouter.completion",
    url: ({ path }) => `${baseURL}${path}`,
    headers: getHeaders,
    compatibility,
    fetch: options.fetch,
    extraBody: options.extraBody
  });
  const createEmbeddingModel = (modelId, settings = {}) => new OpenRouterEmbeddingModel(modelId, settings, {
    provider: "openrouter.embedding",
    url: ({ path }) => `${baseURL}${path}`,
    headers: getHeaders,
    fetch: options.fetch,
    extraBody: options.extraBody
  });
  const createImageModel = (modelId, settings = {}) => new OpenRouterImageModel(modelId, settings, {
    provider: "openrouter.image",
    url: ({ path }) => `${baseURL}${path}`,
    headers: getHeaders,
    fetch: options.fetch,
    extraBody: options.extraBody
  });
  const createLanguageModel = (modelId, settings) => {
    if (new.target) {
      throw new Error(
        "The OpenRouter model function cannot be called with the new keyword."
      );
    }
    if (modelId === "openai/gpt-3.5-turbo-instruct") {
      return createCompletionModel(
        modelId,
        settings
      );
    }
    return createChatModel(modelId, settings);
  };
  const provider = (modelId, settings) => createLanguageModel(modelId, settings);
  provider.languageModel = createLanguageModel;
  provider.chat = createChatModel;
  provider.completion = createCompletionModel;
  provider.textEmbeddingModel = createEmbeddingModel;
  provider.embedding = createEmbeddingModel;
  provider.imageModel = createImageModel;
  return provider;
}
var openrouter = createOpenRouter({
  compatibility: "strict"
  // strict for OpenRouter API
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  OpenRouter,
  createOpenRouter,
  openrouter
});
//# sourceMappingURL=index.js.map